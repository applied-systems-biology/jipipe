[
{
	"uri": "https://www.jipipe.org/documentation/basic-concepts/",
	"title": "Basic concepts",
	"tags": [],
	"description": "",
	"content": "This section explains some basic concepts that are helpful to understand if you want to use JIPipe.\n Visual programming\nExplains the basics of visual programming.\n  Batch processing\nExplains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/create-pipelines/",
	"title": "Creating pipelines",
	"tags": [],
	"description": "",
	"content": "This section explains the JIPipe user interface, how to create an analysis pipeline, and some concepts behind how analysis pipelines work.\n Pipeline editor\nExplains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.\n  Expression parameters\nExplains the expression parameter type language that is often used for filtering or generating numbers.\n  Graph compartments\nExplains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.\n  Group nodes\nExplains the group node feature.\n  Loop nodes\nExplains the loop node feature.\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/run-pipelines/",
	"title": "Running pipelines",
	"tags": [],
	"description": "",
	"content": "This section contains documentation that explains how to run a pipeline and review the results. For example, you can run the whole workflow or make use of the cache feature to run single nodes.\n Running the whole pipeline\nExplains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.\n  Review results\nExplains how to review results.\n  Use results in external software\nJIPipe stores outputs in a standardized format that can be easily read with third-party software. The output folder of always contains a file project.jip, which is the project that generated the output. This folder contains sub-folders named according to the graph compartment. The ID is the unique ID of the graph compartment and can be looked up in the project.jip file or the compartment graph editor. Each of these compartment folders contains a set of additional sub-folders based on unique ID of the node (also visible in the graph editor).\n  Running a single node\nExplains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.\n  Data caching\nExplains the how JIPipe caches intermediate results and how to access them.\n  "
},
{
	"uri": "https://www.jipipe.org/faq/general/",
	"title": "General questions",
	"tags": [],
	"description": "General questions about JIPipe",
	"content": "Where do I find documentations? You can find all documentations in the  menu at the top right.\nThere are also context-based documentations available if you select a node in the graph. Hover your mouse over a parameter to show documentations for this parameter only.\nDoes JIPipe have a backup function? Yes. By default, JIPipe creates a backup every 3 minutes. You can recover it via Project \u0026gt; Restore Backup.\nCan I make the startup faster? Many JIPipe extensions rely on other ImageJ plugins to work. That is why JIPipe always checks if all necessary ImageJ plugins are available. If you are sure that you have everything installed, you can disable this check at Project \u0026gt; Application settings \u0026gt; General \u0026gt; Extensions. Disable Validate ImageJ dependencies.\nIf you do not have access to these setting (because you are offline or there are issues with the ImageJ servers), open the file jipipe.properties.json (located in your ImageJ directory) in a text editor search for a line \u0026quot;extensions/validate-imagej-dependencies\u0026quot; : true and replace true by false.\nIf the file is not present, create a new file and put following text into it:\n{\r\u0026quot;extensions/validate-imagej-dependencies\u0026quot; : false\r}\rJIPipe will automatically add the other settings on the first startup.\nCan I expose a set of specific parameters for collaborators? Yes. You can do this via the Project \u0026gt; Project settings \u0026gt; Parameters. They will be available in Project \u0026gt; Project overview, alongside the description that can be set in Project \u0026gt; Project settings \u0026gt; General.\nCan I add my author information to a project? Yes. Go to Project \u0026gt; Project settings \u0026gt; General. Here you can add multiple authors (including affiliation), provide a citation, license, and website, as well as cite other projects.\nWhere should I place files if I want to make the project portable? JIPipe automatically relativizes file paths if you place data files in the same folder as the project (or in a subfolder). This allows you to compress the project and share it with other without breaking anything.\nThis is the recommended way to do share your projects if you have multiple operating systems.\nHow can I copy / delete the global settings? JIPipe places a file jipipe.properties.json into your ImageJ directory. You can delete it to reset all settings to their defaults or copy it to another JIPipe instance.\n"
},
{
	"uri": "https://www.jipipe.org/_header/",
	"title": "Header",
	"tags": [],
	"description": "",
	"content": "\n"
},
{
	"uri": "https://www.jipipe.org/faq/user-interface/",
	"title": "User interface",
	"tags": [],
	"description": "Questions concerning the user interface",
	"content": "Does JIPipe have a dark mode? Yes, you can enable it in Project \u0026gt; Application settings \u0026gt; UI \u0026gt; General \u0026gt; Theme. Set the theme to Modern dark and restart JIPipe/ImageJ.\nThe nodes are so large. Can they be more compact? Yes, there are multiple view modes available, including a horizontal and compact vertical mode. See here for more info.\nHow can I make long connections without zooming out? Click the arrow button at the input/output slot. It lists all compatible sources/targets ordered by distance.\nWhy is the user interface suddenly messed up on Windows? This is a known issue with the open/save dialogs that are used on Windows. They cause to overwrite JIPipe\u0026rsquo;s design. We have not yet found a solution for this. We recommend to configure ImageJ to use the Java file dialogs, not the native Windows dialogs.\n"
},
{
	"uri": "https://www.jipipe.org/faq/data-processing/",
	"title": "Data processing",
	"tags": [],
	"description": "Questions about how data is processed",
	"content": "What are those compartments for? Imagine you have a large complicated pipeline. Most certainly, you could split it into multiple sub-pipelines like \u0026ldquo;preprocessing\u0026rdquo; or \u0026ldquo;segmentation\u0026rdquo;. Compartments allow you to do exactly this.\nWhat is the difference between groups and compartments? If you use compartments, JIPipe is still aware of the whole pipeline. This allows it to run all dependency nodes via Update cache or Quick run. Groups are independent pipelines that are not aware where they are used. You can only extract the final outputs, not intermediate steps.\nWhat happens if I put multiple inputs into a slot? Because each slot holds a table of data and metadata, those tables are merged row-wise.\n\rShow example\r\r\r\rWhy should I care to add those annotations? Annotations are optional for single data analyses or pipelines without multi-input nodes, but helpful anyways. They will allow you to quickly find out from which data set your data was generated.\nIf you have a multi-input node, you will need annotations, as JIPipe needs to figure out which data from which input belongs together.\nYou will find more information here.\nCan you give me an example of multi-input processing? \rShow example\r\r\rThe merge channels node has two inputs (one for each channel) and at some point needs to assign which of the input images belong together.\rThis assignment is here visualized as \"intermediate merged input table\".\rTo achieve this with multiple rows in the input tables, JIPipe utlizes the additional annotation columns (here #Dataset) to group the input rows by these columns.\r\r\r\rWhy do you create annotations with a \u0026lsquo;#\u0026rsquo;? There are two kinds of annotations: Ones that only you care about (e.g. the resolution) and the ones the JIPipe should care about. By default all JIPipe\u0026rsquo;s multi-input nodes are configured to only care about annotation columns that begin with #.\nYou can extensively configure this behavior in the node\u0026rsquo;s properties and also manually define which columns JIPipe should look at.\nWhat happens if a reference column is missing? JIPipe will assume an ANY for such columns.\n\rShow example\r\r\rIn this example, one set of images has a data set, while the other set has no such information. This is interpreted as \"any\".\r\r\r\rCan I preview what the multi-input processing will do without running the node? Yes, switch to the \u0026ldquo;Data batches\u0026rdquo; tab in the properties panel. It allows you to configure how JIPipe merges data together and previews the results.\nDo not forget to refresh after changing a setting.\nHow does JIPipe store its data during the analysis? JIPipe stores all necessary inputs and the outputs of each processing step. This means that any kind of large data set will be loaded into the memory at the same time if you set up an iteration.\nFor example, an Import image step will load all the images and then continue with the next steps.\nI have a very large data set. How can I prevent loading it at the same time? You have two options:\n Run a JIPipe project within a another Use a node group and set it to iterative mode  Nested JIPipe projects You can run JIPipe projects within other JIPipe projects. This will separate them and into individual runs that are iterated one-by-one. JIPipe comes with nodes to extract specific results from those outputs.\nCreate the analysis for only one data set and export project-wide parameters via its project settings. Those parameters will be later modified and should contain anything you need for the project setup. Save it into a *.jip project.\nThen create a separate project and add the nodes Run JIPipe project and Define JIPipe project parameters. In both nodes, you load the main analysis projects.\nIterative group nodes Group a set of nodes that contains functions with a large memory footprint. This will create a Group node. By default group nodes will just act as simple group and pass data from its slots to the wrapped graph. To reduce the memory footprint, set the Graph iteration mode to iterate/merge, which changes the behavior of the node: The code now will be repeated for each data batch, which prevents loading all data at once.\nPlease ensure that the wrapped nodes can handle this kind of iteration.\nI do not want to always put in the credentials into each OMERO node. What can I do? Go to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; OMERO and set your credentials there. Any OMERO node will supplement unset credentials by those settings.\nWhere can I find information about the formats used in JIPipe output? You will find information in the data type compendium. Concerning the standardized JIPipe output format, you will find information here\n"
},
{
	"uri": "https://www.jipipe.org/faq/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Questions about the integration into ImageJ and popular plugins like OMERO",
	"content": "Can I use plugins from ImageJ in JIPipe? Yes. Either there is an integration available, or you just use the macro node and input the corresponding macro code that runs the plugin.\nCan I use existing ImageJ macros in JIPipe? Yes, use Images \u0026gt; ImageJ macro. The input slots are opened as image windows and can be addressed from within the macro with selectWindow(). You can also load an example that shows how to use the node.\nCan I use JIPipe from within ImageJ macros? Yes. You can use both pipelines and individual JIPipe algorithms from within ImageJ macros and the GUI.\nWhy are some JIPipe algorithms not availabe from within ImageJ? JIPipe has a very general data model that makes it possible to develop pipelines for processing any kind of data. The communication between JIPipe\u0026rsquo;s data types and ImageJ is handled by adaptors that will handle the \u0026ldquo;translation\u0026rdquo; back \u0026amp; forth. For some of such data types, there is no adaptor. The reason behind this is that ImageJ might not have an equivalent data type or feature.\n"
},
{
	"uri": "https://www.jipipe.org/faq/result-analysis/",
	"title": "Result analysis",
	"tags": [],
	"description": "Questions concerning the export and further analysis of results",
	"content": "Can I open a table in ImageJ instead of JIPipe or vice versa? Yes, and even more: Depending on the data type there are multiple options on displaying data available. Select the data in the result view or cache browser and click the ... button at the bottom. JIPipe will even remember the last setting for you.\nCan I save data by their metadata? Yes, use the node Miscellaneous \u0026gt; Export data. It will export all incoming data into one or multiple folders and generates names based on metadata.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-data-api/data-table/",
	"title": "Data table",
	"tags": [],
	"description": "Organizes data into an annotated table",
	"content": "The data table structure is the smallest unit of the data API. Its purpose is to organize data of any supported kind into an annotated table and store all required metadata to recover the data from the file system.\nA data table is located in a directory within the file system and contains following parts:\n data-table.json, which contains all metadata and the table row definitions Numeric folders starting from zero (e.g., 0, 1, 52) that correspond to rows defined in data-table.json. These contain files \u0026amp; folders specific to the serialized data type.  The numeric folders are also referred as \u0026ldquo;Row folders\u0026rdquo;. Please visit the row folder documentation for more info.\nHere you see an example of such a folder that stores three data rows. Here we assume that the stored data types are imagej-imgplus (ImageJ images).\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"/\"] -- DataTable[\"data-table.json\"]; Root -- R0[\"0/\"]; Root -- R1[\"1/\"]; Root -- R2[\"2/\"]; R0 -- R0Img[\"data.tif\"]; R1 -- R1Img[\"data.tif\"]; R2 -- R2Img[\"data.tif\"];  data-table.json Here you will find the structure of the data-table.json file. You also can access the document in JSON Schema format: data-table.schema.json. Please note that the description for a data table row (data-table-row.schema.json) can be found below.\nHere is an example data table that stores FFT images:\n{ \u0026#34;node-id\u0026#34; : \u0026#34;ij1-fft-forward2d\u0026#34;, \u0026#34;slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;internal-path\u0026#34; : \u0026#34;/fastdata/projects/JIPipe/Output\u0026#34;, \u0026#34;rows\u0026#34; : [ { \u0026#34;index\u0026#34; : 0, \u0026#34;annotations\u0026#34; : [ ], \u0026#34;data-annotations\u0026#34;: [ ], \u0026#34;true-data-type\u0026#34; : \u0026#34;imagej-imgplus-fft-2d\u0026#34; } ], \u0026#34;data-type\u0026#34; : \u0026#34;imagej-imgplus-fft-2d\u0026#34; } Data table  Defines a data table row   node-id:  string      The node type ID that generated the data. Optional.   slot:  string      The slot name that generated the data. Optional.   rows:  object[]       The data row items See data-table-row        data-type:  string       The data type ID behind the row      Data table row  Defines a data table row   id:  number      Row index within the data table   annotations:  object[]       Annotations attached to the data row See annotation        data-annotations:  object[]      Data annotations attached to the data row See data-annotation        true-data-type:  string       The true (not the slot) data type ID behind the row      Annotation  An annotation   name:  string       Name of the annotation   value:  string       Value of the annotation      Data annotation  A data annotation   name:  string       Name of the annotation   true-data-type:  string       Data type ID of the stored data annotation   row-storage-folder:  string       Relative path to the current data table containing the data annotation data row      "
},
{
	"uri": "https://www.jipipe.org/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "Sorry, the download is not available, yet.\r\rWe are currently working hard on getting the first release of JIPipe out.\nThe release will be announced in the image.sc forum.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph-node/",
	"title": "Graph node",
	"tags": [],
	"description": "Node in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm-node.schema.json\n\rNode in a graph\r\r\rjipipe:slot-configuration:\r\robject\r\r\r[object Object]\r\r\r\r\r\rUser-defined slots. Might be ignored depending on the algorithm. The keys are the slot names.\rSee slot-definition\r\r\r\r\r\r\r\rjipipe:node-ui-location:\r\robject\r\r\r[object Object]\r\r\r\r\rLocations of this node within the UI. Optional. The keys depend on the UI implementation.\rSee point\r\r\r\r\r\r\r\rjipipe:node-info-id:\r\rstring\r\r\r\r\r\r\rAlgorithm type ID\r\r\rjipipe:graph-compartment:\r\rstring\r\r\r\r\r\r\rCompartment UUID. Only relevant in project graphs. Empty indicates no compartment assignment.\r\r\rjipipe:alias-id:\r\rstring\r\r\r\r\r\rHuman-readable ID. Unique within the same graph. Can be changed by the software.\r\r\rname:\r\rstring\r\r\r\r\r\r\rA custom name for this node. Only important for the UI. If null or empty, the UI will default to the node type name.\r\r\rdescription:\r\robject\r\r\r\r\r\r\rA custom description. Only important for the UI.\r\r\r\r\r\rExample { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Annotated folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Annotated folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;default-preprocessing\u0026#34; : { \u0026#34;x\u0026#34; : 525, \u0026#34;y\u0026#34; : 100 }, \u0026#34;default-preprocessing{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 }, \u0026#34;default-preprocessing{Horizontal}\u0026#34; : { \u0026#34;x\u0026#34; : 450, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-annotate-by-name\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;default-preprocessing\u0026#34;, \u0026#34;generated-annotation\u0026#34; : \u0026#34;project-sample\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Folders to annotations\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/iterating-algorithms/",
	"title": "Handling multiple inputs",
	"tags": [],
	"description": "",
	"content": "JIPipe data slots store multiple data rows. This means that algorithms have to iterate their workload for each input row and generate equivalent output in the respective output slots.\nThere can be issues if data from multiple input slots need to be combined (e.g. merge channels into RGB, see user documentation). JIPipeAlgorithm has no capabilities to help with such cases.\nA solution can be JIPipeIteratingAlgorithm or JIPipeSimpleIteratingAlgorithm that use the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeDataBatch instances that represent one data set iteration.\nFor simple algorithms, we recommend JIPipeSimpleIteratingAlgorithm. It does not have the additional parameters that might confuse some users, but creates the same runIteration(\u0026hellip;) command as JIPipeIteratingAlgorithm. It only works for algorithms with at most one input and will generate error messages if you have more than one input.\n Please access data via the data interface. It reads exactly one JIPipeData for each input.\n The only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeNode(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeIteratingAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation Please read and write only via the data interface. */ @Override public runIteration(JIPipeDataBatch dataBatch, JIPipeProgressInfo progress) { // Run your workload here  } } "
},
{
	"uri": "https://www.jipipe.org/tutorials/analysis/",
	"title": "Image analysis pipeline",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": "\rThis tutorial is also available as video.\r\r\r1. First start\rOn starting JIPipe, you will see such a screen: It contains a short introduction, the graph compartment editor,\ran three pre-defined graph compartments Preprocessing, Analysis, and Postprocessing. As described in the graph compartment documentation, you\rcan ignore graph graph compartments. But in this tutorial we will make use of its capabilities to clearly separate the pipeline into the mentioned tree steps.\r\r\r\r2. Graph compartments\rHere you can see how the data flows between graph compartments. You do not have to do anything here, as this is the default configuration.\rData flows from Preprocessing to Analysis, and finally to Postprocessing.\r\rYou can ignore the graph compartments and of course define your own data flow. Graph compartments are very flexible. Just take a look at the documentation.\r\r\r\r3. Preprocessing\rIn this tutorial, the preprocessing step should consist of algorithms that load and organize data for the following processes.\rTo switch to the graph editor for the preprocessing step, just click the Preprocessing tab.\rYou will find an empty graph aside of the Preprocessing output node. We will utilize this node in\ra later step to pass preprocessed data to other steps.\r\rThe graph is stored project-wide. You can just close all graph editors that you do not need for the current task.\rYou can re-open them via the graph compartment editor. If you closed it, you can re-open it via the Compartment menu in the project menu bar.\r\r\r\r4. Adding a data source\rThe most common way how data is provided is to load them from files or folders. JIPipe comes preinstalled with data-types and algorithms\rthat handle filesystem operations. The tutorial data is supplied as set of folders\rthat contain the input images as TIFF files in a sub-directory.We begin by adding a data source that supplies a list of folders.\rYou can find it in Add data \u0026gt; Folder \u0026gt; Folder list. After selecting the item, it will appear in the graph.\r\rYou can also drag folders and/or files directly into the graph editor area. Corresponding file data source nodes are then created.\rFor this example, you could just drag the input data folders directly into the graph.\r\r\rYou do not have to navigate via the menu. You can also type the algorithm name or some keywords into the bar that reads Search ....\r\r\r\r5. Including the input folders\rSelect the newly created algorithm node by clicking it. The panel on the right-hand side will update and allow you to change\rthe parameters of the selected algorithm node. Click the  Add button and select the\rinput folders.\r\rYou can save the current project at any time and re-load it later. If you save it in a parent directory relative to where your data is located,\rJIPipe automatically saves all paths relative to the project file. This means you can just move all your data, including the project to other machines or\rhard drive partitions without breaking anything.\r\r\r\r6. Annotating data\rJIPipe is designed as batch processing tool, meaning that it can be always scaled from small test data up to large data sets.\rIt can be helpful for you and some algorithms to know which data belongs together. JIPipe introduces the concept of data annotations that\rassign data to an unique data set and are passed through the pipeline. You can find more about this in the documentation about how JIPipe processes data.\rIn this step we add the data annotation directly at the beginning by attaching the input folder name to each folder that was passed into the pipeline.\rThis is done via the Annotations \u0026gt; Generate \u0026gt; Path to annotation algorithm. Just add this algorithm into the graph.\rFor more advanced projects there are plenty of other sources for annotations, like importing them from tables, or extracting and modifying annotations.\r\r\r7. Connecting slots\rThe input folders are converted into a format understandable by JIPipe by the Folder list algorithm. The output then can be passed to following algorithms\rlike the Folders to annotations algorithm we added in the last step.\rTo make a connection click the  or  button and select the available data slot.\rYou can see that a connection between the two data slots was created.\rThis list is always sorted from the closest to the farthest away slot.\r\rYou can also use your mouse to drag a connection between slots.\r\r\r\r8. Annotation type\rAnnotations are like columns in a table - only that our table contains complex data types. The Path to annotation algorithm automatically extracts\rthe path's file name (or directory name) and annotates it to the input row. By default, the algorithm creates a column Dataset. If you want you can\rchange it to another meaningful column name. And with more complex projects you will probably have many different columns.\r\r\r9. Extracting the image file\rWe have now the folders and can extract the input image file from each one of them.\rYou can find an algorithm designed for such purposed in File system \u0026gt; List \u0026gt; List files. Add it to the graph and connect it to the Subfolder name output.\rThis algorithm is not only able to list files, but also filter them directly.\rIn this case, we exactly know that our files are located within a sub-folder in. Please update the Subfolder parameter by setting it to in.\rThe filter uses an expression that allows highly flexible filters. But for this example, we only want to test if the filename contains .tif.\rTo do this, type name CONTAINS \".tif\" into the filter box.\r\rIf you have more complicate folder structures, you can apply the \"Navigate to sub-folder\" operation with a distinct algorithm. You can find it in the Filesytem category.\r\r\rWe highly recommend that you get familiar with expressions, as they are present in most filtering or generation nodes. They are easy to learn and write, but also allow extremely powerful operations.\r\r\r\r10. Testing if the pipeline is correct (Optional)\rThe Quick Run feature allows you to run the pipeline until the selected algorithm and compare multiple parameter sets.\rIt is a good way to test if the pipeline works so far. To create a quick run right-click the List files node and select  Run \u0026amp; show results.\r\rThe quick run will check if the pipeline is valid might show some error. If you think that the pipeline is valid, click  Retry\rto check the pipeline again. It sometimes does not update for performance reasons.\r\r\rYou can also do a quick-run that just refreshes the Cache.\r\r\rYou can also start a Quick Run from the parameter panel if you select the algorithm.\r\r\r\r11. Testing if the pipeline is correct - results (Optional)\rNavigate to the output if the List files algorithm and check if the file paths are correct.\rSee our Quick Run documentation for more information about the testbench and its features.\r\r\r12. Importing the images\rAfter correctly setting up the files, you can import them as images. You can find various importers for\rimage types in Add data.\rOur images do not require Bio-Formats, so we choose Add data \u0026gt; Image \u0026gt;Import image. Connect it to the output of List files.\r\rThe Import image node does not ensure the exact bit depth and dimensionality of the output image. You can change this via a parameter that allows you\rto choose the exact image type.\r\r\r\r13. Preprocessing output\rYou could continue with the analysis directly from the Import image node. But to showcase the graph compartments feature, we decide to\rhave the imported greyscale image as output for of the Preprocessing compartment. The output of a graph compartment is only interfaced through a special node,\rin this case Preprocessing output.We first have to define an output slot by clicking the  button. Select Import image,\rset a name, and click  Add.\r\r\r14. Connecting the output\rFinally, connect the output of Import image to the new input slot of Preprocessing output.\r\r\r15. The analysis\rNow we are finished with the preprocessing. Switch to the Analysis graph compartment by selecting the tab in the tab bar.\rYou see that it also contains a node called Preprocessing output. This is the same node as in the preprocessing compartment, but\rit only contains output data this time.\rWe continue the analysis with a Gaussian filter that can be found in Images \u0026gt; Blur \u0026gt; Gaussian blur 2D.\rAdd it to the graph and connect it to the output of Preprocessing output.\r\r\r16. Finding the particles\rAdd following algorithms to the graph and connect them the the previous output:\r\rImages \u0026gt; Threshold \u0026gt; Auto Threshold 2D\rImages \u0026gt; Binary \u0026gt; Distance transform watershed 2D\rImages \u0026gt; Analyze \u0026gt; Find particles 2D\r\r\rThis will create a more or less accurate segmentation of the objects (spores) that are visible in the data.\rThe generated masks are then analyzed to extract ROI and measurements.\r\r\r17. Analysis output\rCreate multiple analysis output slots via the  button. Export at least the measurements table.\rIn our example, we exported the mask, ROI, and the measurements.\r\rYou can hide edges if you want. Just click the  or  and select Hide edge.\r\r\r\r18. Postprocessing\rThe postprocessing consists of generating a histogram plot of the spore particle areas.\rYou can find a node that generates plots in Tables \u0026gt; Plot \u0026gt; Plot tables.\rConnect the measurements to the plotting node and set its plot type to  Histogram plot.\rYou see that the node parameters change. They adapt to the the currently selected plot and expect from you to input from which table column(s)\rto extract the data from. Either you know the name of the columns, or you can use the testbench to generate output and check it yourself. Some algorithms\ralso write the names of their output columns in their description.\rThe correct column for the measurements is Area.\rYou can also change various plot-specific settings and determine how output images are generated.\r\rThe plot node automatically generates SVG and PNG renders in the selected resolution. This is not a definite choice, as JIPipe has its own plot builder that\rcan import generated plots from within the results UI.\r\r\rAside from exact matching, plot input columns can be matched via a regular expression\ror generated. Use the generator by selecting . A generator can be useful if you have no matching column within your data.\r\r\r\r19. Running the pipeline\rTo run the pipeline, click the  Run button at the top right corner. This will open a new tab where you can select the output directory.\rYou can also generate a random folder that will be located on your operating system's temporary directory\rby clicking the button.\rAfter setting up the parameters, click  Run now.\r\rJIPipe attempts to prevent the most common errors (such as wrong parameters) and displays a message if something was found. Please follow the instructions of those messages.\rDepending on the data and algorithms, the behavior might not be forseeable and a crash occurs during the processing. A similar easy-to-understand message is shown on how\rto proceed or repair the issue.\r\r\r\r20. Displaying results\rAfter the pipeline was successfully executed, a result analysis interface is shown. It displays the\rresults of all output slots. You can navigate through the results via the tree on the left-hand side.\rOn selecting a row, an interface is displayed below the table that contains various operations to import or open the data.\r\r\r21. Displaying plots\rTo open the generated plots, navigate to Results \u0026gt; Postprocessing \u0026gt; Plot tables \u0026gt; Output and double-click an entry in the list.\rAlternatively, you can also select the row and click Open in JIPipe. This will open a new tab with a plot builder tool.\rPlease take a look at the plots and tables documentation for more information how the tool works.\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/javadocs/",
	"title": "JavaDocs",
	"tags": [],
	"description": "Provides a link to the JavaDocs",
	"content": "The JavaDocs of the Java API can also be found here\n"
},
{
	"uri": "https://www.jipipe.org/documentation/create-pipelines/pipeline-editor/",
	"title": "Pipeline editor",
	"tags": [],
	"description": "Explains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.",
	"content": "\rThis guide is also available as video tutorial.\r\rThe graph editor (pipeline editor) allows you to edit the processing steps of a graph compartment. Its user interface is separated into three sections:\n The analysis graph contains the processing steps (also referred as algorithms) The settings panel shows the properties of the currently selected algorithms The toolbar allows you to add more algorithms into the graph, navigate to existing algorithms, change some behavior settings of the graph editor, and create screenshots  Analysis graph The analysis graph contains algorithms that are represented by rectangles. The algorithm graph area will automatically grow depending on where you place the algorithms. Scroll bars will appear if the graph area is larger than the available screen size.\nAn alternative to using the scroll bars is to hold the middle mouse button while dragging the your mouse.\n Algorithms read data from their input slots and output the results into the output slots. There are some algorithms that do not have input slots - they produce output based on their current parameters. The algorithm user interface has three sections:\n Input slots are located on the top of the algorithm UI. Each slot has a unique name that is displayed below the arrow. The arrow opens a menu that allows you to make/modify connections or change other options specific to the slot. Depending on the algorithm, a + button is created that allows you to add more slots. The drag area allows you to move the algorithm around. Move your  mouse pointer over the area and drag your mouse while holding the 🖱 left mouse button. On clicking the  button, a menu will open that contains some algorithm options. Alternatively you can right-click the drag area to open this menu. Output slots are located on the bottom and allow you to connect your output data to the input of another algorithm.  Any output data is always saved automatically by JIPipe. After generating the final output data, there is no need to connect it to any input.\n Slot connections You can connect two slots by clicking the  or  button of a slot and by selecting the source/target slot. Input slots can only receive one connection, while outputs can be distributed to as many inputs as you wish. The selection menu shows all available target slots and its sorted from the nearest to the slot that is furthest away.\nA connection is shows as line between the connected slots. The color of the line indicates if this connection is valid or invalid depending on the data types of the source and target.\n A black line indicates that the data types match exactly. A blue line indicates that the types dont match exactly, but can be converted by JIPipe A red line indicates that the types are incompatible. You will probably get an error message during the calculation.  Hover with your mouse over a slot\u0026rsquo;s name to show information about its data type.\n Slot options The slot context menu opened by  or  contain additional entries to managing connections.\n  Label this slot allows you to give the slot a custom name without changing the internal workings of the algorithm (As many algorithms are designed to adress specific slots). On selecting the entry, you can give a custom name that is displayed in cursive. To remove the custom label, label it with an empty text.  Find matching algorithm \u0026hellip; opens a tool that lists all compatible algorithms that can receive the output data as input. Depending on the algorithm, you can remove a slot from within this menu  Algorithm settings The algorithm settings are displayed on the right-hand side and contain all settings of the selected algorithm. There are usually four categories:\n  Parameters contains general parameters, like the name displayed in the drag area, and algorithm-specific parameters like thresholds, the selection of methods, and other parameters.  Slots is an alternative to modifying slots via the algorithm UI. Here, you can also re-order slots.  Annotations is an alternative to modifying slot annotations via the algorithm UI. See above for more info about annotations.  Quick run is a tool to run the analysis only up to the selected algorithm. It allows you to try and compare multiple parameters without creating new nodes. See the testbench documentation for more info.  Toolbar The toolbar contains functions to add new algorithms into the graph, navigate to existing algorithms or search the list of available algorithms, and functions to control the algorithm graph display.\n On the left-hand side you can find a menu containing all available algorithms. On selecting an entry, the corresponding algorithm is added to the graph. The navigator allows you to quickly navigate to an existing algorithm instance or create a new one. Just type one or multiple search terms into the field. On pressing the  arrow down key on your keyboard, the first entry is selected. The view options control how the graph editor behaves and contains some additional utility functions.  Additional tools  / allows you to switch between different view modes. This does not change the pipeline, but just how it is displayed in the editor. By default, a vertical view is enabled. If you prefer that data flows from left to right, choose the horizontal view mode. automatically aligns all nodes in the algorithm graph according to the algorithm by Sugiyama et. al allows you to change how dragging the middle mouse button changes the current view. is enabled by default and makes it that nodes are automatically aligned on creating connections. This feature does not reorganize the whole graph, but only places the target algorithm to a location that better represents the data flow. crops the graph area to the area taken by the algorithm nodes. Use this tool to find your nodes after scrolling too far away. creates a screenshot of the whole graph compartment that is currently being displayed.  View modes The graph can be displayed in different view modes. There are currently three modes integrated:\n Vertical: Nodes are displayed in a way that inputs are at the top and outputs are at the bottom. This is the default mode. Vertical (compact): Just like the vertical mode, but the size of each node is reduced. Horizontal: Nodes are displayed, so inputs are the the left and outputs are at the right  Nodes arrangements are saved for each view mode separately. Graphs will remember the current view mode.\nYou can change the default view mode via Project \u0026gt; Application settings \u0026gt; Graph Editor \u0026gt; Default view mode\n Here you will find a preview of all view modes with the same graph. The screenshots all have the same size.\n\r\rVertical\rVertical (compact)\rHorizontal\r\r\r\r\r\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/python/api/",
	"title": "Python API",
	"tags": [],
	"description": "Documentation of the Python API to communciate with JIPipe.",
	"content": "\njipipe \njipipe.data_slot This file provides functions that are used to manage the contents of a data slot\nZoltán Cseresnyés, Ruman Gerst\nResearch Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge https://www.leibniz-hki.de/en/applied-systems-biology.html HKI-Center for Systems Biology of Infection Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Institute (HKI) Adolf-Reichwein-Straße 23, 07745 Jena, Germany\nThe project code is licensed under BSD 2-Clause. See the LICENSE file provided with the code for the full license.\n\nDataSlot Objects class DataSlot() Models a JIPipe data slot.\n\n__init__ | __init__(data_type: str, storage_path: Path, node_id=\u0026#34;\u0026#34;, internal_path: Path = \u0026#34;\u0026#34;, name: str = \u0026#34;\u0026#34;, slot_type: str = \u0026#34;\u0026#34;) Initializes a new data slot\nArguments:\n data_type: the JIPipe data type ID that is accepted in this slot. The most basic type is \u0026lsquo;jipipe:data\u0026rsquo; slot_type: the type of the slot. Allowed values are \u0026lsquo;input\u0026rsquo; and \u0026lsquo;output\u0026rsquo;. Can be empty. storage_path: a directory where the slot data is stored. If it does not exist, one will be created node_id: Metadata that indicates the node associated to this slot. Can be empty. internal_path: Metadata that indicates the placement of this data within a hierarchy of data. Can be empty. name: Name of the slot. Can be empty.  \nget_row_storage_path | get_row_storage_path(row: int) Returns the storage path for the provided row\nArguments:\n row: the row index  Returns:\nthe storage path for the row\n\ncopy_row | copy_row(source_data_slot, source_row: int) Copies data from the source slot into this slot\nArguments:\n source_data_slot: the source slot source_row: the source row  \nadd_row | add_row(n: int = 1, annotations: dict = None, true_data_type: str = None) Adds n rows into the slot\nArguments:\n true_data_type: the true data type ID of this entry. If none, the slot data type is used annotations: annotations to set for these rows n: how many rows to add  Returns:\nthe last row index\n\nto_table | to_table() Converts the data slot into a Pandas table.The format is equivalent to data-table.csv generated by JIPipe.\nReturns:\nPandas table\n\nto_dict | to_dict() Converts the data slot into a dict that can be serialized into JSON\nReturns:\na dictionary that describes this slot\n\nsave | save(with_csv=False) Saves all metadata related to this slot in the storage folder. This will overwrite data-table.json and data-table.csv (if enabled)\nArguments:\n with_csv: Also write the table as CSV. The format is equivalent to the one generated by JIPipe. Writing with CSV requires pandas to be installed.  Returns:\nNone\n\nimport_from_folder import_from_folder(storage_path: Path) Imports a data slot from a storage path. A valid storage path contains \u0026lsquo;data-table.json\u0026rsquo; and multiple numeric folders.\nArguments:\n storage_path: the storage path  Returns:\na DataSlot instance\n\njipipe.imagej This file provides functions to read/write ImageJ data types\nZoltán Cseresnyés, Ruman Gerst\nResearch Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge https://www.leibniz-hki.de/en/applied-systems-biology.html HKI-Center for Systems Biology of Infection Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Institute (HKI) Adolf-Reichwein-Straße 23, 07745 Jena, Germany\nThe project code is licensed under BSD 2-Clause. See the LICENSE file provided with the code for the full license.\n\nget_image_file get_image_file(data_slot: DataSlot, row: int) Finds the image file located in imagej-imgplus-* data slot rows\nArguments:\n data_slot: the data slot row: the row  Returns:\npath to the image file or None if not found\n\nget_table_file get_table_file(data_slot: DataSlot, row: int) Finds the CSV table file located in imagej-results-table (and related) data slow rows\nArguments:\n data_slot: the data slot row: the row  Returns:\npath to the CSV file or None if not found\n\nload_image_file load_image_file(data_slot: DataSlot, row: int) Finds and loads the image file located in imagej-imgplus-* data slot rows and loads it with Skimage. Requires that Skimage is installed.\nArguments:\n data_slot: the data slot row: the row  Returns:\nImage data or None if no image was found\n\nload_table_file load_table_file(data_slot: DataSlot, row: int) Finds and loads the CSV table file in imagej-results-table (and related) data slow rows as pandas data frame Requires that pandas is installed.\nArguments:\n data_slot: the data slot row: the row  Returns:\nImage data or None if no image was found\n\nadd_table add_table(table, data_slot: DataSlot, annotations: dict = None) Adds a new table into a new row of the specified slot\nArguments:\n table: the table. must be a Pandas table or dictionary that can be converted into a data frame data_slot: the data slot annotations: optional annotations (a dict of string keys and string values)  Returns:\nindex of the newly added row\n\nadd_image add_image(image, data_slot: DataSlot, annotations: dict = None) Adds a new image into a new row of the specified slot. The image will be saved as TIFF. Requires Skimage.\nArguments:\n image: an image. must be a numpy array data_slot: the data slot annotations: optional annotations (a dict of string keys and string values)  Returns:\nindex of the newly added row\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/result-ui/",
	"title": "Result view",
	"tags": [],
	"description": "",
	"content": "After processing, users should be able to continue processing the data from within JIPipe. The data instances are cleared from memory after processing, meaning that the data needs to be loaded from its output folder after processing.\nAn user interface is shown when a user select a row in the results table. There are two ways to modify the user interface:\n Registering additional operations that will be available to users (recommended) Replacing the interface with a custom one  Adding custom operations JIPipe already comes with some default operations, such as opening the containing folder. Any other operation must be added manually to each data type.\nThere are two types of operations: one for importing data written into a results folder, and one for displaying already loaded data from memory. The corresponding interfaces are JIPipeDataImportOperation and JIPipeDataDisplayOperation.\nYou can implement one or both interfaces as shown here:\npublic class MyOperation implements JIPipeDataImportOperation, JIPipeDataDisplayOperation { @Override public void display(JIPipeData data, String displayName, JIPipeWorkbench workbench) { // Here you can pu a custom display function  // Currently it just uses the default function  data.display(displayName, workbench); } @Override public String getName() { // Name as shown in the menu  // The name should be unique  return \u0026#34;Open in JIPipe\u0026#34;; } @Override public String getDescription() { return \u0026#34;Opens the table in JIPipe\u0026#34;; } @Override public int getOrder() { // The lower the order the higher it is placed in the menu  // The lowest ist used as default  return 100; } @Override public Icon getIcon() { return UIUtils.getIconFromResources(\u0026#34;apps/jipipe.png\u0026#34;); } @Override public JIPipeData show(JIPipeDataSlot slot, JIPipeExportedDataTable.Row row, Path rowStorageFolder, String compartmentName, String algorithmName, String displayName, JIPipeWorkbench workbench) { // This function should import the data contained in the rowStorageFolder and display it  // You can return the data (which is currently not used) or return null  if (rowStorageFolder == null || !Files.isDirectory(rowStorageFolder)) return null; Path csvFile = PathUtils.findFileByExtensionIn(rowStorageFolder, \u0026#34;.csv\u0026#34;); if (csvFile != null) { ResultsTableData result = JIPipeTableEditor.importTableFromCSV(csvFile, (JIPipeProjectWorkbench) workbench); workbench.getDocumentTabPane().switchToLastTab(); return result; } return null; } } The operations must be registered in JIPipeJavaExtension either via the data type ID or when registering a new data type.\nCurrently you have to register all your operations per data type. It its not enough to register them for the base class only.\n @Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // Registering the operation when registering the data type  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null, new MyOperation()); // alternative ...  // Registering the operation by itself  registerDatatypeOperation(\u0026#34;my-data\u0026#34;, new MyOperation()); } }  You can register an operation for all data types by leaving the data type ID empty.\n Using a custom interface This UI can be replaced with a custom one that is designed to handle this specific data type.\nSuch UIs inherit from JIPipeResultDataSlotRowUI, which is a panel that has access to\n the data location the annotation of this data row the project workbench UI  We recommend to inherit from JIPipeDefaultResultDataSlotRowUI that allows to inherit actions from inherited data types.\nJIPipeDefaultResultDataSlotRowUI requires you to register actions with a name, description and function. The action that was added last is shown in the main UI and triggered by double-clicking the data row in the table. All other actions are put into the ... menu.\npublic class MyDataDataSlotRowUI extends JIPipeDefaultResultDataSlotRowUI { public MyDataDataSlotRowUI(JIPipeProjectWorkbench workbenchUI, JIPipeDataSlot slot, JIPipeExportedDataTable.Row row) { super(workbenchUI, slot, row); } // This method is required because we need to find the JSON file  // we can load MyData from it  private Path findJsonFile() { if (getRowStorageFolder() != null \u0026amp;\u0026amp; Files.isDirectory(getRowStorageFolder())) { return PathUtils.findFileByExtensionIn(getRowStorageFolder(), \u0026#34;.json\u0026#34;); } return null; } @Override protected void registerActions() { super.registerActions(); Path jsonFile = findJsonFile(); if (imageFile != null) { registerAction(\u0026#34;Show value\u0026#34;, \u0026#34;Shows the value as message box\u0026#34;, UIUtils.getIconFromResources(\u0026#34;open.png\u0026#34;), e -\u0026gt; { MyData data = MyData.fromJson(jsonFile); JOptionPane.showMessageDialog(this, data.value, \u0026#34;The value is ...\u0026#34;) }); } } } The UI class can be directly registered in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The last null parameter will be handled in the next tutorial  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, null); } } "
},
{
	"uri": "https://www.jipipe.org/documentation/run-pipelines/run/",
	"title": "Running the whole pipeline",
	"tags": [],
	"description": "Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.",
	"content": "JIPipe stores its results in a user-defined output folder. After clicking  Run (located at the top right corner of a project window) JIPipe will query the output folder from you. You can also generate a random folder that will be located on your operating system\u0026rsquo;s temporary directory by clicking the button.\nAfter confirming the settings by clicking  Run now, JIPipe will start processing the pipeline.\nYou can have as many runs as you want. Runs will not execute in parallel, but be scheduled to wait until the current run finishes.\n The JIPipe output folder is automatically organized in a standardized way, so JIPipe can open a result folder. You find the \u0026ldquo;Open analysis output \u0026hellip;\u0026rdquo; button in the \u0026ldquo;Project\u0026rdquo; menu.\n "
},
{
	"uri": "https://www.jipipe.org/documentation/basic-concepts/visual-programming/",
	"title": "Visual programming",
	"tags": [],
	"description": "Explains the basics of visual programming.",
	"content": "If you are familiar with ImageJ, you already know how processing is applied in this software: All operations are directly applied after selecting them in the graphical user interface (GUI). For example, a simple analysis protocol would consist of opening the image via File \u0026gt; Open, applying a Gaussian Blur filter, and then thresholding the image via Otsu\u0026rsquo;s method.\nThis allows to easily develop image analysis protocols that can be manually adjusted if needed. There are two main disadvantages:\n The exact parameters and the order of functions need to be written down separately The protocol must be executed manually, which is time-consuming if hundreds or thousands of images need to be processed (batch processing)  ImageJ already provides a method to write down any steps applied in the GUI - the macro recorder. These macro scripts also can be executed by ImageJ to repeat the recorded steps. To adapt macros into an automated analysis, or change steps inside the macro (for example, to choose a different filter) requires programming knowledge - a skill that is hard to acquire. And programmers still need to adapt the script and introduce code to manage data, metadata, and parameters.\nAn alternative concept to text programming languages are visual programming languages. These are based on the idea that data processing pipelines (such as an image analysis workflow) can be represented as easy-to-understand flow chart. Therefore, the need for programming can be circumvented by just letting users design the flow chart and derive all technical details from it.\nJIPipe provides such a language for ImageJ that not only allows to write down the processing steps, but also handles data, metadata, and batch processing. For example the pipeline shown above can be adapted to JIPipe:\n"
},
{
	"uri": "https://www.jipipe.org/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "To get started, you can take a look at some example pipelines and other kind of examples:\n\rSegmenting spores\rThis example applies auto-thresholding to segment spores from microscopy images.\rIt makes use of the particle analyzer to extract ROI and measurements and shows how to create an area histogram plot.\rThere are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.\rThis example is based on one of the tutorials.\r\r Download (Offline)\r Download (Online)\r Tutorial\r\r\r\rSegmenting glomeruli\rThis example applies auto-thresholding and morphological operations to segment glomeruli in 2D slices of whole murine kidney light sheet microscopy images. This algorithm is part\rof a 3D segmentation published by Klingberg et al. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.\r\r Download (Offline)\r Download (Online)\r Publication\r\r\r\rSegmenting worms\rThis example segments worms. This algorithm is part\rof a 3D segmentation published by Klingberg et al. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.\r\r Download (Offline)\r Download (Online)\r Publication\r\r\r\rStack hypermontage\rA useful node that creates a montage of each incoming image stack and creates a montage of the montages. It is very useful when trying out different parameters for 3D analyses.\rJust copy the node from this website and paste it into your JIPipe pipeline.\r\r Copy\r Download example pipeline\r\r\r\r\r$(document).ready(function(){\r// Landing page slideshow\r$('.examples').slick({\rinfinite: true,\rdots: true,\rslidesToShow: 3,\rslidesToScroll: 3,\rautoplay: true,\rautoplaySpeed: 10000,\rcenterMode: true,\rcenterPadding: '5rem',\rinitialSlide: 1,\rresponsive: [\r{\rbreakpoint: 1024,\rsettings: {\rslidesToShow: 1,\rslidesToScroll: 1\r}\r}\r]\r});\r});\rfunction copyTextToClipboard(text, onsuccess) {\rif (!navigator.clipboard) {\rfallbackCopyTextToClipboard(text);\rreturn;\r}\rnavigator.permissions.query({name:'geolocation'}).then(function(result) {\rif (result.state == \"granted\" || result.state == \"prompt\") {\rnavigator.clipboard.writeText(text).then(function() {\ralert(onsuccess);\r}, function(err) {\rconsole.error('Async: Could not copy text: ', err);\r});\r}\relse {\ralert(\"Unable to copy to clipboard! You might be using an older browser that does not support this.\");\r}\r});\r}\rfunction copyMontageExample() {\rvar url = window.location.origin + '/examples/example-montage.json';\rfetch(url)\r.then(function(response) {\rresponse.text().then(text = copyTextToClipboard(text, \"Copied the node to clipboard! Paste it into an existing JIPipe project.\"));\r});\r}\r\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/analysis_video/",
	"title": "Image analysis pipeline (Video)",
	"tags": [],
	"description": "This step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": "\rThis tutorial is also available as text tutorial.\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/merging-algorithms/",
	"title": "Merging input data",
	"tags": [],
	"description": "",
	"content": "You might need to develop an algorithm that does not simply iterate through its input(s), but organize it into groups to be merged. JIPipe comes with JIPipeMergingAlgorithm that uses the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeMergingDataBatch instances that represent multiple data rows merged into one group.\nPlease access data via the data interface.\n The only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeNode(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeMergingAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation Please read and write only via the data interface. */ @Override public runIteration(JIPipeMergingDataBatch dataBatch, JIPipeProgressInfo progress) { // Run your workload here  } } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/algorithm/",
	"title": "Algorithm type",
	"tags": [],
	"description": "Defines a new algorithm",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm.schema.json\n\rDefines a new node type\r\r\rid:\r\rstring\r\r\r\r\r\r\rUnique algorithm ID\r\r\rmetadata:\r\rSee metadata\r\r\r\r\r\r\r\rGeneral algorithm metadata\r\r\rcategory:\r\rstring\r\r\rorg.hkijena.jipipe:miscellaneous\r\r\r\r\r\rThe category\r\r\rexported-parameters:\r\robject\r\r\r[object Object]\r\r\r\r\rList of parameters that will be exported to users of the node\r\r\rgraph:\r\rSee graph\r\r\r\r\r\r\r\rThis graph is executed when the algorithm is run\r\r\rmenu-path:\r\rstring\r\r\r\r\r\r\rOptional menu path within the category menu\r\r\rjipipe:project-type:\r\rstring\r\r, x ∈ {\rgraph-wrapper-algorithm\r\r(default)\r}\r\r\r\r\r\r\rIdentifies the JSON as algorithm\r\r\r\r\r\rExample { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;parameter-visibilities\u0026#34; : { \u0026#34;visible-keys\u0026#34; : [ ] }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } "
},
{
	"uri": "https://www.jipipe.org/documentation/basic-concepts/batch-processing/",
	"title": "Batch processing",
	"tags": [],
	"description": "Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.",
	"content": "JIPipe was designed to always process data in batches, meaning that algorithms always work on multiple data sets at once. This greatly reduces the required work to upscale a processing pipeline from one or few to a large amount of data sets.\nWe will use this pipeline as example:\nmermaid.initialize({startOnLoad:true}); graph LR;\rA[File] -- B[Load image]\rB -- C[Apply gaussian]\r In the pipeline, a file is provided as input. Then the file is loaded as image. Finally, the image is processed with a gaussian filter.\nA possible implementation of such a pipeline consists of three algorithms, one for each processing step. An algorithm consumes input and produces output. The exception is the algorithm that loads a user-defined file path into the pipeline.\nJIPipe extends on this concept by allowing input and output slots contain multiple data sets at once. And depending on the algorithm, it either processes each data set individually, or splits, merges, or transforms the list of input data.\nHandling multiple inputs There might be algorithms that require multiple inputs:\nmermaid.initialize({startOnLoad:true}); graph LR;\rA[Image channel 1] -- B[Merge channels]\rC[Image channel 2] -- B\r The Merge channels algorithm merges the two image channels into one image with two channels. If each data slot only contains one entry, finding image channels that belong to the same data set is trivial.\nFor list-based data slots, like in JIPipe, it is not trivial to find images that should be merged. For example, image1_C1 and image1_C2 should be merged to image1_merged:\nData annotations JIPipe solves this issue by allowing to annotate each data entry (shown as purple entries). Those annotations are in this case automatically extracted and used to group input data. There also can be algorithms that use the annotation information to for example filter or sort data.\nThere are predefined algorithms located within the Annotate menu that for example create annotations based on filenames. JIPipe supports an unlimited amount of annotations that can be attached to data.\nFollowing JIPipe pipeline provides an example of making use of annotations to allow multiple inputs:\nTutorial video We created a video that illustrates how to create a batch processing pipeline:\n\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/extension/",
	"title": "Creating an extension",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.",
	"content": "\r1. Existing pipeline\rIn this tutorial, we will create a custom algorithm extension based on parts of the pipeline created in the other tutorial.\rPlease open the project file for the pipeline and navigate to the Preprocessing tab.\r\r\r\r2. Selecting the algorithms\rPlease select the following algorithms (you can either do this by holding the Shift keyboard button and clicking the nodes or dragging a selection around the nodes):\r\rFolder list\rPath to annotation\rList files\rImport image\r\rAfter selecting the algorithms, right-click a selected node and click Export.\r\rSelecting one or multiple algorithms is only one way to create a custom algorithm. You can also export a whole project compartment (via the Compartments tab) or\rthe whole pipeline (via Project \u0026gt; Export as custom algorithm)\r\r\r\r\r3. Preview\rThis will open a new tab where you can see a preview of the pipeline that will be exported.\rYou see that the connections between the selected algorithms were kept, while two additional nodes were added:\r\rGroup input\rGroup output\r\rThose two nodes respectively act as input and output of the whole exported algorithm. Its input and output slots will be accessible to users of your custom algorithm.\rJIPipe automatically creates matching input and output slots based on the selected algorithms, but you can choose to modify your pipeline in this step.\rNow click Export to extension and then New extension.\r\rYou can always modify custom algorithms within the extension builder. This will be shown in a later step.\r\r\r\r\r4. Extension builder\rThis will open the JIPipe extension builder tool that allows you to package one or multiple custom algorithms into an extension. Such extensions can be just put\rinto the ImageJ plugin directory and will be automatically picked up by JIPipe just like any ImageJ plugin.\rAn extension has a set of metadata that you need to set up. To do this, switch to Extension settings.\r\rYou can always find the extension builder in Plugins \u0026gt; New JSON extension ...\r\r\r\r\r5. Extension metadata\rJIPipe utilizes a unique extension ID to identify an extension. This is the most important setting and should be chosen carefully. The format must follow a specific structure: [Author]:[Extension], where [Author] provides information about the extension author, and [Extension] contains some identifier. We recommend to let the [Author] information follow the Maven naming conventions.\rAll the other metadata can be freely chosen or left out (with the exception of the name). Use the other metadata to add authors (including affiliations), a website, define a license, and cite\rwork your pipeline is depending on.\rFinally, you can review or modify the extension contents by going to Extension contents.\r\rAny dependency to other JIPipe extensions are automatically stored within any project or extension file. JIPipe uses this information to figure out a valid load order.\r\r\r\r\r6. Extension content\rOur custom algorithm is already included in the list of extension contents (left-hand side). You only need to provide metadata. The most important setting is the unique algorithm ID that is\rused by JIPipe to identify your algorithm. Please choose a meaningful string that avoids having duplicate identifiers. Then you can provide a name, category, icon and menu location.\r\rThe extension builder will warn you if an algorithm ID already exists (we will show this function later). You can choose to ignore this if a duplicate ID is intentional - this will\roverride an algorithm and replace it by the new one.\r\r\rAlgorithm IDs are not namespaced, meaning that they are independent of the extension ID.\r\r\r\r\r7. Parameters\rBy default, your algorithm does not come with parameters aside of the few default parameters (name, description, pass-through, enable). For your pipelines it can be useful to\rlet users change some parameters. The Exported parameters section gives you full control on which parameters can be changed and how they are organized.\rFirst, you need to create a group by clicking the  Add group button. This will create a new section in the final parameter UI. Then you can\rreference parameters by clicking  Add parameter. You can customize the name and descriptions of any item.\r\rIt is always a good idea to check the parameters or maybe apply some corrections to the algorithm. To do this, click  Edit graph\r\rYou can just add all parameters of a specific algorithm by clicking Auto add algorithm. Just check if users can properly decipher the function of each parameter.\r\r\rHover over the blue  wrench icon to display information about the referenced parameter.\r\r\rEach parameter can only be referenced once. You will get a warning if you have duplicate references.\r\r\r\r\r8. Modifying the algorithm\rThe extension builder contains a fully function algorithm graph editor (aside of anything that runs the graph) that allows you to modify an algorithm or create\rone from scratch. Use the editor to check the parameters of your algorithm. For example, it is a good idea to remove the folders from the Folder list algorithm.\r\r\r\r9. Validation and installation\rClick the  Validate button on the top right corner to check for any issues. This tool will also detect duplicate extension and algorithm IDs.\rErrors about duplicates can be ignored if they are intentional.\r\rFinally, you can install the extension by clicking  Install. This will open a dialog to save the extension into the ImageJ plugin directory and\rattempt to load the extension.\r\rWe still recommend to restart ImageJ, especially if you are installing duplicate IDs.\r\r\r\r\r10. Using the algorithm\rYou can find your algorithm in the menu, navigation bar, and algorithm finder just like any other algorithm. You can see that the parameters are included according to the settings within\rthe extension builder.\r\rJSON Algorithms can be always converted into  Group nodes that unlink the underlying pipeline from the JSON algorithm definition\rand allows users to modify them. Just select  Convert to group to apply such conversions.\r\r\r Group nodes are related to JSON algorithms. If you export a single group node, its contents are exported into an algorithm instead of\rthe node itself.\r\r\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/create-extension/",
	"title": "Creating an extension project",
	"tags": [],
	"description": "Explains how to setup a SciJava plugin project to extend JIPipe",
	"content": "Prerequisities  Java 8 (Java 9+ are not working)  If you are using Windows or a Linux distribution without Java 8, we recommend AdoptOpenJDK (Please choose OpenJDK 8)   Maven  Creating the project The project should have following structure:\nProject root\r└── pom.xml\r└── src\r└── main\r├── java\r└── resources\rBoth the java and resources folder should contain a folder structure that is equivalent the groupId and artifactId of the project. This is done to prevent conflicts with other plugins.\nJIPipe is based on SciJava and requires libraries provided by the SciJava Maven repository.\nHere is an example *.pom file that makes use of SciJava:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;inceptionYear\u0026gt;2020\u0026lt;/inceptionYear\u0026gt; \u0026lt;organization\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/organization\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;license\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;distribution\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/distribution\u0026gt; \u0026lt;/license\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;developer\u0026gt; \u0026lt;id\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/developer\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;contributors\u0026gt; \u0026lt;contributor\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;/contributor\u0026gt; \u0026lt;/contributors\u0026gt; \u0026lt;mailingLists\u0026gt; \u0026lt;mailingList\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;archive\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/archive\u0026gt; \u0026lt;/mailingList\u0026gt; \u0026lt;/mailingLists\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;connection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/connection\u0026gt; \u0026lt;developerConnection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/developerConnection\u0026gt; \u0026lt;tag\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/tag\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;issueManagement\u0026gt; \u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/issueManagement\u0026gt; \u0026lt;ciManagement\u0026gt; \u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/ciManagement\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pom-jipipe\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2021.2\u0026lt;/version\u0026gt; \u0026lt;!-- Update the version accordingly --\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;imagej.public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://maven.imagej.net/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imagej\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imglib2\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imglib2-ij\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imagej-legacy\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;scijava-log-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JIPipe core library --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jipipe-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- ImageJ integration --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jipipe-ij\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Add more JIPipe libraries if you need --\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;license.licenseName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.licenseName\u0026gt; \u0026lt;license.copyrightOwners\u0026gt;N/A\u0026lt;/license.copyrightOwners\u0026gt; \u0026lt;license.projectName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.projectName\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- This plugin can be useful to create a manually-installable package --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/dependencies\u0026lt;/outputDirectory\u0026gt; \u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt; \u0026lt;overWriteSnapshots\u0026gt;false\u0026lt;/overWriteSnapshots\u0026gt; \u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt; \u0026lt;excludeGroupIds\u0026gt;net.imagej, net.imglib2, org.scijava, com.google.code.gson, com.google.guava, org.swinglabs, ome \u0026lt;/excludeGroupIds\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;scijava-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;set-rootdir\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;validate\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;set-rootdir\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-jars\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;install\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-jars\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Creating an extension service JIPipe uses the SciJava plugin API to register Java extensions. In your project, you can create as many extensions as you want.\nJava extension inherit from JIPipeJavaExtension and require a @Plugin annotation.\nWe recommend to inherit from JIPipeDefaultJavaExtension that comes with some convenience-functions.\nA minimal extension can be found here:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { @Override public String getName() { return \u0026#34;My extension\u0026#34;; } @Override public HTMLText getDescription() { return new HTMLText()\u0026#34;A Java extension\u0026#34;); } @Override public String getDependencyId() { // We recommend the following structure: \u0026lt;groupId\u0026gt;.\u0026lt;artifactId\u0026gt;:\u0026lt;dependencyId\u0026gt;  // (!) The dependency Id should be unique for your plugin (!)  return \u0026#34;org.hkijena.jipipe:my-extension\u0026#34;; } @Override public String getDependencyVersion() { return \u0026#34;1.0.0\u0026#34;; } @Override public String getAuthors() { return \u0026#34;Ruman Gerst\u0026#34;; } @Override public String getWebsite() { return \u0026#34;https://jipipe.org/\u0026#34;; } @Override public String getLicense() { return \u0026#34;BSD-2\u0026#34;; } @Override public URL getLogo() { // This code loads the default JIPipe logo from JIPipe resources  // You can replace it with your own logo if you want  // Just do not use JIPipe\u0026#39;s ResourceUtils for this, as its always pointing to JIPipe resource directories  return ResourceUtils.getPluginResource(\u0026#34;logo-400.png\u0026#34;); } @Override public String getCitation() { // Here you can enter a citation for your publication  // It will be displayed in the plugin manager  return \u0026#34;\u0026#34;; } @Override public void register() { // Content is registered here  } } Testing your extension Use following code to create an ImageJ2 instance that immediately loads JIPipe:\npublic static void main(final String... args) { final ImageJ ij = new ImageJ(); ij.ui().showUI(); // If your ImageJ freezes, you can leave this out. JIPipe will show anyways.  ij.command().run(JIPipeGUICommand.class, true); } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/slot-configuration/",
	"title": "Customizing slots",
	"tags": [],
	"description": "",
	"content": "In the previous examples, we used the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations with autoCreate = true to automatically configure the slots.\nThis is not sufficient for more complicated algorithms that require\n Restricting the number of slots Restricting the allowed data types Users to add more slots or remove existing ones  A custom JIPipeSlotConfiguration can be used to implement such more advanced behaviors.\nFor many cases, the default implementation JIPipeMutableSlotConfiguration is sufficient.\nThe slot configuration can be overriden during instantiation of the algorithm:\npublic MyAlgorithm(JIPipeNodeInfo info) { super(info, JIPipeMutableSlotConfiguration.builder() .addInputSlot(\u0026#34;Input\u0026#34;, ImagePlusData.class) .restrictOutputTo(ImagePlusData.class) .build()); }  The slots of JIPipeMutableSlotConfiguration are by default unsealed - meaning that users can add more slots. Use the seal() functions to prevent this.\n Do not create static slot configurations. Each algorithm should have its own instance. Use a private static function if you want to work outside the capabilities of the builder.\n You should keep the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations. They are required for the algorithm finder and generating tooltips.\n "
},
{
	"uri": "https://www.jipipe.org/documentation/create-pipelines/expressions/",
	"title": "Expression parameters",
	"tags": [],
	"description": "Explains the expression parameter type language that is often used for filtering or generating numbers.",
	"content": "When using nodes that filter or generate data, you might encounter a parameter type called \u0026ldquo;Expression\u0026rdquo;. This parameter allows to to write simple to complex functions that can test for one or multiple conditions or act as input for a generator node. The basic concept of this expression language is to mix string, boolean, and numeric operations into one simple but powerful language. It allows you for example to first calculate a numeric metric and use it for filtering objects within one line.\nThere are always four components you will interact with:\n Literals like numbers (0.5), strings (\u0026quot;hello world\u0026quot;), and boolean values (TRUE, FALSE) Variables that are supplied from the node itself like x, y, or Area Functions that process literals or variables like MIN(x, 5), STRING_EQUALS(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;). Parameters are separated by commas. Operators that do something with the literals, variables, or function results, like subtraction, concatentation, or conditions  The expression language is interpreted as one line and you cannot write own variables. The result of the one expression is supplied to the node for processing.\nThe user interface of the expression parameter allows you to type the expression via a text field. You can also create new lines if you have longer expressions. They will be all merged automatically. If you are unfamiliar with the expression language, you can click the button to open a tool that lists all available functions and operators. This tool will help you to build expressions and check the syntax.\nTo get familiar with expression, use JIPipe\u0026rsquo;s integrated calculator tool (Tools \u0026gt; Development \u0026gt; Calculator). You can play around with any expression you like without breaking something.\n Variables Variables are set externally by the node and can contain various useful values. For example, filter nodes will put numbers into the variables. Image generator nodes might put the pixel coordinates into them.\nExample Here the node supplies the variables x and y and expects a number back. You can input a formula that will be automatically applied to ally x and y values:\n(x + y) + x/y + 1\r The expression builder shows a list of all variables. This list might be incomplete if variables are generated during the runtime (e.g., extracted from a table).\n Operators The expressions understand a wide range of common operators for numeric, string, and boolean data:\n You can add, subtract, divide, \u0026hellip; numbers Strings can be concatenated or checked for if one string contains another All basic boolean operators are available  Example You can combine various operators to do complex filtering. Here the node supplies variables Area and MaxWidth:\n(Area \u0026gt; 1000) AND ((MaxWidth^2 / Area \u0026gt; 0.5))\rFunctions The expression language comes with a large library of predefined functions that you can use for more complex tasks:\nExample To find files, it can be useful to utilize a Glob-filter that can reliably test for the file extension. Here name is the file name and supplied by the node.\nSTRING_MATCHES_GLOB(name, \u0026quot;*.tif\u0026quot;) AND (\u0026quot;data\u0026quot; IN name)\rData types The expression language supports five basic data types: Numbers, strings, arrays, and maps\nNumbers Numbers are any kind of number (integer or floating point). Number literals are read as floating point numbers (double).\nExample: 1, 0.5\nStrings Strings are character sequences (texts). They are defined by putting double quotes around a text. If you want to have a double quote inside your string, escape it via \\. If you want a \\ in your text, escape it with another \\.\nExample: \u0026quot;hello world\u0026quot;, \u0026quot;this text has a \\\u0026quot; quote and \\\\ backslash\u0026quot;\nArrays Arrays are collections of values. They are defined via the ARRAY(...) function. Individual items are access via the @ operator and a numeric index starting from zero.\nExample: ARRAY(1,2,3,4) @ 2 will return 3.\nExample: ARRAY(1,2,3,4) @ ARRAY(0,1) will return an array with 1 and 2\nMaps Maps are collections of values where each value is given a unique name. They are defined via the MAP(...) function that should be provided with 2-item arrays (there is a PAIR(key, value) function for this). You can get an array of all keys via the KEYS() function and can access elements via the @ operator.\nExample: MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3)) @ \u0026quot;b\u0026quot; returns 2\nExample: KEYS(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with a, b, and c\nExample: VALUES(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with 1, 2, and 3\nOperators There are many operators with alternative ways to write them available. There are two kinds of operators:\n Symbolic operators are using symbols like $, \u0026amp; or * Textual operators are written words like AND or CONTAINS  The difference between the operators is that symbolic operators can be written without spaces. For example you can write 5+5 or !x. Textual operators require spaces to be separated. For example you cannot write NOTx. You have to write NOT x.\n   Operator Description Usage     Logical AND Returns TRUE if both operands are TRUE x AND y or x \u0026amp; y   Logical OR Returns TRUE if one of the operands is TRUE x OR y or `x   Logical XOR Returns TRUE if exactly one operand is TRUE x XOR y   Logical NOT Returns TRUE if input is FALSE and vice versa NOT x or ! x   Numeric division Divides the left by the right operand x / y   Numeric exponent Calculates left to the power of the right operand x ^ y   Numeric subtraction / Array removal Subtracts right from left (Numbers). If the operands are arrays, the right items are removed from the left array x - y   Numeric multiplication Multiplies the two operands x * y   Numeric addition / String concatenation / Array concatentation Adds two numbers. Concatenates if the operands are strings. Merges two arrays x + y   Numeric greater than Returns TRUE if the left operand is greater than the right one x \u0026gt; y   Numeric greater or equal Returns TRUE if the left operand is greater or equal to the right x \u0026gt;= y   Numeric less than Returns TRUE if the left operand is less than the right one x \u0026lt; y   Numeric less or equal Returns TRUE if the left operand is less or equal to the right one x \u0026lt;= y   Numeric / String / Boolean equality Returns TRUE if the operands are equal x == y or x EQUALS y   Numeric / String / Boolean inequality Returns TRUE if the operands are unequal x != y or x UNEQUAL y   Numeric negation This is technically an operator -x   Numeric modulo Calculates the modulo x % y   Contains Returns TRUE if the one string is contained in the other one (both operands are strings), or if an array contains an item, or a map contains a values x IN y or y CONTAINS x   Variable exists Returns TRUE if the a variable with the name exists x EXISTS   Resolve variable Returns the value of the variable with name. Useful for variables that have spaces in their names or special characters. $ x (Alternative function: GET_VARIABLE(x))   Get item in array/map Returns the array item(s) or string characters of the left operands. The right-hand side can be a number (the index starting from 0) or an array of indices. If the left operand is a map, the indices are whatever the map uses as index x @ y or x AT y    Precedence The operators are ordered according to a precedence table. You might need to use brackets (()) to force the order you expect:\nThe higher the number is the more the operator is preferred.\n   1 2 3 4 5 6 7 8 9 10     OR AND NOT           XOR                Subtraction (x - y) Divide (x / y)  Power (x^y) Negate (-x)         Modulo (x % y)            Multiply (x * y)          Greater than or equal (x \u0026gt;= y)            Greater than (x \u0026gt; y)            Less than or equal (x \u0026lt;= y)            Less than (x \u0026lt; y)            Equal (x == y)            Unequal (x != y)             String contains (x IN y)            Addition (x + y)            String contains (x CONTAINS y)             Variable exists (x EXISTS)              Array/Map access (x @ y) Variable resolve ($ x)    Compatible types Not all operators are compatible to all types. See following table for the operator\u0026rsquo;s behavior:\n   Operator Number Boolean String Array Map     AND Error OK Error Error Error   NOT Error OK Error Error Error   OR Error OK Error Error Error   XOR Error OK Error Error Error   Divide (x / y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Multiply (x * y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Modulo (x % y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Subtract (x - y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) OK (both operands are arrays) OK (left operand is map, right operand is array or map)   Addition (x + y) OK OK (TRUE=1, FALSE=0) OK (Conversion to strings, string concatenation) OK (both operands are arrays) OK (both operands are maps)   Equality (x == y) OK OK OK (If types differ, conversion to strings) OK OK   Inequality (x != y) OK OK OK OK OK   Contains (x IN y / x CONTAINS y) Error Error OK OK OK   Less than (x \u0026lt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Less than or equal (x \u0026lt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than (x \u0026gt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than or equal (x \u0026gt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Variable exists (x EXISTS) Works (Converted to string) Works (Converted to string) OK Error Error   Variable resolve ($ x) Works (Converted to string) Works (Converted to string) OK Error Error   Get item in array or map (x @ y) Error Error Error OK OK    "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "This library provides integration of ImageJ data types, as well as common ImageJ algorithms.",
	"content": "The ImageJ integration library integrates common data types from ImageJ into JIPipe:\n Multi-dimensional images (ImagePlus). The standard output file format are TIFF files. Result tables. They are serialized to CSV files. Region of interest (ROI Manager). JIPipe handles ROI as *.zip files.  The ImageJ data types are marked as accessible from outside JIPipe, meaning that algorithms that only use those types can be executed standalone\nImage data types Various ImageJ algorithms only work on data with a specific color type, or dimensionality. To make it easier for algorithms to specifiy which types are suitable, the JIPipe standard library introduces various image sub-types (e.g. 8-bit greyscale 3D image).\nThe library is set up to automatically convert any image data type into any other image data type. During this conversion, the data types automatically attempt to satisfy their constraints or raise an error. The conversion automatically converts a lower-dimensional image into a higher-dimensional image (e.g. 2D to 3D), but not the other way around.\nThe image data types are organized in the following way:\nmermaid.initialize({startOnLoad:true}); graph LR;\rImgPlus[\"Image (nD)\"] -- ImgPlusGreyscale[\"Greyscale image (nD)\"]\rImgPlusGreyscale -- ImgPlusGreyscale8U[\"8-bit greyscale image (nD)\"]\rImgPlusGreyscale8U -- ImgPlusGreyscaleMask[\"8-bit mask (nD)\"]\rImgPlusGreyscale -- ImgPlusGreyscale16U[\"16-bit greyscale image (nD)\"]\rImgPlusGreyscale -- ImgPlusGreyscale32F[\"32-bit float greyscale image (nD)\"]\rImgPlus[\"Image (nD)\"] -- ImgPlusColor[\"Color image (nD)\"]\rImgPlusColor -- ImgPlusColorRGB[\"RGB color image (nD)\"]\rImgPlusColor -- ImgPlusColorHSB[\"HSB color image (nD)\"]\rImgPlusColor -- ImgPlusColorLAB[\"LAB color image (nD)\"]\r The graph above shows the structure for non-dimensional (nD) images. This structure is repeated for 2D, 3D, \u0026hellip; 5D images.\nColor spaces The standard library comes with support for different color spaces and supports automated conversion between them.\nEach image stores the color space (allowing for example to remember the color space of a HSB image stored inside a generic image). Color space conversions are automatically applied (e.g. from RGB to greyscale). While trivial for specific color types (like RGB color), JIPipe falls back to following color spaces for generic colors (e.g. greyscale image):\n   Color space Fallback colorspace     All greyscale images 32-bit float greyscale   All colored images RGB color    Please note that if the color space information is lost, RGB is used as fallback. Color conversion nodes in Images \u0026gt; Colors \u0026gt; Convert\nFrequency space image data types The JIPipe standard library contains color types that are intended to hold frequency-space (FFT) data. While the standard library only provides methods to handle 2D FFT, there are 3D, \u0026hellip;, 5D data types available for future extensions.\nWe rely on the mechanisms provided by ImageJ. For example, the ImageJ FFT generates a 8-bit greyscale power spectrum image and attaches data to the image instance. JIPipe has no special methods to load and save the FFT data, aside from the image data itself. We recommend to generate FFT data within the pipeline to generate the correct data.\n ImageJ algorithms The standard library provides a selection of common ImageJ algorithms as JIPipe algorithm nodes. Those algorithms wrap around the respective ImageJ methods and have the same feature set, aside from some changes that are required to make algorithms usable in a batch-environment like JIPipe.\nYou can find a list of all algorithms via the  Help menu on the top right corner and the item Algorithm compendium.\nMacro node If an algorithm is not available as JIPipe node, you can use the Macro node.\n"
},
{
	"uri": "https://www.jipipe.org/tutorials/jipipe-for-imagej-users/",
	"title": "JIPipe for ImageJ users (Video)",
	"tags": [],
	"description": "This video explains the basics of creating pipelines in JIPipe - aimed towards users already familiar with ImageJ.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/result-preview/",
	"title": "Preview from results folder",
	"tags": [],
	"description": "",
	"content": "While JIPipeData allows you to define a custom function for previewing, this only works for data already present in memory. To allow previewing of data stored in a results folder, you need to suppy a JIPipeResultDataSlotPreviewUI that loads the data from disk and generates a preview. We recommend to use JIPipeAsyncResultDataPlotPreviewUI This class will offload the loading and preview generation into a separate thread to prevent the UI from freezing. By default it will use the already defined importFrom(Path) method present in the JIPipeData class and use its already defined preview function.\nYou can override the data loading and other methods for customization.\npublic class MyDataPreviewUI extends JIPipeAsyncResultDataPlotPreview { public MyDataPreviewUI(JTable table) { super(table); } } The preview class is registered as last argument of registerDataType():\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The last null parameter will be handled in the next tutorial  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, MyDataPreviewUI.class); } } "
},
{
	"uri": "https://www.jipipe.org/documentation/run-pipelines/result-analysis/",
	"title": "Review results",
	"tags": [],
	"description": "Explains how to review results.",
	"content": "Running the whole pipeline or executing a quick run with HDD output will result in a folder that contains all output data and the current project file. JIPipe will automatically open an interface that allows you to navigate through the results, and import them back into ImageJ or JIPipe (if supported by the generated data type). You can also re-open these folders via Project \u0026gt; Open analysis output ....\nThe UI has two main components:\n The slot tree shows a hierarchy of all data slots. It is organized by compartment, then algorithm, and finally data slot. By selecting any of the entries, all data associated to the selection or any n-child is displayed. The output data table lists the stored data of the selected slot(s) as table (if you are unfamiliar why this is, please take a look at the explanation on how JIPipe processes data)  After selecting a set of slots in the slot tree the output data table will update to only display the data of the selected slots. The table has following columns:\n (Optional) Compartment shows in which graph compartment the generating algorithm is located (Optional) Algorithm shows the name of the algorithm that generated the data. Location is the folder name where the data is located relative to the slot directory Data shows a string representation of the data row. The contents vary depending on the slot data type. For example, file system data display their path at this location. Additional columns correspond to the data annotations that were attached by various algorithms  Importing results back into JIPipe/ImageJ/\u0026hellip; On selecting one or multiple rows, additional UI elements are displayed below the table. They contain various actions that can be applied to the output data, such as opening the results directory, importing the data back into ImageJ or JIPipe, or any other operation.\nDouble-click a row to execute the default action, which is the one most commonly used.\n --\r"
},
{
	"uri": "https://www.jipipe.org/documentation-data-api/row-folder/",
	"title": "Row folder",
	"tags": [],
	"description": "Data storage of a JIPipe data type in the file system",
	"content": "All data in a data table are stored in numeric folders called \u0026ldquo;row folders\u0026rdquo;, each containing the data of one table row.\nThis data stores the raw serialized format, without metadata - metadata is located in data-table.json of the data table.\nThe exact structure of a row folder depends on the data type and is documented in (?) \u0026gt; Data type compendium within JIPipe. Here we will provide you a list of the most important row folder structures supported by JIPipe.\nNot all data types save data: For example structural data like \u0026ldquo;Zero table\u0026rdquo; column contain all necessary info in their type. There are also data types that are not instantiatable and therefore are never saved. Always refer to the true-data-type property that you can find within the data table.\n  Data type Data type ID(s) Row folder structure   All ImageJ images (except FFT)   imagej-imgplus imagej-imgplus-greyscale imagej-imgplus-greyscale-8u imagej-imgplus-greyscale-mask imagej-imgplus-greyscale-16u imagej-imgplus-greyscale-32fu imagej-imgplus-color imagej-imgplus-color-rgb imagej-imgplus-color-hsb imagej-imgplus-color-lab imagej-imgplus-2d imagej-imgplus-2d-greyscale imagej-imgplus-2d-greyscale-8u imagej-imgplus-2d-greyscale-mask imagej-imgplus-2d-greyscale-16u imagej-imgplus-2d-greyscale-32fu imagej-imgplus-2d-color imagej-imgplus-2d-color-rgb imagej-imgplus-2d-color-hsb imagej-imgplus-2d-color-lab imagej-imgplus-3d imagej-imgplus-3d-greyscale imagej-imgplus-3d-greyscale-8u imagej-imgplus-3d-greyscale-mask imagej-imgplus-3d-greyscale-16u imagej-imgplus-3d-greyscale-32fu imagej-imgplus-3d-color imagej-imgplus-3d-color-rgb imagej-imgplus-3d-color-hsb imagej-imgplus-3d-color-lab imagej-imgplus-4d imagej-imgplus-4d-greyscale imagej-imgplus-4d-greyscale-8u imagej-imgplus-4d-greyscale-mask imagej-imgplus-4d-greyscale-16u imagej-imgplus-4d-greyscale-32fu imagej-imgplus-4d-color imagej-imgplus-4d-color-rgb imagej-imgplus-4d-color-hsb imagej-imgplus-4d-color-lab imagej-imgplus-5d imagej-imgplus-5d-greyscale imagej-imgplus-5d-greyscale-8u imagej-imgplus-5d-greyscale-mask imagej-imgplus-5d-greyscale-16u imagej-imgplus-5d-greyscale-32fu imagej-imgplus-5d-color imagej-imgplus-5d-color-rgb imagej-imgplus-5d-color-hsb imagej-imgplus-5d-color-lab   Contains one image file with one of following extensions: *.tif, *.tiff, *.png, *.jpeg, *.jpeg, *.png. We recommend the usage of TIFF.   ImageJ FFT images   imagej-imgplus-fft imagej-imgplus-fft-2d imagej-imgplus-fft-3d imagej-imgplus-fft-4d imagej-imgplus-fft-5d  Info: Dimensions greater than 2 are currently experimental due to limitations in ImageJ.   Contains two image files: fht.ome.tif / fht.tif and power_spectrum.ome.tif / power_spectrum.tif, as well as a file fht_info.json. Either the OME TIFF or TIFF must be present. fht.ome.tif / fht.tif contains the FHT (float32). power_spectrum.ome.tif / power_spectrum.tif contains the power spectrum (float32). fht_info.json contains a JSON object that defines following properties: quadrant-swap-needed (boolean), original-width (integer), original-height (integer), original-bit-depth (integer; 8, 16, or 32 are valid values), power-spectrum-mean (double).    OME Image imagej-ome Contains one or multiple files in *.tif or *.ome.tif format. If OME TIFF is used, multiple tiff files can be present (due to the ability of OME TIFF to link them together). Although, we do recommend having multiple files, as sometimes OME TIFF can store absolute paths. If only standard TIFF files are present, only one will be loaded.   Tables and table columns   imagej-results-table annotation-table table-column-string table-column-numeric   Contains a single *.csv file that contains the table data.   Plots   plot-pie-2d plot-pie-3d plot-category-bar plot-box-and-whisker plot-histogram plot-category-line plot-category-bar-stacked plot-category-statistical-bar plot-category-statistical-line plot-xy-line plot-xy-scatter    plot-metadata.json contains the serialized information about the plot. series[Index].csv contains the data of series [Index]. The plot metadata JSON contains entries title, export-width,export-height, background-color, grid-color, with-legend, title-font-size, legend-font-size, color-map, and plot-series. plot-series is mandatory and is a list of objects with each object having an object metadata, and a string element file-name. The file name must point at the corresponding series[Index].csv file of the series. Additional metadata in the root object and series metadata depend on the exact plot type.    "
},
{
	"uri": "https://www.jipipe.org/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "Are you new to JIPipe? Do you want to find out what this tool is about? Then watch our video abstract:\n\rTutorial list You will find text and video tutorials in the following list. All tutorials are also available as playlist on YouTube.\n Image analysis pipeline\nThis step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Image analysis pipeline (Video)\nThis step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Creating an extension\nThis step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.\n  JIPipe for ImageJ users (Video)\nThis video explains the basics of creating pipelines in JIPipe - aimed towards users already familiar with ImageJ.\n  User interface (Video)\nThis video explains the basics of the JIPipe user interface.\n  Data caches (Video)\nThis video explains the basics of the caching system.\n  Graph editor user interface (Video)\nThis video explains the basics of the graph editor user interface.\n  How to do batch processing (Video)\nThis video explains how to create a batch processing pipeline.\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/macro-node/",
	"title": "Macro node",
	"tags": [],
	"description": "The macro node allows to run ImageJ macros.",
	"content": "The macro node allows to run existing ImageJ macros or execute algorithms that are not directly available as JIPipe nodes. You will find it in Images \u0026gt; ImageJ Macro.\nInputs and outputs By default, the node has no inputs and outputs. Use to the + button to add them. For example, if you want to process one image and output the processed result, create one input and one output.\nBy default, there are four data types that can be used as input and output:\n Any image data type Results table ROI List Paths  Depending on the data type, JIPipe converts inputs into a format that can be processed by an ImageJ macro. The other way around, JIPipe extracts outputs from via modes that are commonly used in macros.\nDevelopers can provide their own integrations to add more data types.\n Image data As input: The image is opened as ImageJ image window, named according to the slot name. We recommend to use the macro command select(\u0026lt;window name\u0026gt;) to first select the image window before applying the processing.\nAs output: The image is extracted from an image window, named according to the slot name. Use the rename() command to rename outputs accordingly.\nExample (for the node shown above)\n// The input is created as window \u0026#34;Input\u0026#34; selectWindow(\u0026#34;Input\u0026#34;); run(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=2\u0026#34;); // The node expects an image window \u0026#34;Output\u0026#34; rename(\u0026#34;Output\u0026#34;); Results table As input: The table data is opened as the main \u0026ldquo;Results\u0026rdquo; table. We recommend to have only one results table input, as the conversion overwrites the current table.\nAs output: The table data is extracted from the main \u0026ldquo;Results\u0026rdquo; table.\nYou should only have one results table input, as only the latest input is used. If you want to merge tables, use JIPipe nodes for this.\n ROI data As input: The ROI are added to the ROI manager. Like with the results table data, the existing ROI manager is cleared.\nAs output: The ROI are extracted from the ROI manager.\nYou should only have one results ROI List data input, as only the latest input is used.\n Path data As input: Paths are defined as string variable, named according to the input slot name. Please note that the slot name must be a valid variable name.\nAs output: A path is extracted from a results table window (row 0, column 0). We do not recommend to extact paths as output, as ImageJ does not have native handling for such data.\nWe recommend to only use paths as input. The extraction as output is unpredictable, as ImageJ has not a native way to display this type in a way that can be distinguished from result tables.\n Parameters The most important parameters are\n The macro code The list of variables  The Code parameter contains the macro code. You can hide it with Collapse or open the code in a larger editor (in a separate tab).\nVariables The macro node allows you to create parameters that can be directly accessed from within JIPipe. The benefit is that those variables can be exported (custom nodes/group node) for ease of use or applying multiple parameter sets.\nClick the Add parameter button in the Macro parameters category to add a variable/parameter.\nIn the dialog, you have to set following options:\n Select the data type of the parameter The Unique identifier acts both as identifier inside JIPipe and the variable name inside the macro. The Name is displayed in the JIPipe GUI The Description field allows you to provide a documentation displayed at the bottom of the parameter list  Variables inside macros On running the macro node, the final code is assembled by adding variables at the top.\nVariables are assembled as var \u0026lt;Unique identifier\u0026gt; = \u0026lt;Value\u0026gt;. The values are converted as following:\n   JIPipe parameter type ImageJ macro variable type     String String   Byte Integer   Short Integer   Double Double   Float Double   Path String   Boolean Boolean    For example, a Gaussian blur node with a Sigma parameter will generate following code:\n// Code generated from parameters var sigma = 2.0; // Code written in the \u0026#34;Code\u0026#34; parameter selectWindow(\u0026#34;Input\u0026#34;); run(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=\u0026#34; + sigma); rename(\u0026#34;Output\u0026#34;);  Path inputs are converted in a similar way.\n "
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-user-interface/",
	"title": "User interface (Video)",
	"tags": [],
	"description": "This video explains the basics of the JIPipe user interface.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-data-caches/",
	"title": "Data caches (Video)",
	"tags": [],
	"description": "This video explains the basics of the caching system.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-graph-editor/",
	"title": "Graph editor user interface (Video)",
	"tags": [],
	"description": "This video explains the basics of the graph editor user interface.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-batch-processing/",
	"title": "How to do batch processing (Video)",
	"tags": [],
	"description": "This video explains how to create a batch processing pipeline.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": " General questions\nGeneral questions about JIPipe\n  User interface\nQuestions concerning the user interface\n  Data processing\nQuestions about how data is processed\n  ImageJ integration\nQuestions about the integration into ImageJ and popular plugins like OMERO\n  Result analysis\nQuestions concerning the export and further analysis of results\n  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/",
	"title": "Creating an algorithm",
	"tags": [],
	"description": "Explains how to create a custom algorithm",
	"content": "All algorithms inherit from JIPipeAlgorithm. An algorithm consists of following parts:\n A run() function that runs the workload A reference to an algorithm info that describes the general properties of the algorithm A slot configuration that describes which slots the algorithm should have  JIPipe comes with different base algorithms that provide different feature sets:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.   JIPipeSingleIterationAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple inputs and acts like a JIPipeMergingAlgorithm where all data rows are always merged into one batch.    Any algorithm should have the following basic structure:\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeNode(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots autoCreate automatically creates the slots if set to true and no slot configuration was provided @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) // You can add multiple JIPipeCitation annotations to provide citations for this node only @JIPipeCitation(\u0026#34;Additional citation\u0026#34;) public class MyAlgorithm extends JIPipeAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation */ @Override public run(JIPipeProgressInfo progress) { // Run your workload here  } } To register the algorithm and provide it with an Id, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // Registers our algorithm with a unique ID and an icon  registerNodeType(\u0026#34;my-algorithm\u0026#34;, MyAlgorithm.class, UIUtils.getIconURLFromResources(\u0026#34;actions/viewimage.png\u0026#34;)); } } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/dependency/",
	"title": "Dependency",
	"tags": [],
	"description": "Project or extension dependency. Refers to an JIPipe extension.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: dependency.schema.json\n\rProject or extension dependency. Refers to a JIPipe extension.\r\r\rmetadata:\r\rSee metadata\r\r\r\r\r\r\r\r\rid:\r\rstring\r\r\r\r\r\r\rUnique ID of this dependency should have format\r\r.\r\r:\r\r\r\r\r\r\rversion:\r\rstring\r\r\r\r\r\r\rVersion of this dependency\r\r\r\r\r\rExample { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "JIPipe is a visual programming language for ImageJ that allows you to create macros without any programming  by just creating a flowchart. In this documentation, you will find information about the basic concepts behind JIPipe, how to create an image analysis pipeline with the JIPipe graphical user interface (GUI), and run your pipeline and review results. You will also find guides how to connect JIPipe with ImageJ and other software.\nIf you are not familiar with the idea behind JIPipe, we recommend to watch following video:\n\rHere you can find the topics of this documentation:\n Basic concepts\nThis section explains some basic concepts that are helpful to understand if you want to use JIPipe. Visual programming Explains the basics of visual programming. Batch processing Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.   Creating pipelines\nThis section explains the JIPipe user interface, how to create an analysis pipeline, and some concepts behind how analysis pipelines work. Pipeline editor Explains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool. Expression parameters Explains the expression parameter type language that is often used for filtering or generating numbers. Graph compartments Explains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.\n  Running pipelines\nThis section contains documentation that explains how to run a pipeline and review the results. For example, you can run the whole workflow or make use of the cache feature to run single nodes. Running the whole pipeline Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline. Review results Explains how to review results. Use results in external software\n  ImageJ integration\nExplains functionality that allows ImageJ to run JIPipe algorithms or pipelines.\n  Managing plugins\nExplains how to install and manage plugins.\n  Standard library\nContains some explanations about the algorithms that are included in the JIPipe standard distribution.\n  Extension builder\nExplains the extension builder tool\n  Command Line Interface\nExplains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/filesystem/",
	"title": "Filesystem algorithms",
	"tags": [],
	"description": "This library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.",
	"content": "The JIPipe standard library contains data types and algorithms to apply file system operations. The common use case is to extract the list of input files for the following algorithms.\nThe filesystem library has two basic data types:\n A  File contains a path to a file A  Folder contains a path to a folder A Path contains a path to a file or folder  In the Add data menu you can define one file/folder or a list of files/folders.\nWe recommend to create a list of files/folders. This makes it easier to scale your workflow up.\n Drag any set of files or folders into the graph editor to create corresponding file/folder data source algorithms.\n File/folder manipulation algorithms The standard library comes with various algorithms that apply common operations to input filesystem data. This includes listing the files in a folder, filtering files/folders, or navigating to a subfolder. They are placed in the Filesystem category.\nAutomated relativization File and folder data source algorithms by default store absolute paths. If you save your project in a parent folder where the data is stored, the paths are automatically converted into relative paths that make data transfer between devices easier.\nAnnotation It is helpful to add data annotations to the file data at some point. This allows algorithms and users to assign data rows to an unique data set. See the annotation standard library documentation for more information.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/create-pipelines/compartments/",
	"title": "Graph compartments",
	"tags": [],
	"description": "Explains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.",
	"content": "A common issue with graphical programming languages is that large graphs are hard to navigate. JIPipe solves this issue by separating the pipeline graph into sub-graphs. Each sub-graph has a predetermined output node that is visible to other compartments. Other nodes on the other hand are not visible to other compartments.\nThe difference between compartments and simple node groups is that compartments only communicate with each other via the compartment output node. JIPipe also only allows you to edit a specific compartment, instead of the whole graph. By default, JIPipe creates three compartments: Preprocessing, Analysis, and Postprocessing.\nBy default a compartment\u0026rsquo;s output node is not visible in any other compartment. The have to be connected in a similar manner on how algorithms are connected. To do this, use the compartment editor that is described in the following section.\n You can ignore the compartment feature if you want. You can delete the default compartments without any issue. Just leave one graph compartment and edit the remaining one.\n Compartments behave similar to algorithms. This means you can create a directed acyclic graph of compartments.\n Creating and connecting compartments JIPipe comes with an editor that allows to control the graph compartments. This editor is similar to the pipeline editor and allows you to create new compartments, connect them, as well as import or export compartments. Instead of containing algorithms, the editor contains graph compartment nodes that can be connected similar to how algorithms are connected.\nYou can one or multiple compartments in the editor. Click the  Edit button to open the compartment in the pipeline editor.\nYou can also double-click a compartment node to open the editor.\n "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/multi-parameter/",
	"title": "Multi-parameter algorithms",
	"tags": [],
	"description": "This library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.",
	"content": "Most algorithms allow handling of multiple parameters via an additional slot that can be optionally enabled. You can find the setting in an algorithm\u0026rsquo;s settings as Multiple parameters. On selecting the item, a new slot will appear that consumes parameter data.\nTo define parameters, use the algorithms found in Add data \u0026gt; Parameters. There are currently two data source algorithms available:\n Define parameter defines a single set of parameters Define multiple parameters lets you define a table of parameters  Use Process \u0026gt; Merge \u0026gt; Merge slots to merge multiple parameter sets.\n Defining parameters Both data sources require you to determine which parameters should be created. To do this, add parameters into the Parameters section (red box).\nFor Define multiple parameters, there is an additional element (blue box) that contains a parameter table. Each row represents a parameter set, while a column represents a parameter type. Columns can be added by adding parameters into the Parameters section.\nYou can leave the table empty. In this case, the parameters are extracted from the \u0026lsquo;Parameters\u0026rsquo; section.\n Select a table cell to open the parameter editor below the table.\nThere are following buttons available:\n Add row adds a new row with standard parameters Generate row allows you to create new rows where one column is generated by the selected generator Replace cells allows you to replace the selected cells in one column with a set of generated parameters  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/parameters/",
	"title": "Parameters",
	"tags": [],
	"description": "",
	"content": "You can add parameters to your algorithm by creating a property with a getter and setter. Then you annotate the getter and setter with the same @JIPipeParameter keys. Also add an @JIPipeDocumentation annotation to either the getter or setter.\nParameters are automatically serialized and deserialized.\nPlease make sure to send an event when the parameter is set, so the UI can update.\n// ... see previous tutorials public class MyAlgorithm extends JIPipeIteratingAlgorithm { private float roundness = 0.5f; // ... see previous tutorials  @JIPipeParameter(\u0026#34;roundness\u0026#34;) @JIPipeDocumentation(name = \u0026#34;Roundness\u0026#34;, description = \u0026#34;Value within [0, 1]\u0026#34;) public float getRoundness() { return roundness; } @JIPipeParameter(\u0026#34;roundness\u0026#34;) public boolean setRoundness(float roundness) { if(roundness \u0026lt; 0 || roundness \u0026gt; 1) return false; // Reject this value  this.roundness = roundness; // Send the change out to listeners  getEventBus().post(new ParameterChangedEvent(this, \u0026#34;roundness\u0026#34;)); } }  Your setter can return a boolean. If the output is true, JIPipe considers the value as valid. If false, the JIPipe UI re-loads a valid value via the getter.\n Please make sure that your parameter key is unique. Only one getter and one setter should have the same key.\n Not all data types are supported. Data types are registered into JIPipe and available via JIPipeUIParametertypeRegistry.getInstance(). In a later tutorial we show how to register custom data types. JIPipe supports common primitives like boolean, int, float, double, String, and all enum data types.\n Accessing parameters from within code When a user sets a parameter within the UI, it goes through an instance of JIPipeParameterAccess. This object is responsible for triggering the required events to notify the UI.\nIf you set a parameter setter via code, you will notice that any open parameter UI does not respond to this change - due to the absence of the JIPipeParameterAccess.ParameterChangedEvent.\nUse the provided triggerParameterChange(key) function to trigger the appropriate parameter change event for a parameter. Alternatively, you can use the setParameter(key, value) method to set parameters.\nMyAlgorithm algorithm = new MyAlgorithm(...); // This will NOT update the UI algorithm.setRoundness(1.0f); // Either trigger the event manually algorithm.setRoundness(1.0f); algorithm.triggerParameterChange(\u0026#34;roundness\u0026#34;); // Or just use the setParameter() function algorithm.setParameter(\u0026#34;roundness\u0026#34;, 1.0f); // DO NOT DO THIS EVER: algorithm.setRoundness(1.0f); algorithm.isParameterUIVisible(); // DON\u0026#39;T DO THIS!!! THIS WILL UPDATE THE UI, BUT NOT INFORM DEPENDENT PARAMETERS You can also read parameters via their key using getParameter()\nMyAlgorithm algorithm = new MyAlgorithm(...); algorithm.getParameter(\u0026#34;roundness\u0026#34;, Float.class) // Returns 1.0 Accessing the whole parameter tree The mentioned functions getParameter and setParameter are utilities around JIPipeParameterTree, which manages the whole set of parameters and sub-parameters of a JIPipeParameterCollection. We recommend to create such an object directly, if you want to access many parameters at once or want to read parameter metadata like names, documentation, annotations, and more. It also gives you more control on how parameters are accessed (for example it can force using reflection parameters), which can be helpful in more special cases.\nMyAlgorithm algorithm = new MyAlgorithm(...); JIPipeParameterTree tree = new JIPipeParameterTree(algorithm); // The access object contains the metadata JIPipeParameterAccess access = tree.getParameters().get(\u0026#34;roundness\u0026#34;); access.set(1.0f); // You can also access sub-parameters (by key or by object) JIPipeParameterTree.Node subParameterNode = tree.getSourceNode(algorithm.getSubParameter()); subParameterNode.getDescription(); // Access to various settings Parameter settings Some parameter types have different styles or other settings that can change the behavior of the parameter editor UI. An example is StringParameterSettings that allows to change between single-line and multi-line editors.\nSub-parameters JIPipeAlgorithm, like any JIPipeParameterCollection allows sub-parameters.\nTo create a sub-parameter create a getter to an JIPipeParameterCollection and annotate it with @JIPipeParameter. The key provided with the annotation should be an unique parameter key. The parameters in the sub-parameter instance are automatically displayed as new group in the parameter editor.\n@JIPipeDocumentation(name = \u0026#34;Gaussian filter\u0026#34;) @JIPipeParameter(value = \u0026#34;gaussian-algorithm\u0026#34;) public GaussianBlur2DAlgorithm getGaussianAlgorithm() { return gaussianAlgorithm; } The @JIPipeParameter annotation allows you to determine various properties, like if the sub-parameter should be collapsed or hidden by default.\nPlease do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm\u0026rsquo;s event bus. Otherwise there can be issues with the extension builder. You can use the registerSubParameter() method in the constructor and copy constructor as a shortcut.\n Conditional parameters Each parameter collection (including nodes) allow the conditional display of parameters or sub-parameters. To setup this display, override the isParameterUIVisible method. There are two overloads, one for displaying or hiding single parameters, and one for controlling the display of sub-parameters.\n// Example for conditional showing/hidding of single parameters  @Override public boolean isParameterUIVisible(JIPipeParameterTree tree, JIPipeParameterAccess access) { if (access.getKey().equals(\u0026#34;mode\u0026#34;)) return true; if (mode == Mode.Automatic) { return !access.getKey().equals(\u0026#34;custom-name\u0026#34;); } else { if (access.getKey().equals(\u0026#34;ignore-missing-metadata\u0026#34;)) return true; if (access.getKey().equals(\u0026#34;missing-string\u0026#34;)) return true; return access.getKey().equals(\u0026#34;custom-name\u0026#34;); } } // Example for sub-parameters @Override public boolean isParameterUIVisible(JIPipeParameterTree tree, JIPipeParameterCollection subParameter) { if(!scaleToModelSize \u0026amp;\u0026amp; subParameter == getScale2DAlgorithm()) { return false; } return super.isParameterUIVisible(tree, subParameter); }  Use triggerParameterUIChange() to trigger an update of the UI in the setter function if you have dependencies between parameters. This will work for parameters and parameter groups.\n User-defined parameters If you want to make it possible for users to create custom parameters, create an JIPipeDynamicParameterHolder as sub-parameter. You can control the list of allowed parameter types and other settings.\n// Field that initializes the dynamic parameter collection with all supported parameter types private JIPipeDynamicParameterCollection scriptParameters = new JIPipeDynamicParameterCollection(true, JIPipe.getParameterTypes().getRegisteredParameters().values()); public MyClass() { registerSubParameter(scriptParameters); } public MyClass(MyClass other) { this.scriptParameters = new JIPipeDynamicParameterCollection(other.scriptParameters); registerSubParameter(scriptParameters); } @JIPipeDocumentation(name = \u0026#34;Script parameters\u0026#34;) @JIPipeParameter(value = \u0026#34;script-parameters\u0026#34;, persistence = JIPipeParameterPersistence.Object) // Important: Set persistence public JIPipeDynamicParameterCollection getScriptParameters() { return scriptParameters; }  Do not forget to deep-copy the JIPipeDynamicParameterHolder. The class has a copy constructor for such an operation.\n Please do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm\u0026rsquo;s event bus. Otherwise there can be issues with the extension builder. JIPipeAlgorithm comes with a pre-made function registerSubParameters() that should be called in the constructors.\n We recommend setting the persistence of the getter to JIPipeParameterPersistence.Object. Otherwise, JIPipe will have issues with de-serializing the parameter and lose all settings.\n Full control You can inherit from JIPipeCustomParameterHolder to define all parameters manually without the need for an JIPipeDynamicParameterHolder or annotations.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-data-api/pipeline-output/",
	"title": "Pipeline output",
	"tags": [],
	"description": "",
	"content": "A pipeline output folder is generated on running a pipeline using the Run function or via other means of running the pipeline and saving the results to the hard drive.\nThe generated folder follows a hierarchical structure that is based on the location of data within graph compartments, nodes, and slots. It also contains a copy of the project that generated the data in a file project.jip.\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"/\"] -- DataTable[\"project.jip\"]; Root -- Compartment[\"[Compartment ID]/\"]; Compartment -- Node[\"[Node ID]/\"]; Node -- Slot[\"[Slot ID]/\"]; Slot -- DT[\"Data table\"];   Compartment ID: The human-readable unique ID of the graph compartment the node is located in. This ID can change if the compartment is renamed. Node ID: The human-readable unique ID of the generating node. The ID can change if the node is renamed. Slot ID: The name of the slot the stores the data Data table: An instance of a data table. Stores all the data.  The data table contains a property internal-path that can be used to recover the node and compartment the data was generated in.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/run-pipelines/connect-external-software/",
	"title": "Use results in external software",
	"tags": [],
	"description": "",
	"content": "JIPipe stores outputs in a standardized format that can be easily read with third-party software. The output folder of always contains a file project.jip, which is the project that generated the output.\nThis folder contains sub-folders named according to the graph compartment. The ID is the unique ID of the graph compartment and can be looked up in the project.jip file or the compartment graph editor.\nEach of these compartment folders contains a set of additional sub-folders based on unique ID of the node (also visible in the graph editor).\nA node folder contains a set of folders, one for each output slot. This folder may be empty if JIPipe is instructed to not save the output slot.\nEach slot folder contains a metadata file data-table.json that contains information about all stored outputs, including the data type and annotations. The metadata is also usually available as data-table.csv file that can be read more easily. The folder contains sub-folders with numeric names that correspond to the table rows. The contents of each of these folders is determined by the standardized storage format of the data type (true-data-type in the data table).\nYou can open existing project folders in JIPipe. Just go to Project \u0026gt; Open analysis output and select the folder that contains the project.jip file.\n We recommend to always copy the whole project folder. This will ensure the highest reproducibility.\n Slot output folders are used beyond result analysis for importing/exporting cache states and to communicate with external applications like Python or R. Only the JSON file carries the metadata.\n A description of the contents of a table row folder can be viewed in the data type compendium (help menu).\n "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/parallelization/",
	"title": "Parallelization",
	"tags": [],
	"description": "",
	"content": "The current version of JIPipe supports parallelization via a fixed thread pool. Parallelization is done on an per-algorithm-level, meaning that the algorithms are responsible for providing parallelization capabilities.\nThe included base algorithms JIPipeIteratingAlgorithm, JIPipeSimpleIteratingAlgorithm, and JIPipeMergingAlgorithm already come with support for parallelization that has to be manually enabled via code. The inherit from JIPipeParallelizedAlgorithm and completely apply parallelization automatically.\nAutomated parallelization (JIPipeParallelizedAlgorithm) The automated parallelization is controlled by three factors:\n If the user enabled parallelization via a parameter If parallelization is supported In how many batches the data is separated  To enable parallelization, let supportsParallelization() return true (defaults to false). This will parallelize the processing of data interfaces (see previous chapters). As sometimes third-party algorithms apply their own parallelization, you can restrict how many threads are allocated by JIPipe by setting getParallelizationBatchSize.\nFor example, there are many image analysis algorithm implementations that use Runtime.getRuntime().availableProcessors() for their own parallelization. To ensure that only as many threads as the user selected are allocated, return Runtime.getRuntime().availableProcessors() from getParallelizationBatchSize(). The implementation then will adapt to this value.\npublic class MyAlgorithm extends JIPipeIteratingAlgorithm { /* Enable parallelization. By default false. */ @Override isParallelizationEnabled() { return true; } /* Assume that each runIteration() executes a third-party algorithm with its own parallelization based on Runtime.getRuntime().availableProcessors() threads. Tell this to the JIPipe implementation to limit the number of threads. */ @Override getParallelizationBatchSize() { return Runtime.getRuntime().availableProcessors(); } } Manual parallelization You can choose to do your own parallelization (leave isParallelizationEnabled() to return false). Each JIPipeAlgorithm object has a method getThreadPool() that returns the thread pool assigned to the current run. Please note that this thread pool can be null.\nThe thread pool provides methods to schedule workloads. If the number of threads is set to 1, the thread pool will schedule the workload into the current thread. You also have raw access to the ExecutorService behind the thread pool - just do not forget that the service can be null.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/custom-info/",
	"title": "Custom algorithm info",
	"tags": [],
	"description": "",
	"content": "In the previous tutorials we used the standard way of creating algorithms. This might not be sufficient if you want to generate algorithms, for example by importing ImageJ algorithms, loading algorithms from JSON or generate algorithms for an unknown list of data types.\nHow algorithms are registered Algorithm instances are created by an JIPipeNodeInfo. This info is the object that is actually registered into JIPipe. It is able to create new instances of the declared algorithm, or copy it. It also carries basic metadata such as a name, description, or annotation preferences.\nDeclarations should be unique and have a unique ID within the JIPipe algorithm registry.\nOn registering an algorithm like in previous tutorials, following code is run:\npublic void registerNodeType(String id, Class\u0026lt;? extends JIPipeAlgorithm\u0026gt; algorithmClass) { registerNodeType(new JIPipeJavaAlgorithmRegistrationTask(id, algorithmClass, this)); } The code generates a task that just checks if all algorithm dependencies are loaded. If all dependencies are available, the task runs:\nJIPipeAlgorithmRegistry.getInstance().register(new JIPipeNodeInfo(id, algorithmClass), source); The important bit is JIPipeNodeInfo. In the end an algorithm info is created that extract algorithm information from the class annotations.\nCreating a custom info To create a custom info, inherit from JIPipeNodeInfo. The most important functions are clone() and newInstance().\nRegister the info either via a direct call to registerNodeType(JIPipeNodeInfo) or (recommended) via a task that inherits from JIPipeNodeRegistrationTask. You can inherit from the default implementation JIPipeDefaultNodeRegistrationTask that comes with pre-made functionality to check for common dependencies. The reason behind using a task is that some algorithm-internal classes might require that data types or annotation types are already registered.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph-edge/",
	"title": "Graph Edge",
	"tags": [],
	"description": "Edge in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph-edge.schema.json\n\rEdge in a graph\r\r\rsource-node:\r\rstring\r\r\r\r\r\r\rAlgorithm ID of the edge source\r\r\rtarget-node:\r\rstring\r\r\r\r\r\r\rAlgorithm ID of the edge target\r\r\rsource-slot:\r\rstring\r\r\r\r\r\r\rSlot name within the edge source algorithm\r\r\rtarget-slot:\r\rstring\r\r\r\r\r\r\rSlot name within the edge target algorithm\r\r\r\r\r\rExample { \u0026#34;source-node\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-node\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/",
	"title": "Java API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe Java API that allows you to create SciJava plugins to extend JIPipe. The Java API is very powerful and allows you to add algorithms, annotation types and new data types. It also allows you to create UI-only components such as parameter editors, plots, and table processing operations.\nYou can refer to the JIPipe JavaDocs for more information about the API specifics. The following tutorials will show you to implement your own Java extensions via small examples.\n JavaDocs\nProvides a link to the JavaDocs\n  Creating an extension project\nExplains how to setup a SciJava plugin project to extend JIPipe\n  Creating an algorithm\nExplains how to create a custom algorithm\n  Creating a data type\nExplains how to create custom data types\n  Creating a parameter type\nExplains how to create an UI for a parameter\n  Usage in Java\nExplains how to use the JIPipe API to run graphs, algorithms, or projects within pure java code\n  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/context-actions/",
	"title": "Context actions",
	"tags": [],
	"description": "",
	"content": "Context actions allow you to add custom buttons into an algorithm\u0026rsquo;s parameter group that by default will also appear within a node\u0026rsquo;s context menu. They can be used for multiple purposes such as loading example data, applying an auto-configuration, opening websites, or displaying documentation or data in a new tab.\nTo create one, annotate a public function with @JIPipeDocumentation and @JIPipeContextAction. The function should have one parameter: an instance of JIPipeWorkbench.\n@JIPipeDocumentation(name = \u0026#34;Load example\u0026#34;, description = \u0026#34;Loads example parameters that showcase how to use this algorithm.\u0026#34;) @JIPipeContextAction(iconURL = ResourceUtils.RESOURCE_BASE_PATH + \u0026#34;/icons/actions/graduation-cap.png\u0026#34;) public void setToExample(JIPipeWorkbench parent) { // Insert code here } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/",
	"title": "Creating a data type",
	"tags": [],
	"description": "Explains how to create custom data types",
	"content": "Custom JIPipe data types must inherit from JIPipeData. It is required to add an @JIPipeDocumentation annotation that provides a name and brief description of the data type.\nJIPipe requires that data can be saved to a folder within the output directory. We also recommend that you include code that can load the data back into JIPipe or ImageJ in some form.\nThere are no requirements on the constructor of the data type. The only requirements are that there is a function importFrom(Path) that imports JIPipeData from a row storage folder, and an annotation of type @JIPipeStorageDocumentation that explains the structure of the storage folder.\nThe folder that is provided in storageFilePath is unique to the data and empty. The name parameter in storageFilePath is usually the data slot name and can be used as template for file names. It can be ignored undless forceName is true. The reason behind this is that then the name is pre-generated in a unique way for saving the data at a non-standard location (e.g. exporting the data). In such cases all file or folder names within the storage path should contain the name in some way, even if the import function cannot load the exported data anymore.\nThere are two optional functions that you can override:\n display() shows the data in ImageJ, JIPipe, or any other GUI preview() generates a GUI component that acts as thumbnail/preview of the contained data  @JIPipeDocumentation(name = \u0026#34;My data\u0026#34;, description = \u0026#34;This is some data\u0026#34;) @JIPipeStorageDocumentation(\u0026#34;Contains exactly one *.json file that stores the string value.\u0026#34;) // You can use @JIPipeHidden to hide this data from data type list UIs public class MyData implements JIPipeData { String value; public MyData() { } // Constructor that initializes the data  public MyData(String value) { this.value = value; } @JsonGetter(\u0026#34;value\u0026#34;) public String getValue() { return value; } @JsonSetter(\u0026#34;value\u0026#34;) public String setValue(String value) { this.value = value; } // This should return a deep copy  @Override public JIPipeData duplicate() { return new MyData(value); } // The display method is optional, but recommended  @Override public void display(String displayName, JIPipeWorkbench workbench) { JIPipeTextEditor editor = JIPipeTextEditor.openInNewTab(workbench, displayName); editor.setMimeType(getMimeType()); editor.setText(data); } // The preview method is optional, but recommended for many cases  // The width and height are guidelines you should adhere to (especially the height)  @Override public Component preview(int width, int height) { // This example would overlap with toString()  return new JLabel(value); } // Do not forget to override this  @Override public String toString() { return StringUtils.orElse(value, \u0026#34;\u0026#34;); } @Override public void saveTo(Path storageFilePath, String name, boolean forceName, JIPipeProgressInfo progress) { try { JsonUtils.getObjectMapper().writeValue(storageFilePath.resolve(name + \u0026#34;.json\u0026#34;).toFile(), this); } catch(Exception e) { throw new RuntimeException(e); } } // We will use this method later to load the data back from disk  public static MyData fromJson(Path jsonFile) { try { return JsonUtils.getObjectMapper().readValue(jsonFile.toFile(), MyData.class); } catch(Exception e) { throw new RuntimeException(e); } } // Do not forget to add this method or JIPipe will refuse to start  public static MyData importFrom(Path rowStorageFolder) { // You can use the PathUtils  Path targetFile = PathUtils.findFileByExtensionIn(storageFilePath, \u0026#34;.json\u0026#34;); return fromJson(targetFile); } }  You can use JIPipe\u0026rsquo;s JsonUtils class to get access to a Jackson JSON ObjectMapper.\n Do not forget to override toString(), as the string representation will be displayed in the cache browser.\n To register the data type and provide it with an id, and icon, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The two null parameters will be handled in the next tutorials  // You can leave them null if you want. This is valid.  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null); } } "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/annotations/",
	"title": "Data annotation algorithms",
	"tags": [],
	"description": "This library provides basic functionality to add annotations to data slot rows.",
	"content": "Data annotations allow JIPipe algorithms and users to assign an unique data set to the data located in a data slot. The standard library contains various algorithms that allow to generate, manipulate, and utilize those annotations.\nWe recommend to use the algorithms in Annotation \u0026gt; Generate while setting up filesystem operations or any other import step to prevent issues in following algorithm steps.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph/",
	"title": "Graph",
	"tags": [],
	"description": "A graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph.schema.json\n\rA graph\r\r\radditional-metadata:\r\robject\r\r\r[object Object]\r\r\r\r\rDict of additional metadata\rSee additional-metadata\r\r\r\r\r\r\r\rnodes:\r\robject\r\r\r[object Object]\r\r\r\r\r\rThe nodes. Keys are the UUIDs.\rSee graph-node\r\r\r\r\r\r\r\redges:\r\robject[]\r\r\r\r\r\r\rThe edges. IDs in the edge definition must be consistent to the UUIDs in the 'nodes' entry\rSee graph-edge\r\r\r\r\r\r\r\r\r\r\rExample { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/",
	"title": "JSON API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe JSON API that includes the API for creating JSON extensions, but also other data types like a project.\n\r Project file specification \r JSON extension file specification \r\rJSON objects The JSON API is object-oriented and re-uses different object types in multiple occasions. You will be referred to the specified documentation.\n Graph node\nNode in a graph\n  Algorithm type\nDefines a new algorithm\n  Dependency\nProject or extension dependency. Refers to an JIPipe extension.\n  Graph Edge\nEdge in a graph\n  Graph\nA graph\n  Extension\nAn extension that can be put into the ImageJ plugin folder\n  Metadata\nCommonly used metadata type in JIPipe.\n  Point\nA point\n  Project\nAn analysis project\n  Slot definition\nDefines a data slot\n  Data table\nDefines a data table\n  Data table row\nDefines a data table row\n  Annotation\nDefines an annotation\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/run-pipelines/quick-run/",
	"title": "Running a single node",
	"tags": [],
	"description": "Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.",
	"content": "As an additional option to running the whole pipeline, JIPipe also allows you to run the workflow only up to the selected node. The most convenient way to run a single node can be accessed by clicking the green play button that is located inside each node.\nHere you will find following options:\n Update cache: Runs the pipeline up until the selected node. The result of the selected node will be stored inside a memory cache, which can be reviewed in the Cache browser tab (see below) Cache intermediate results: Runs the pipeline up until the selected node. The result of the node and the ones of intermediate steps are stored inside the cache. Run \u0026amp; show results: Runs the pipeline up until the selected node. The result of the node is stored on the hard drive. We recommend this option if you have limited memory. Show intermediate results: Runs the pipeline up until the selected node. The result of the node *and the ones of intermediate steps are stored on the hard drive.  These operations can also be accessed by selecting the  Quick Run tab in the properties panel:\nHere you can also create a custom quick run that comes with additional settings, including the number of threads, the output folder, and how the cache is utilized.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/run-pipelines/cache/",
	"title": "Data caching",
	"tags": [],
	"description": "Explains the how JIPipe caches intermediate results and how to access them.",
	"content": "JIPipe has a project-wide cache for generated results. This cache can be accessed by algorithms to prevent repeating previous calculation steps.\nLoad data into the cache To cache data, right click a node and click  Update cache. This will execute a Quick run and store all results into the cache.\nAccessing the cache Cache items are assigned a unique identifier ( Snapshot) that is based on relevant algorithm parameters and the processing pipeline behind the data generation. You have multiple ways to manage and access the cache. First, in the top tool bar, there is a summary on how many items are currently cached. If items are stored in the cache, you have multiple options to clear the cache.\nIf you select an algorithm, you have access to its  Cache browser that lists all  Snapshots and all stored data, including a string representation, and annotations if available. By selecting a row in the data table below, you can  Show the item\u0026rsquo;s data. The operation depends on the exact data type. ImageJ images for example are opened in ImageJ.\nIf an algorithm data slot has cached data, icons appear next to the slot. Hover the items with your mouse to show a summary. Clicking the items allows you to manage the cache or display the results in a full-window cache browser.\nManaging the cache The cache consumes large amounts of memory, depending on the pipeline. Use the button at the top (menu bar) to clean all cached data or remove cached items that are invalid (e.g., because the node parameters were changed).\nYou can also enable the \u0026ldquo;Reduce memory\u0026rdquo; mode (bottom) to store unused data on the hard drive, or explicitly move cached items to the hard disk.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/parameter-type/",
	"title": "Creating a parameter type",
	"tags": [],
	"description": "Explains how to create an UI for a parameter",
	"content": "JIPipe requires you to register custom parameter types, where they are assigned an unique identifier. This is done to allow future refactoring without breaking a user\u0026rsquo;s project.\nA custom parameter type must be JSON-serializable via the Jackson library. It is associated to an editor UI that is responsible for updating the parameter value from the GUI.\nA parameter type cannot be a generic class. This is due to restrictions in the JVM. We recommend to create a sub-class for a list of a parameter if you require a list of it down the line. The list parameter inherits from the ListParameter class.\n Creating an editor To create an editor UI, you have to inherit from JIPipeParameterEditorUI.\nThe UI class provides access to the JIPipeParameterCollection object and the JIPipeParameterAccess object that encapsulates the getter and setters, as well as additional annotations.\nThere is also access to the SciJava context object.\nPlease be careful to avoid infinite loops between reloading and setting parameters from UI elements.\n Registering a parameter Register the parameter type and its UI in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // You have to provide an unique ID, the parameter class, a method to create a new instance, a method to create a deep copy, and an UI class  registerParameterType(\u0026#34;my-parameter\u0026#34;, MyParameter.class, MyParameter::new, p -\u0026gt; p.clone(), \u0026#34;My parameter\u0026#34;, \u0026#34;A custom parameter type\u0026#34;, MyParameterParameterEditorUI.class); // If you have a hierarchy of parameters, you can register the editor for the whole hierarchy:  registerParameterEditor(MyCollectionBase.class, MyCollectionParameterEditorUI.class); // There is a predefined method to register enum values:  registerEnumParameterType(\u0026#34;my-enum\u0026#34;, MyEnum.class, \u0026#34;My Enum\u0026#34;, \u0026#34;Enum of values\u0026#34;); } }  Do not forget to register all algorithm parameter types. JIPipe will throw an error if it detects a missing parameter registration.\n There is an overload of registerParameterType that takes the matching list directly and automatically generates the ID, name, and description.\n You can set the instance creation function to null if the parameter is default-constructable. You can set the clone function to null if the parameter type can be copied via a copy constructor.\n You can review your parameter UI via Tools \u0026gt; Development \u0026gt; Show all parameter types.\n Making use of the parameter registration You can use the parameter type registry to get a parameter type info. The info provides access to all metadata from the registry.\nJIPipe comes preinstalled with some common Java types (String, numerics, file and folder paths). You can take a look at the Parameters Extension package for all default parameters that are provided by JIPipe.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-data-api/",
	"title": "Data API documentation",
	"tags": [],
	"description": "",
	"content": "JIPipe communicates data with external applications via a standardized file system hierarchy. The specifications of this format are explained in this page / sub-pages.\nThe specification is used in following circumstances:\n Pipeline output Exported cache results Communication with external script languages (R, Python)  The data API is modular due to the different uses. It incorporates following elements:\n Data table row Data table Pipeline output Exported cache  Additionally, the data API incorporates elements from the JSON API to store metadata.\nThe following graph gives an overview how these relate to tech other.\nmermaid.initialize({startOnLoad:true}); graph LR; DataTable[\"Data table\"] -- DataTableRow[\"Data table row\"]; PipelineOutput[\"Pipeline output\"] -- DataTable; ExportedCache[\"Exported cache\"] -- DataTable;  Detailed descriptions You will find detailed descriptions on the other pages.\n Data table\nOrganizes data into an annotated table\n  Row folder\nData storage of a JIPipe data type in the file system\n  Pipeline output\nA pipeline output folder is generated on running a pipeline using the Run function or via other means of running the pipeline and saving the results to the hard drive. The generated folder follows a hierarchical structure that is based on the location of data within graph compartments, nodes, and slots. It also contains a copy of the project that generated the data in a file project.jip. mermaid.initialize({startOnLoad:true}); graph LR; Root[\"\n  "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/json-extension/",
	"title": "Extension",
	"tags": [],
	"description": "An extension that can be put into the ImageJ plugin folder",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: json-extension.schema.json\n\rAn extension that can be put into the ImageJ plugin folder\r\r\rid:\r\rstring\r\r\r\r\r\r\rUnique ID of this extension. Should have format\r\r.\r\r:\r\r\r\r\r\r\rversion:\r\rstring\r\r\r\r\r\r\rVersion of this extension\r\r\rmetadata:\r\rSee metadata\r\r\r\r\r\r\r\rGeneral metadata about the extension\r\r\ralgorithms:\r\robject[]\r\r\r\r\r\r\rList of added algorithms\rSee algorithm\r\r\r\r\r\r\r\r\r\r\rExample { \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:example-list-tiff\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Example extension\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;An example extension\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;algorithms\u0026#34; : [ { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } ], \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;json-extension\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Explains functionality that allows ImageJ to run JIPipe algorithms or pipelines.",
	"content": "ImageJ to JIPipe JIPipe integrates commonly used data types and popular algorithms from ImageJ. If an algorithm is not available for JIPipe, you can still run them via the Macro node. There is also a Python script node available that behaves similar to the macro node.\nJIPipe to ImageJ JIPipe algorithms and pipelines can be executed from within an ImageJ environment. There are two ways JIPipe integrates back into ImageJ:\n You can run a pipeline project from a macro/command You can run JIPipe algorithms from a macro/command if the slot data types are supported by ImageJ  Running a pipeline You can run an JIPipe pipeline via the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe project. It will ask you the project file and the output directory.\nTo run the command via a macro, run:\nrun(\u0026quot;Run JIPipe project\u0026quot;, \u0026quot;projectFile=\u0026lt;Project\u0026gt;, outputDirectory=\u0026lt;Directory\u0026gt;, threads=\u0026lt;Threads\u0026gt;\u0026quot;)\r There can be issues using the macro recorder depending on which ImageJ algorithms are used. This issue is especially prevalent in ImageJ macro algorithm nodes.\n You can also run JIPipe in headless-mode just like any ImageJ2 algorithm:\n./ImageJ-linux64 --headless --ij2 --run \u0026#34;Run JIPipe project\u0026#34; \u0026#39;projectFile=\u0026#34;\u0026lt;Project\u0026gt;\u0026#34;, outputDirectory=\u0026#34;\u0026lt;Directory\u0026gt;\u0026#34;, threads=\u0026lt;Threads\u0026gt;\u0026#39;  While JIPipe works in Headless-mode, some ImageJ algorithms don\u0026rsquo;t. You will get an error message if an algorithm requires a graphical environment.\n Running a single algorithm JIPipe algorithms can be run from ImageJ macros/commands if the slot data types are compatible with ImageJ. By default, this includes any image data type, result tables, and regions of interest (via ROIManager). If you run the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe algorithm, a dialog with all available algorithms, parameters, and more information is shown.\nA difference to the parameter panel of an algorithm within the graph editor UI is that you have to select the input image.\nOutput data is created according to the slot name. For example if the output slot name is Output, the created image window will also be named Output.\nJust as in a graph, images are converted automatically to the data type specified by the algorithm.\n There may be issues if multiple ROI or result table outputs are generated. JIPipe will merge multiple ROI List data items into one Results Table.\n There can be issues using the macro recorder depending on which ImageJ algorithm is executed. This issue is especially prevalent in ImageJ macro algorithm nodes.\n To run the command via a macro, run:\nrun(\u0026quot;Run JIPipe algorithm\u0026quot;, \u0026quot;nodeId=\u0026lt;Algorithm\u0026gt;, parameters=\u0026lt;Parameters\u0026gt;\u0026quot;)\rThe algorithm ID can be looked up via the plugin manager. Parameters are provided as string in JSON format. The JSON data should have following structure:\n (Optional) An object parameters that contains the algorithm parameters. They are equal to the parameters saved in an JIPipe project file. We recommend to use the Copy command button to obtain the parameters. If you leave out parameters, the default value is assumed. (Optional) An object add-input that contains additional input slot definitions. The entry keys are the slot names. (Optional) An object add-output that contains additional output slot definitions. The entry keys are the slot names. (Optional) An object input. Entry keys correspond to the slot name. The entry value is a string that corresponds to the Window name that contains the data. Only required for image data types, as JIPipe accesses the global ROI manager and global result table.  Use the \u0026ldquo;Copy command\u0026rdquo; button in the \u0026ldquo;Run JIPipe algorithm\u0026rdquo; GUI command to quickly create a valid macro for your parameters.\n If you are a developer of a JIPipe node (Java only) and want to provide your node as separate entry in the ImageJ menu, you can use our Java API to create custom SciJava commands that provide a similar UI to the single algorithm run. You just have to inherit from JIPipeRunCustomAlgorithmCommand and provide the constructor with the node ID. Then add the Plugin annotation just as with any SciJava command.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/plugins/",
	"title": "Managing plugins",
	"tags": [],
	"description": "Explains how to install and manage plugins.",
	"content": "JIPipe has its own plugin (extension) system that is independent of the one provided by ImageJ/SciJava. You can find a list of plugins in Plugins \u0026gt; Manage plugins.\nJIPipe by default supports two types of extensions:\n Java extensions are similar to ImageJ plugins (*.jar) and are the most powerful plugin type. Just like ImageJ plugins, they are located in the plugins directory. JSON plugins are similar to ImageJ macros or scripts, as they are pure text files. Such extensions can be created without programming via the JSON Extension Builder  Some plugins require that dependencies are installed and will notify you if something is wrong. To check if all plugins are in working condition, check if the top right button displays  All plugins valid. Otherwise click the button to show what went wrong and how to solve the issue.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/plots-tables/",
	"title": "Plots and tables",
	"tags": [],
	"description": "This library provides operations to generate and modify tables, as well as creating plots.",
	"content": "The standard library contains algorithms and data types that allows to manipulate tables, and create plots. The table data type is the JIPipe wrapper for the ImageJ results table (see ImageJ integration).\nManipulating tables Table manipulation operations are located in Process \u0026gt; Tables and allow you to add, remove, or replace columns.\nCreating plots Plots can be created via the Analyze \u0026gt; Plot \u0026gt; Plot tables algorithm that processes each incoming result table and produces an automatically generated plot. You can decide which plot type is generated, and how to assign the columns of the input tables to the data series as expected by the plot. Plots are exported automatically as PNG and SVG in the size set up within the algorithm node settings.\nYou can later import the plot back into the JIPipe plot editor that has more options available.\nPlot editor JIPipe comes with a plot editor GUI that allows more refined control over plots than by the standard Plot tables algorithm (for example multiple series). You can either open a plot from results, or create a new plot from scratch via Project \u0026gt; New plot.\nThe settings panel of the plot editor is split into three tabs:\n  Settings contains all general parameters of the plot. It also allows you to change the plot type.  Series contains all data series. A series is a collection of string or number arrays that is used as input for the plot. Depending on the plot type, there can be multiple series (e.g. the line XY plot can display multiple lines)  Data contains a list of data columns that can be assembled to series. You can open the columns in the table editor or import columns from a CSV file. JIPipe also supports generating columns that do not carry any data, but instead generate the requested number of rows.  Table editor While JIPipe prefers opening tables in ImageJ\u0026rsquo;s table view, it contains a table editor that allows you to do basic operations directly from within JIPipe.\nYou can find the operations on the right-hand side. They include some basic operations like modifying rows and columns, and specialized operations for scientific data, such as splitting values by category, quickly integrating the table, and combining columns into a single condition column.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/jython/",
	"title": "Jython integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts via the Jython library",
	"content": "The standard library contains nodes that allow to run Python scripts using the Jython library. Python scripts have access to all JIPipe and ImageJ APIs that are available at runtime.\n Due to restrictions in the Jython library, Python libraries that are built on a native backend (such as Numpy) will not work.\n As JIPipe builds on the functionality provided by ImageJ. Please refer to the ImageJ documentation to find information on how to expand Jython with additional libraries.\n You can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Node Based on Purpose     Jython script JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   Jython script (simple iterating) JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   Jython script (iterating) JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   Jython script (merging) JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Common functions All Python script nodes share a set of variables that are available in the code:\n   Variable Purpose     input_slots A list of all effective input slots. This means, slots like the \u0026lsquo;Parameters\u0026rsquo; slot are not listed here. Each slot is using the Jython API to access the native Java data type. Refer to the JIPipeDataSlot documentation for further information.   output_slots A list of all output slots. Each slot is using the Jython API to access the native Java data type. Refer to the JIPipeDataSlot documentation for further information.   input_slot_map A dictionary from input slot name to input slot instance.   output_slot_map A dictionary from output slot name to output slot instance.    Data batch access Python nodes based on JIPipeSimpleIteratingAlgorithm, JIPipeIteratingAlgorithm, and JIPipeMergingAlgorithm repeat the script for each data batch (or at least once if there is none). Data batches organize the data of various input slots into one bundle that should be processed. Access to this data batch is provided via a variable data_batch.\nThis variable points to an instance of JIPipeDataBatch (or JIPipeMergingDataBatch for the merging algorithm).\nScript parameters Each node provides means to define Python variables inside the JIPipe environment via custom parameters. Each parameter value is passed as variable into Python - the name of the variable being determined by the unique ID of the parameter.\nAll Python nodes are multi-parameter capable (including iterating and merging nodes). \u0026ldquo;Jython script (multi-parameter capable)\u0026rdquo; provides a unique variable parameter_annotations that contains any annotations of the current parameter set.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/metadata/",
	"title": "Metadata",
	"tags": [],
	"description": "Commonly used metadata type in JIPipe.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: metadata.schema.json\n\rCommonly used metadata type in JIPipe.\r\r\rname:\r\rstring\r\r\r\r\r\r\rA name\r\r\rdescription:\r\rstring\r\r\r\r\r\r\rA description\r\r\rauthors:\r\rstring\r\r\r\r\r\r\rComma-separated list of authors\r\r\rwebsite:\r\rstring\r\r\r\r\r\r\rWebsite of the project\r\r\rlicense:\r\rstring\r\r\r\r\r\r\rName of the license\r\r\rcitation:\r\rstring\r\r\r\r\r\r\rCitation for the publication\r\r\r\r\r\rExample { \u0026#34;name\u0026#34; : \u0026#34;Image property annotations\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used annotations for describing image properties\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/usage-in-java/",
	"title": "Usage in Java",
	"tags": [],
	"description": "Explains how to use the JIPipe API to run graphs, algorithms, or projects within pure java code",
	"content": "The JIPipe API allows you to run algorithms, graphs, and projects in a pure Java environment without the need for a GUI or through ImageJ1 or ImageJ2 scripts.\nPrerequisites To use the JIPipe API JIPipe must be initialized first. This requires an ImageJ instance or any other way to load SciJava plugins. The following example shows how to initialize JIPipe.\npublic static void main(String[] args) { // Extract necessary SciJava variables  // An alternative is to create a @Plugin and execute this plugin via ImageJ  final ImageJ ij = new ImageJ(); Context context = ij.context(); // Execute the JIPipe registration if necessary  if (JIPipe.getInstance() == null) { JIPipe.createInstance(context); JIPipe.getInstance().initialize(); } // JIPipe is now ready to use } Loading and running a project You can load a project via a static method. Running the project either involves enqueuing a run into the global queue or running it on the current thread. The run has a multitude of settings that control how/if output is written or how many threads are used.\npublic static void main(String[] args) { // First initialize JIPipe before this line!  // Load the project  // JIPipe will put any non-exception errors or warnings into the report  JIPipeValidityReport report = new JIPipeValidityReport(); JIPipeProject project = JIPipeProject.loadProject(Paths.get(\u0026#34;my-project.jip\u0026#34;), report); // Create a run that generates a deep-copy of the project\u0026#39;s graph  // The run is controlled by the JIPipeRunSettings instance that allows you to  // have runs without caching or writing outputs if needed  JIPipeRunSettings settings = new JIPipeRunSettings(); settings.setOutputPath(Paths.get(\u0026#34;/data/my-project-output\u0026#34;)); JIPipeRun run = new JIPipeRun(project, settings); // Option 1: Run in separate thread (Async)  JIPipeRunnerQueue.getInstance().enqueue(run); // Option 2: Run it on the current thread  // The run itself has a property getProgressInfo() that allows access to the progress \u0026amp; log  run.run(); } Loading a result To load an existing result folder, the run is imported back into JIPipe. The run itself contains a graph instance with nodes that are aware of the data storage location. The storage location contains a data-table.json file that can be imported into an exported data table. This table contains all metadata and the relative storage location of each row.\nRow data is always stored in folders that correspond to the row index. For example, the first row\u0026rsquo;s data is stored in a folder 0.\npublic static void main(String[] args) { // First initialize JIPipe before this line!  // Load the run  // It will load the project as well  Path path = Paths.get(\u0026#34;/data/my-project-output\u0026#34;); JIPipeRun run = JIPipeRun.loadFromFolder(path, report); run.getProject().setWorkDirectory(path); // You can now access the run\u0026#39;s graph and access the data slots  JIPipeDataSlot slot = run.getGraph().getNodes().get(\u0026#34;some-node\u0026#34;).getOutputSlot(\u0026#34;Output\u0026#34;); // Load the slot\u0026#39;s data table  JIPipeExportedDataTable table = slot.getStorageDataTable(); // Example: Get the folder where the first row stores its data  Path firstRowStorage = slot.getRowStoragePath(0); } Building and running a graph JIPipe allows to create and run graphs without involving a project. A simple graph runner is available to execute a graph.\npublic static void main(String[] args) { // First initialize JIPipe before this line!  JIPipeGraph graph = new JIPipeGraph(); // There are multiple ways to instantiate a new node:  // Option 1: Utility function  JIPipeGraphNode first = JIPipe.createNode(\u0026#34;import-file\u0026#34;, JIPipeGraphNode.class); // Option 2: Using the registry  JIPipeGraphNode second = JIPipeNodeRegistry.getInstance().getInfoById(\u0026#34;import-imagej-imgplus-from-file\u0026#34;).newInstance(); // Add the nodes into the graph and connect them  graph.insertNode(first, JIPipeGraph.COMPARTMENT_DEFAULT); graph.insertNode(second, JIPipeGraph.COMPARTMENT_DEFAULT); graph.connect(first, second); // Use the graph runner  // We always recommend to make a copy of the graph if it is used somehere else  JIPipeGraphRunner run = new JIPipeGraphRunner(new JIPipeGraph(graph)); // Option 1: Run in separate thread (Async)  JIPipeRunnerQueue.getInstance().enqueue(run); // Option 2: Run it on the current thread  // The run itself has a property getProgressInfo() that allows access to the progress \u0026amp; log  run.run(); } Running a single node You can run single algorithm nodes without involving a project or a graph:\npublic static void main(String[] args) { // First initialize JIPipe before this line!  JIPipeSimpleIteratingAlgorithm node = JIPipe.createNode(\u0026#34;import-imagej-imgplus-from-file\u0026#34;, JIPipeSimpleIteratingAlgorithm.class); // The node requires a progress info  JIPipeProgressInfo progress = new JIPipeProgressInfo(); // Always clear the node first (allows you to re-use it)  node.clearSlotData(); // Add inputs  node.getFirstInputSlot().addData(new FileData(Paths.get(\u0026#34;/data/image.tif\u0026#34;)), progress); // Run the node  node.run(progress); // Extract the output  ImagePlusData image = node.getFirstOutputSlot().getData(0, ImagePlusData.class, progress); } "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/python/",
	"title": "Python integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts.",
	"content": "The standard library contains nodes that allow to run Python scripts using an existing installation of Python. This means you will need to download Python, Anaconda, or Miniconda.\nSetting up Python You have the option to either select an existing Python environment, or let JIPipe install a new Conda environment into a folder.\nTo setup Python, navigate to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; Python integration. There you will find a setting Python environment that, by default, is not set up.\nIf you want to select an existing Python environment or let JIPipe handle the installation for you, choose the Select/Install button and select the appropriate operation. Follow the instructions provided in the newly opened window.\nYou can also edit existing Python environments by selecting the Edit button to, for example, setup environment variables or change command line parameters.\nIncluded nodes You can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Node Based on Purpose     Python script JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   Python script (simple iterating) JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   Python script (iterating) JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   Python script (merging) JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Common functions All Python script nodes share a set of variables that are available in the code:\n   Variable Purpose     jipipe_inputs A dict of slot name to an instance of DataSlot. Each item represents the input data of the current data batch/current input.   jipipe_outputs A dict of slot name to an instance of DataSlot. Each item represents the output data of the current data batch/current output.    Data I/O Python nodes based on JIPipeSimpleIteratingAlgorithm, JIPipeIteratingAlgorithm, and JIPipeMergingAlgorithm repeat the script for each data batch (or at least once if there is none). Data batches organize the data of various input slots into one bundle that should be processed.\nData access is handled through temporary folders that contain input/output data in JIPipe standardized format. The nodes are supplied with a Python API that allows to read/write data and metadata in this format.\nYou can choose to not use the reading/writing functions provided by this package and access the input/output folders directly.\nEach JIPipe data type provides information about the structure of the data folder. You can find it in [?] \u0026gt; Data type compendium.\n Script parameters Each node provides means to define Python variables inside the JIPipe environment via custom parameters. Each parameter value is passed as variable into Python - the name of the variable being determined by the unique ID of the parameter.\nAll Python nodes are multi-parameter capable (including iterating and merging nodes). \u0026ldquo;Python script (multi-parameter capable)\u0026rdquo; provides a unique variable parameter_annotations that contains any annotations of the current parameter set.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/point/",
	"title": "Point",
	"tags": [],
	"description": "A point",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: point.schema.json\n\rA point\r\r\rx:\r\rinteger\r\r\r\r\r\r\rX coordinate\r\r\ry:\r\rinteger\r\r\r\r\r\r\rY coordinate\r\r\r\r\r\rExample { \u0026#34;x\u0026#34; : 2900, \u0026#34;y\u0026#34; : 100 } "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/r-integration/",
	"title": "R integration",
	"tags": [],
	"description": "This library provides nodes that allow to run R scripts.",
	"content": "The standard library contains nodes that allow to run R scripts. This means that you will need to install a distribution of R.\nYou will need to install R (https://www.r-project.org/) and setup JIPipe to find this installation.\n Setting up R You have the option to either select an existing R environment, or let JIPipe install a new R environment into a folder (only available on Windows).\nTo setup Python, navigate to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; R integration. There you will find a setting R environment that, by default, is not set up.\nIf you want to select an existing R environment or let JIPipe handle the installation for you, choose the Select/Install button and select the appropriate operation. Follow the instructions provided in the newly opened window.\nYou can also edit existing R environments by selecting the Edit button to, for example, setup environment variables or change command line parameters.\nIncluded nodes You can find the R scripting nodes in the Miscellaneous menu. You can find algorithms equivalent to following Java standard algorithms:\n   Node Based on Purpose     R script (iterating) JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   R script (merging) JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Both nodes share a similar R API to communicate with JIPipe - the difference being how many data items can be processed in each iteration. All nodes repeat the script for each data batch (or at least once if there is none). Data batches organize the data of various input slots into one bundle that should be processed.\nData I/O As R is run in a separate environment, the data is communicated by writing it to the hard drive from one process and reading it back inside the other process. Currently, the nodes are designed for following data types:\n   Data type As input As output     Results table Provided as CSV file or data frame Saved as single CSV file. JIPipe will load this CSV file.   Colored Image (RGB) Not supported Saved as single PNG/TIFF/JPG. JIPipe will load the image.    Other data types are supported, although there are no predefined utility functions to load/save them for now.\nLoading results tables Result tables can be loaded via the JIPipe.GetInputAsDataFrame(slot, row=0) function. The slot parameter must be identical to the name of the input slot. The row parameter indicates which item of the current data batch should be returned. Please note that row can only be zero if you are using R script (iterating).\nIf you have multiple rows, you can find their count in JIPipe.InputSlotRowCounts\nfor( i in 1:JIPipe.InputSlotRowCounts$Tables) { # Note that the row has zero-based indices table \u0026lt;- JIPipe.GetInputAsDataFrame(slot=\u0026#34;Tables\u0026#34;, row=i-1) } Writing result tables Result tables can be written via a function JIPipe.AddOutputDataFrame(data, slot, annotations=list()). This will add a new result table to the specified output. Please note, that you can add multiple outputs.\nThe provided data must be of a type compatible with write.csv, like data.frame.\nOptionally, you can provide a list of annotations that should be added to the specified output data as list of named strings.\nlibrary(datasets) JIPipe.AddOutputDataFrame(iris, \u0026#34;Tables\u0026#34;, annotations=list(\u0026#34;data set\u0026#34;=\u0026#34;Iris\u0026#34;)) Writing plots or other images As R does not have a dedicated data type for images, the JIPipe API will only provide means to generate a valid output file name. For this, two methods JIPipe.AddOutputPNGImagePath(data, slot, annotations=list()) and JIPipe.AddOutputTIFFImagePath(data, slot, annotations=list()) are available that produce a path for PNG or TIFF files respectively.\nWe recommend to use the \u0026lsquo;Image (RGB)\u0026rsquo; or any other RGB output type. This is due to the R behavior of generating images with indexed colors that are detected as greyscale images by JIPipe.\n library(datasets) # Generate the output file name png.file.name \u0026lt;- JIPipe.AddOutputPNGImagePath(slot=\u0026#34;Plot\u0026#34;) # Use standard R functions. Write into this file. png(png.file.name, width = 800, height = 600) plot(iris$Petal.Length, iris$Petal.Width, pch=21, bg=c(\u0026#34;red\u0026#34;,\u0026#34;green3\u0026#34;,\u0026#34;blue\u0026#34;)[unclass(iris$Species)], main=\u0026#34;Edgar Anderson\u0026#39;s Iris Data\u0026#34;) dev.off() # JIPipe will automatically load the data Reading and writing other data types Currently, only reading and writing of tables, as well as writing of image data is supported via convience functions. The node supports all other JIPipe data types, although import and export must be written via custom functions.\nJIPipe provides the input of each data item via a dedicated folder that contains all files related to this data. Use JIPipe.GetInputFolder(slot, row=0) get obtain the path to this folder.\nOutputs are also expected to be provided in standardized JIPipe format. Use JIPipe.AddOutputFolder(slot, annotations=list()) to obtain a valid path to such a folder and register the output.\nEach JIPipe data type provides information about the structure of the data folder. You can find it in [?] \u0026gt; Data type compendium.\n Script parameters Each node provides means to define R variables inside the JIPipe environment via custom parameters. Each parameter value is passed as variable into R - the name of the variable being determined by the unique ID of the parameter.\nIndependent of the compatibility of a parameter\u0026rsquo;s unique key, all variables are also provided as named list entries in JIPipe.Variables.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/",
	"title": "Standard library",
	"tags": [],
	"description": "Contains some explanations about the algorithms that are included in the JIPipe standard distribution.",
	"content": "JIPipe comes with a standard library of data types, algorithms, and other functionality that makes it ready to use for most common image analysis projects. The library of course can be extended with plugins.\nPlease take a look at the following standard library components:\n ImageJ integration\nThis library provides integration of ImageJ data types, as well as common ImageJ algorithms.\n  Macro node\nThe macro node allows to run ImageJ macros.\n  Filesystem algorithms\nThis library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.\n  Multi-parameter algorithms\nThis library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.\n  Data annotation algorithms\nThis library provides basic functionality to add annotations to data slot rows.\n  Plots and tables\nThis library provides operations to generate and modify tables, as well as creating plots.\n  Jython integration\nThis library provides nodes that allow to run Python scripts via the Jython library\n  Python integration\nThis library provides nodes that allow to run Python scripts.\n  R integration\nThis library provides nodes that allow to run R scripts.\n  Cellpose integration\nIntegrates the Cellpose tool into JIPipe.\n  Deep Learning\nIntegrates Deep Learning capabilities (Tensorflow, Keras).\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/cellpose/",
	"title": "Cellpose integration",
	"tags": [],
	"description": "Integrates the Cellpose tool into JIPipe.",
	"content": "JIPipe provides an integration of Cellpose that both can apply segmentation, and training from within JIPipe.\nSetting up Cellpose Cellpose is a Python library and is integrated via the Python library. This means that you will need to setup a Python environment with Cellpose installed (follow the documentation here: https://github.com/MouseLand/cellpose) and provide the appropriate settings to JIPipe.\nAlternatively, JIPipe provides automated installers (tested on Linux and Windows) that will download and setup Cellpose automatically.\nTo setup Cellpose, navigate to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; Cellpose. Here you can find a setting Cellpose Python environment that is enabled by default, meaning that Cellpose is executed in a different Python environment than the one setup in the Python library (recommended). You can disable the setting if you want.\nTo install Cellpose or select an existing Python environment, click the Select/Install button. Here you can select an existing Conda environment, or let JIPipe install the CPU or GPU version of Cellpose.\nGPU processing requires large amounts of VRAM. You can always disable GPU processing on a per-node basis if your hardware is not sufficient. Cellpose also will fall back to CPU processing if GPU processing cannot applied.\n Especially on Windows, the installation of the GPU version takes a considerable time (30 min +). Due to buffered text output, you might not always receive progress info from the Conda installation process. We cannot fix this on our end.\n Only Nvidia GPUs: If you want to make use of GPU processing, you will need to install the CUDA Toolkit. On Ubuntu Linux, install the package nvidia-cuda-toolkit (please review the output of APT carefully, as nvidia-cuda-toolkit only works with specific driver versions). On Windows, download the CUDA toolkit from the Nvidia homepage. Please restart JIPipe or Windows after installing the toolkit - otherwise the installed files will not be found by Tensorflow.  Segmentation with Cellpose Segmenting images with Cellpose is handled by the Cellpose node (Images \u0026gt; Deep learning \u0026gt; Cellpose). It receives 2D or 3D images and, by default, outputs the ROI in ImageJ/JIPipe format (ROI Lists).\nThe node has a multitude of parameters that allow to customize its behavior and how Cellpose is executed:\n You can enable additional outputs, for example the probability map or the cell flows You can change the model to one of the pretrained ones (Cyto or Nuclei), or a custom pre-trained model (received via an input slot) The model and performance parameters Various thresholds used internally by Cellpose Enable augmentation or other tweaks  Training with Cellpose JIPipe supports training a Cellpose model and size model via the Cellpose training node. It can train from scratch, or continue training a predefined model (custom or Cyto/Nuclei).\nJIPipe automatically saves all inputs in appropriate folders and runs the training CLI according to the Cellpose documentation.\nCellpose requires input images annotated with their respective mask labels. To annotate masks to the image, use the Annotate with data node.\nThe output of this node are Cellpose model data that can be either saved to a file or further processed in JIPipe.\nTest data is optional (that\u0026rsquo;s why the triangle is grey if disconnected). We still recommend to provide both training and test data sets. You can use the \u0026lsquo;Split data randomly (percentage)\u0026rsquo; node to split data into two sets.\n Troubleshooting The most common issue is insufficient VRAM with GPU processing enabled. Please always ensure that issues are not caused by GPU problems (disable GPU processing to be sure!).\nJIPipe automatically exports all relevant data and scripts into a temporary folder that, by default, is automatically deleted on successful execution of the node. You can always disable this behavior by disabling the Clean up data after processing setting. The folder is always logged and can be accessed via Tools \u0026gt; Logs.\nThe logs also provide information about the exact Python commands that are executed. You can use this information to find out why there is a problem.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/create-json-extensions/",
	"title": "Extension builder",
	"tags": [],
	"description": "Explains the extension builder tool",
	"content": "JIPipe allows the creation of extensions that contain additional algorithms without the need for writing Java code. We recommend starting from a functional pipeline project and export the whole pipeline or a part of it into a JSON Extension. Alternatively, you can create custom algorithms from scratch within the extension builder.\nIf you want a step-by-step guideline on how to create a custom algorithm, please check out our tutorial.\nExporting from an existing pipeline Within the JIPipe interface, you can find contextual menu items and buttons that allow to generate an exported algorithm.\n To export the whole pipeline as algorithm, select Project \u0026gt; Export as custom algorithm To export a graph compartment, select it and click the Export button at the top-right corner. Then select  As custom algorithm To export a selection of nodes, click the Export button at the top-right corner. JIPipe ensures that connections within the selected nodes are exported as well. To export a single algorithm, click the Export button at the top-right corner. Please note that if the algorithm is a  Group algorithm, the group contents are exported instead of the group iself.  This will open a tab showing a preview of the pipeline. Select Export to extension to copy the custom algorithm into a new or existing extension.\n\rTo open a new extension builder or load a JSON extension, you can use Plugins \u0026gt; New JSON extension ...\r\rThe extension builder The extension builder opens three tabs:\n A short introduction A tab that allows you to change the extension settings and metadata A tab that lists all algorithms that are part of the extension  Extension settings All extension metadata can be changed from within this tab. There are only three fields that are mandatory and one where you have to put special care in deciding about the value:\n Unique extension ID is the most important field. It contains a unique identifier that is utilized by JIPipe to figure out project and algorithm dependencies. It must have following format: [Author]:[Id] where [Author] contains information about the author (ideally in Maven-compatible format) and [Id] is the identifier if this extension within the author\u0026rsquo;s group. Version is not used by JIPipe but can be helpful for users to find issues Name is displayed in the plugin manager  You can write anything you want into the other metadata fields or leave them out.\nExtension contents This interface allows you to manage the list of algorithms that are contained within the extension. If you want, you can also create algorithms from scratch (although we do not recommend this as you cannot test pipelines within the extension builder). On selecting an algorithm, you can edit its metadata.\n Algorithm ID is the most important field. It uniquely identifies the algorithm within JIPipe. The ID is not namespaced (meaning that it is independent of the extension ID). We recommend to choose a meaningful name that can be easily expanded for specialized algorithms. Category determines in which menu the algorithm is shown. Please note that if you select DataSource, the algorithm will be placed in a menu based on the output data type. Choosing Internal is not allowed.  You can edit the graph that defines the algorithm\u0026rsquo;s workload by clicking  Edit algorithm. Use this to modify the pipeline to your needs and change parameters. Please note that you cannot test the pipeline.\n\rWe recommend to check if you have some parameters that are invalid or dangerous (e.g. file paths that were copied when exportiong from a project). You algorithms should always\rhave sane defaults.\r\rExporting parameters By default (this excludes exporting from a  Group algorithm) your algorithm will not have any parameters aside of the default ones (name, description, pass-though, and enabled). The extension builder comes with a powerful editor to reference parameters within the algorithm\u0026rsquo;s graph.\nExported parameters are organized in Groups with each group having a title and optional description. Each group holds a collection of parameter references that can be assigned a custom name and description. Click  Add group to create a new empty group or use the  Auto add algorithm button to import parameters from a node and automatically create groups.\nIn a group, you can use the  Add parameter button to create a reference.\n\rHover over the blue  wrench icon to display information about the referenced parameter.\r\r\rEach parameter can only be referenced once. You will get a warning if you have duplicate references. If you ignore the warning, JIPipe will just skip them when creating the parameter UI.\r\r\rThe parameter editor UI implements a sub-set of the parameter reference standard to prevent overloading the UI. You always can change the JSON file to control additional properties like\ra manual order of the parameter items.\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/project/",
	"title": "Project",
	"tags": [],
	"description": "An analysis project",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: project.schema.json\n\rAn analysis project\r\r\rjipipe:project-type:\r\rstring\r\r, x ∈ {\rproject\r\r(default)\r}\r\r\r\r\r\r\rUsed to identify this JSON as JIPipe project\r\r\rmetadata:\r\rSee metadata\r\r\r\r[object Object]\r\r\r\r\r\rGeneral information about the project\r\r\rdependencies:\r\robject[]\r\r\r\r\r\r\rDependencies of this project\rSee dependency\r\r\r\r\r\r\r\rgraph:\r\rSee graph\r\r\r\r[object Object]\r\r\r\r\r\rContains the pipeline nodes\r\r\rcompartments:\r\robject\r\r\r[object Object]\r\r\r\r\r\rFor organization of compartments\r\rcompartment-graph:\r\rSee graph\r\r\r\r[object Object]\r\r\r\r\r\rStructural graph of compartments\r\r\r\r\r\r\r\r\r\rExample { \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;project\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Empty (3 compartments)\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;This template contains three compartments \u0026#39;Preprocessing\u0026#39;, \u0026#39;Analysis\u0026#39;, and \u0026#39;Postprocessing\u0026#39; that are connected to each other.\u0026#34;, \u0026#34;authors\u0026#34; : [ ], \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Standard plots\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used plot types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:plots\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Integrates ImageJ algorithms into JIPipe\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-algorithms\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Compartment management\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types required for graph compartment management\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:compartments\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ integration\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Adds support for commonly used ImageJ data types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://jipipe.org/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-integration\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;additional-metadata\u0026#34; : { \u0026#34;pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe:pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe.ui:project-tabs\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.project.JIPipeProjectTabMetadata\u0026#34;, \u0026#34;data\u0026#34; : { \u0026#34;open-tabs\u0026#34; : [ \u0026#34;singleton:INTRODUCTION\u0026#34;, \u0026#34;singleton:COMPARTMENT_EDITOR\u0026#34;, \u0026#34;graph-compartment:preprocessing\u0026#34;, \u0026#34;graph-compartment:analysis\u0026#34;, \u0026#34;graph-compartment:postprocessing\u0026#34; ], \u0026#34;selected-tab\u0026#34; : null } } }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing-folder-list\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 300 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-folder-list\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;folder-paths\u0026#34; : [ \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5516\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5517\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5518\u0026#34; ], \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Folder list\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;preprocessing-path-to-annotation\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 500 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;path-to-annotation-simple\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;annotation-merge-strategy\u0026#34; : \u0026#34;OverwriteExisting\u0026#34;, \u0026#34;remove-extensions\u0026#34; : true, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;generated-annotation\u0026#34; : \u0026#34;Dataset\u0026#34;, \u0026#34;full-path\u0026#34; : false, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Path to annotation\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 700 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;subfolder\u0026#34; : \u0026#34;in\u0026#34;, \u0026#34;recursive-follows-links\u0026#34; : true, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;*.tif\u0026#34;, \u0026#34;invert\u0026#34; : false } ], \u0026#34;only-filenames\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;recursive\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-import-image\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 900 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-imagej-imgplus-from-file\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;generated-image-type\u0026#34; : \u0026#34;imagej-imgplus\u0026#34;, \u0026#34;title-annotation\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image title\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Import image\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-preprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 1100 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis-gaussian-blur-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-blur-gaussian2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;sigma-y\u0026#34; : -1.0, \u0026#34;sigma-x\u0026#34; : 1.0, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Gaussian blur 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-auto-threshold-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-threshold-auto2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;method\u0026#34; : \u0026#34;Default\u0026#34;, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;dark-background\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Auto threshold 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-distance-transform-watershed-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 650 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-binary-dtwatershed2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Distance transform watershed 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-find-particles-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 850 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-analyze-find-particles2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;min-particle-circularity\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Find particles 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;min-particle-size\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;annotation-type\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image index\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;max-particle-circularity\u0026#34; : 1.0, \u0026#34;split-slices\u0026#34; : true, \u0026#34;exclude-edges\u0026#34; : false, \u0026#34;measurements\u0026#34; : { \u0026#34;values\u0026#34; : [ \u0026#34;Centroid\u0026#34;, \u0026#34;PixelValueMinMax\u0026#34;, \u0026#34;Area\u0026#34; ] }, \u0026#34;max-particle-size\u0026#34; : \u0026#34;Infinity\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-analysis-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 1050 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing-plot-tables\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 550, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;plot-from-table\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;plot-type\u0026#34; : \u0026#34;plot-histogram\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Plot tables\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;plot-parameters/export-height\u0026#34; : 768, \u0026#34;plot-parameters/value-axis-label\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;plot-parameters/bins\u0026#34; : 10, \u0026#34;plot-parameters/export-width\u0026#34; : 1024, \u0026#34;plot-parameters/bin-axis-label\u0026#34; : \u0026#34;Bin\u0026#34;, \u0026#34;plot-parameters/histogram-type\u0026#34; : \u0026#34;Frequency\u0026#34;, \u0026#34;plot-parameters/title\u0026#34; : \u0026#34;Histogram plot\u0026#34;, \u0026#34;column-assignments\u0026#34; : { \u0026#34;parameters\u0026#34; : { \u0026#34;Value\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Values to generate a histogram from. (Numeric column)\u0026#34;, \u0026#34;visibility\u0026#34; : \u0026#34;TransitiveVisible\u0026#34;, \u0026#34;field-class\u0026#34; : \u0026#34;org.hkijena.jipipe.extensions.tables.parameters.TableColumnSourceParameter\u0026#34;, \u0026#34;value\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;PickColumn\u0026#34;, \u0026#34;column-source\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;Equals\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;Area\u0026#34;, \u0026#34;invert\u0026#34; : false }, \u0026#34;generator-source\u0026#34; : { \u0026#34;generator-type\u0026#34; : null, \u0026#34;generated-type\u0026#34; : \u0026#34;NumericColumn\u0026#34; } }, \u0026#34;short-key\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;ui-order\u0026#34; : 0, \u0026#34;field-class-id\u0026#34; : \u0026#34;table-column-source\u0026#34; } } } }, \u0026#34;postprocessing-postprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { }, \u0026#34;output\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 1100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing-plot-tables\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Image\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : true } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Annotated paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-folder-list\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Folder paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Paths\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;ROI\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] }, \u0026#34;compartments\u0026#34; : { \u0026#34;compartment-graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Preprocessing\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Analysis\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 188, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] } } } "
},
{
	"uri": "https://www.jipipe.org/citation/",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nThe publication is currently in preparation. Please visit this page again later.\n Thanks!\nJIPipe was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n   \n "
},
{
	"uri": "https://www.jipipe.org/documentation/cli/",
	"title": "Command Line Interface",
	"tags": [],
	"description": "Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.",
	"content": "You can run JIPipe pipelines without a graphical interface via the command line.\nJust run following command:\n./ImageJ --pass-classpath --full-classpath --main-class org.hkijena.jipipe.JIPipeCLI run --project \u0026lt;project file\u0026gt; --output-folder \u0026lt;output folder\u0026gt; Command line options ./ImageJ --pass-classpath --full-classpath --main-class org.hkijena.jipipe.JIPipeCLI run \u0026lt;options\u0026gt;  --project \u0026lt;Project file\u0026gt; provides the project file to be executed --output-folder \u0026lt;folder\u0026gt; defines where outputs will be written. Outputs are in standard JIPipe format. Optional: --num-threads \u0026lt;N=1,2,3,...\u0026gt; lets you enable multi-threading Optional: --overwrite-parameters \u0026lt;JSON file\u0026gt; allows you to overwrite specific parameters without the need for changing the project file Optional: --P\u0026lt;Node ID\u0026gt;/\u0026lt;Parameter ID\u0026gt; \u0026lt;Parameter value JSON\u0026gt; overwrites a specific parameter with the specified value  Overwriting parameters The JIPipe project file contains all parameters of a project. Still, it may be useful to overwrite specific parameters without the need for editing the file. A use case for this is automated parallel execution of a pipeline within a script (e.g., using GNU Parallel).\nYou can overwrite parameters by providing a JSON file and by setting CLI options. The CLI options are parsed in the provided order, meaning that a --P override will replace values set in a previously provided --overwrite-parameters and vice versa. It is also possible to provide multiple --overwrite-parameters if desired.\nParameter overwrite file format The --overwrite-parameters file must have following JSON format:\n{ \u0026#34;\u0026lt;Node ID\u0026gt;/\u0026lt;Parameter ID\u0026gt;\u0026#34;: \u0026#34;\u0026lt;appropriate value\u0026gt;\u0026#34; } for example:\n{ \u0026#34;gaussian-blur/sigma-x\u0026#34;: 5, \u0026#34;gaussian-blur/sigma-y\u0026#34;: 1 } Node ID The node ID can either bei the node UUID (a long and unique string of letters and numbers) or the node\u0026rsquo;s alias ID (human-readable name). If you want to be sure, then use the UUID, as it will never change, while the alias ID will be updated if the node is renamed by the user.\nYou can find both the node UUID and alias ID inside the JIPipe GUI by selecting a node and reviewing the node description/documentation.\nParameter ID The parameter ID can be found by selecting a node and moving the mouse over a parameter. Its ID then will be displayed in the documentation below.\nAlternatively, you can open the parameter explorer by right-clicking a node and selecting Parameter explorer. This tool displays the more technical info about each parameter.\nAppropriate parameter values If you do not provide a valid JSON value for the parameter, the CLI tool will crash. To find out which value is appropriate, use the Parameter explorer (see above), which will display the raw JSON values for you. The tool also allows you to \u0026ldquo;test\u0026rdquo; parameter values in a editor and copy its JSON representation.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/deep-learning/",
	"title": "Deep Learning",
	"tags": [],
	"description": "Integrates Deep Learning capabilities (Tensorflow, Keras).",
	"content": "JIPipe provides Deep Learning support via a standardized Python interface that allows to train/segment with different networks.\nSetting up Deep Learning Deep Learning requires a Python installation that comes with Tensorflow 2. To simplify this process, we included automated installers for this environment that can be accessed via Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; Deep learning. Here, click Select/install at the Tensorflow item.\nThe installer will ask you to review various settings - these should be fine for most system configurations. If you are more experienced, then you can change the settings accordingly. You can also select an existing Conda or virtualenv environment by choosing the Additional compatible installers section inside Select/Install.\nGPU processing requires large amounts of VRAM. You can always disable GPU processing on a per-node basis if your hardware is not sufficient.\n Especially on Windows, the installation of the GPU version takes a considerable time (30 min +). Due to buffered text output, you might not always receive progress info from the Conda installation process. We cannot fix this on our end.\n Only Nvidia GPUs: If you want to make use of GPU processing, you will need to install the CUDA Toolkit. On Ubuntu Linux, install the package nvidia-cuda-toolkit (please review the output of APT carefully, as nvidia-cuda-toolkit only works with specific driver versions). On Windows, download the CUDA toolkit from the Nvidia homepage. Please restart JIPipe or Windows after installing the toolkit - otherwise the installed files will not be found by Tensorflow.  Training To train a network from scratch, add a Create model node into the pipeline and set it up. It allows you to choose from different architectures and setup the expected image size, the number of classes, and additional factors like the learning rate. Here you also have to decide which kind of model is created: For example you can create segmentation oder classification models.\nDepending on the model choice, you will need to prepare your data in different ways:\nSegmentation models Segmentation models are trained on labeled images, where the label is in most cases a binary mask. The label must be annotated as data annotation to the raw image (for example via the Annotate with data node). The data is supplied to the Train model (labeled images) node, which has three inputs:\n Training data: This contains the labeled images that are used for training the network Test data: This contains labeled images for evaluating the performance of the network The model (created from Create model or a pretrained model)  Please always ensure that there is no data shared between training and test data to prevent overfitting. You can achieve this either manually or by using the Split data randomly (percentage) node.\nClassifier models Classifiers determine which kind of object is shown in the image.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/create-pipelines/groups/",
	"title": "Group nodes",
	"tags": [],
	"description": "Explains the group node feature.",
	"content": "While compartments offer a simple way to structure pipelines into functional units, they are not suitable for creating \u0026ldquo;user-defined\u0026rdquo; nodes that can be re-used. Node groups cover this use case by providing a node that contains a dedicated pipeline inside of it. Data is communicated between the main and the inner pipeline via interface nodes that can be customized by users.\nThe group node can be found in Miscellaneous \u0026gt; Group, or can be created from a set of selected nodes by right-clicking them and selecting the Group option (which will also create inputs and outputs that match the selection).\nDouble-clicking the group (or clicking the Edit graph inside the properties) opens the pipeline that is contained inside the group. It contains two interface nodes (Group input and Group output) that define which data is passed from outside the group or exported to the group outputs. Modifying the slots of these interface nodes changes the slots of the group node itself.\nExporting parameters Users can export parameters from nodes that are inside the group to the group node itself. To do this, click the Edit parameters button in the node group\u0026rsquo;s parameter list. You can either create custom parameter groups and add parameters one-by-one, or add a whole node from the pipeline into the list.\n If you want to hide all other parameters of the group, select the \u0026lsquo;Show limited parameters\u0026rsquo; option.\n If you want to configure multiple nodes with the same parameter, use a \u0026lsquo;Define parameter\u0026rsquo; node to create the parameter value and then either directly make use of it via the multi-parameter slot or generate annotations (via \u0026lsquo;Parameters to annotations\u0026rsquo;) and read the values back in with adaptive parameters.\n Looping data JIPipe processes data node-per-node, meaning that a node always processes all available input data before passing the results to the next node. This is easy to understand and makes no assumptions about the structure of the data. The issue is that such a model allocates all memory required to process the data at once.\nTo solve this issue, group nodes can loop through the data batches of its input and repeat the embedded pipeline for each of the batches. Just set the Graph iteration mode parameter to a different value than Pass data through.\nJIPipe provides loop nodes that offer the same functionality as group node looping, but without the need for encapsulating nodes into a group.\n We suggest to prepare file data and paths outside the group and then apply all steps that are working on image data (e.g., loading and processing) inside the group.\n "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/slot-definition/",
	"title": "Slot definition",
	"tags": [],
	"description": "Defines a data slot",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: slot-definition.schema.json\n\rDefines a data slot\r\r\rslot-data-type:\r\rstring\r\r\r\r\r\r\rThe data type ID of the data stored in this slot\r\r\rslot-type:\r\rstring\r\r, x ∈ {\rInput\r\r,\rOutput\r\r}\r\r\r\r\r\r\rDetermines if the slot is an input or an output\r\r\rinherited-slot:\r\robject\r\r\r\r\r\rOnly valid for output slot. Defines from which slot to inherit the data type. Can be '*' to select the first available slot.\r\r\rname:\r\rstring\r\r\r\r\r\r\rUnique slot name\r\r\rcustom-name:\r\robject\r\r\r\r\r\rUser-customizable name. Only displayed in UI.\r\r\rinheritance-conversions:\r\robject\r\r\r[object Object]\r\r\r\r\rOnly valid for slot inheritance. Applies conversiuons to the inherited type. Must contain map from input data type ID to output data type ID. Conversion is a finite text replacement system.\r\r\r\r\r\rExample { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inheritance-conversions\u0026#34;: { \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;: \u0026#34;imagej-imgplus-2d-greyscale-8u\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;Output\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/data-table/",
	"title": "Data table",
	"tags": [],
	"description": "Defines a data table",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: data-table.schema.json\n Defines a data table   node-id:  string      The node type ID that generated the data. Optional.   slot:  string      The slot name that generated the data. Optional.   rows:  object[]       The data row items See data-table-row        data-type:  string       The data type ID behind the row      Example { \u0026#34;node-id\u0026#34; : \u0026#34;ij1-fft-forward2d\u0026#34;, \u0026#34;slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;internal-path\u0026#34; : \u0026#34;/fastdata/projects/JIPipe/Output\u0026#34;, \u0026#34;rows\u0026#34; : [ { \u0026#34;index\u0026#34; : 0, \u0026#34;annotations\u0026#34; : [ ], \u0026#34;true-data-type\u0026#34; : \u0026#34;imagej-imgplus-fft-2d\u0026#34; } ], \u0026#34;data-type\u0026#34; : \u0026#34;imagej-imgplus-fft-2d\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation/create-pipelines/loops/",
	"title": "Loop nodes",
	"tags": [],
	"description": "Explains the loop node feature.",
	"content": "JIPipe processes data node-per-node, meaning that a node always processes all available input data before passing the results to the next node. This is easy to understand and makes no assumptions about the structure of the data. The issue is that such a model allocates all memory required to process the data at once.\nGroup nodes provide a feature that allows to loop the contained pipeline for each input data batch, reducing the memory allocated during the processing (if the groups are set up so that memory-intensive tasks are split). The nodes on the other hand have no access to the project-wide data cache, as groups contain separate pipelines. Loop nodes solve this issue by providing the looping ability of group nodes within the main pipeline.\nTo make a section of nodes loop, just insert a Loop start node. Optionally, you add Loop end nodes to indicate where the loop should end.\nThe Loop start node can be switched to following iteration modes:\n Per iterating data batch: Finds data batches where only one data item per slot is found. Iterates through all data batches. Per merging data batch: Finds data batches where multiple data items per slot are found. Iterates through all data batches. Pass data through: Disables looping  You can also enable the Pass through parameter of loop starts and ends to disable their functionality. In the case of loop starts, the pipeline will be run as if there is no loop. In case of loop ends, more nodes will be inside the loop.\n Always ensure that there are no multiple loop starts per node. Your pipeline will not run in such cases.\n We consider loop nodes still as experimental, as complex processing is applied while the pipeline is running to achieve loops.\n "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/data-table-row/",
	"title": "Data table row",
	"tags": [],
	"description": "Defines a data table row",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: data-table-row.schema.json\n Defines a data table row   id:  number      Row index within the data table   annotations:  object[]       Annotations attached to the data row See annotation        true-data-type:  string       The true (not the slot) data type ID behind the row      Example { \u0026#34;index\u0026#34; : 0, \u0026#34;annotations\u0026#34; : [ ], \u0026#34;true-data-type\u0026#34; : \u0026#34;imagej-imgplus-fft-2d\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/annotation/",
	"title": "Annotation",
	"tags": [],
	"description": "Defines an annotation",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: annotation.schema.json\n An annotation   name:  string       Name of the annotation   value:  string       Value of the annotation      Example { \u0026#34;name\u0026#34; : \u0026#34;#Dataset\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Experiment 1\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "https://www.jipipe.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.jipipe.org/",
	"title": "JIPipe",
	"tags": [],
	"description": "",
	"content": "Macro programming for everyone! \rJIPipe is a visual programming language for ImageJ that\rallows you to create macros without any programming  by just creating a flowchart!\r\r Download now \r Learn how to use it \r Show examples \r\r\r --\r\rIntuitive user interface\rJIPipe comes with a modern and easy to use interface that is simple by default, but powerful when needed.\rAll options are logically organized and located where you expect them to be.\r\r\r\rEasy to learn\rJIPipe comes with helpful tools such as the Algorithm finder that guides you in creating a pipeline by offering compatible processing steps for your current data.\r\r \rEasy to organize \u0026amp; document\rJIPipe allows you to organize your pipelines into compartments and node groups to help you to keep track of your analysis. Furthermore, you can document your pipeline by adding\rlabels, names, and custom descriptions to inputs, outputs, and nodes.\r\r\r\rBuilt on ImageJ\rJIPipe is built on the established ImageJ software and comes with commonly used ImageJ functions and plugins, just as CLIJ2 and MorphoLibJ.\rYou can re-use your existing macros and ImageJ2 scripts and create easy-to-use graphical interfaces for them, which will also be available directly within ImageJ via JIPipe's two-way integration.\r\r\r\rEasy sharing \u0026amp; extending\rJIPipe allows you to export your pipelines as custom nodes that can be installed just like any other ImageJ plugin. Programmers can make use of the powerful API to enhance the feature set even more.\r\r\r\rPowerful result evaluation\rYou can either analyze results directly after processing or load existing results\rdirectly into JIPipe. The powerful result analysis tool lets you import data back\rinto ImageJ, or summarize and plot them directly within JIPipe.\r\r\r\rIntegrated table editor\rJIPipe comes with a tool to summarize and concatenate tables without\rany external tools. The tool can directly import table data generated\rby ImageJ.\r\r\r\rIntegrated plot editor\rJIPipe comes with a powerful plot builder that supports a multitude of different plot types,\rsuch as XY plots, bar charts, histograms, and box plots.\r\r\r\r\rDo you want to try it?\r\rYou can try JIPipe right now in three simple steps!\r\r\rDownload ImageJ or open your existing ImageJ installation\rActivate the JIPipe update site (Help \u0026gt; Update ...)\rRun the JIPipe GUI from within the plugin menu\r\r\rAfter starting JIPipe, we recommend you to follow our tutorial or load an example pipeline.\r\r\rDo you have a question or require some help?\r\rPlease do not hesitate to contact us! You can always contact the JIPipe developers via the community, or via E-Mail.\rIf you find a bug, you can also report it directly on GitHub.\r\r\r Community \r Send E-Mail \r Report a bug \r\r\rJIPipe was developed by Research Group Applied Systems BiologyHead: Prof. Dr. Marc Thilo Figge\rHKI-Center for Systems Biology of Infection\rLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\rAdolf-Reichwein-Straße 23, 07745 Jena, Germany\r\r\r\r\r\r\r$(document).ready(function(){\r// Landing page slideshow\r$('.landing-features').slick({\rinfinite: true,\rdots: true,\rslidesToShow: 3,\rslidesToScroll: 3,\rautoplay: true,\rautoplaySpeed: 10000,\rcenterMode: true,\rcenterPadding: '5rem',\rinitialSlide: 1,\rresponsive: [\r{\rbreakpoint: 1024,\rsettings: {\rslidesToShow: 1,\rslidesToScroll: 1\r}\r}\r]\r});\r});\r\r"
},
{
	"uri": "https://www.jipipe.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]