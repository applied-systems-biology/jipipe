[
{
	"uri": "https://www.jipipe.org/faq/general/",
	"title": "General questions",
	"tags": [],
	"description": "General questions about JIPipe",
	"content": "Where do I find documentations? You can find all documentations in the  menu at the top right.\nThere are also context-based documentations available if you select a node in the graph. Hover your mouse over a parameter to show documentations for this parameter only.\nDoes JIPipe have a backup function? Yes. By default, JIPipe creates a backup every 3 minutes. You can recover it via Project \u0026gt; Restore Backup.\nCan I make the startup faster? Many JIPipe extensions rely on other ImageJ plugins to work. That is why JIPipe always checks if all necessary ImageJ plugins are available. If you are sure that you have everything installed, you can disable this check at Project \u0026gt; Application settings \u0026gt; General \u0026gt; Extensions. Disable Validate ImageJ dependencies.\nIf you do not have access to these setting (because you are offline or there are issues with the ImageJ servers), open the file jipipe.properties.json (located in your ImageJ directory) in a text editor search for a line \u0026quot;extensions/validate-imagej-dependencies\u0026quot; : true and replace true by false.\nIf the file is not present, create a new file and put following text into it:\n{\r\u0026quot;extensions/validate-imagej-dependencies\u0026quot; : false\r}\rJIPipe will automatically add the other settings on the first startup.\nCan I expose a set of specific parameters for collaborators? Yes. You can do this via the Project \u0026gt; Project settings \u0026gt; Parameters. They will be available in Project \u0026gt; Project overview, alongside the description that can be set in Project \u0026gt; Project settings \u0026gt; General.\nCan I add my author information to a project? Yes. Go to Project \u0026gt; Project settings \u0026gt; General. Here you can add multiple authors (including affiliation), provide a citation, license, and website, as well as cite other projects.\nWhere should I place files if I want to make the project portable? JIPipe automatically relativizes file paths if you place data files in the same folder as the project (or in a subfolder). This allows you to compress the project and share it with other without breaking anything.\nThis is the recommended way to do share your projects if you have multiple operating systems.\nHow can I copy / delete the global settings? JIPipe places a file jipipe.properties.json into your ImageJ directory. You can delete it to reset all settings to their defaults or copy it to another JIPipe instance.\n"
},
{
	"uri": "https://www.jipipe.org/_header/",
	"title": "Header",
	"tags": [],
	"description": "",
	"content": "\n"
},
{
	"uri": "https://www.jipipe.org/faq/user-interface/",
	"title": "User interface",
	"tags": [],
	"description": "Questions concerning the user interface",
	"content": "Does JIPipe have a dark mode? Yes, you can enable it in Project \u0026gt; Application settings \u0026gt; UI \u0026gt; General \u0026gt; Theme. Set the theme to Modern dark and restart JIPipe/ImageJ.\nHow can I make long connections without zooming out? Click the arrow button at the input/output slot. It lists all compatible sources/targets ordered by distance.\nWhy is the user interface suddenly messed up on Windows? This is a known issue with the open/save dialogs that are used on Windows. They cause to overwrite JIPipe\u0026rsquo;s design. We have not yet found a solution for this. We recommend to configure ImageJ to use the Java file dialogs, not the native Windows dialogs.\n"
},
{
	"uri": "https://www.jipipe.org/faq/data-processing/",
	"title": "Data processing",
	"tags": [],
	"description": "Questions about how data is processed",
	"content": "What are those compartments for? Imagine you have a large complicated pipeline. Most certainly, you could split it into multiple sub-pipelines like \u0026ldquo;preprocessing\u0026rdquo; or \u0026ldquo;segmentation\u0026rdquo;. Compartments allow you to do exactly this.\nWhat is the difference between groups and compartments? If you use compartments, JIPipe is still aware of the whole pipeline. This allows it to run all dependency nodes via Update cache or Quick run. Groups are independent pipelines that are not aware where they are used. You can only extract the final outputs, not intermediate steps.\nWhat happens if I put multiple inputs into a slot? Because each slot holds a table of data and metadata, those tables are merged row-wise.\n\rShow example\r\r\r\rWhy should I care to add those annotations? Annotations are optional for single data analyses or pipelines without multi-input nodes, but helpful anyways. They will allow you to quickly find out from which data set your data was generated.\nIf you have a multi-input node, you will need annotations, as JIPipe needs to figure out which data from which input belongs together.\nYou will find more information here.\nCan you give me an example of multi-input processing? \rShow example\r\r\rThe merge channels node has two inputs (one for each channel) and at some point needs to assign which of the input images belong together.\rThis assignment is here visualized as \"intermediate merged input table\".\rTo achieve this with multiple rows in the input tables, JIPipe utlizes the additional annotation columns (here #Dataset) to group the input rows by these columns.\r\r\r\rWhy do you create annotations with a \u0026lsquo;#'? There are two kinds of annotations: Ones that only you care about (e.g. the resolution) and the ones the JIPipe should care about. By default all JIPipe\u0026rsquo;s multi-input nodes are configured to only care about annotation columns that begin with #.\nYou can extensively configure this behavior in the node\u0026rsquo;s properties and also manually define which columns JIPipe should look at.\nWhat happens if a reference column is missing? JIPipe will assume an ANY for such columns.\n\rShow example\r\r\rIn this example, one set of images has a data set, while the other set has no such information. This is interpreted as \"any\".\r\r\r\rCan I preview what the multi-input processing will do without running the node? Yes, switch to the \u0026ldquo;Data batches\u0026rdquo; tab in the properties panel. It allows you to configure how JIPipe merges data together and previews the results.\nDo not forget to refresh after changing a setting.\nHow does JIPipe store its data during the analysis? JIPipe stores all necessary inputs and the outputs of each processing step. This means that any kind of large data set will be loaded into the memory at the same time if you set up an iteration.\nFor example, an Import image step will load all the images and then continue with the next steps.\nI have a very large data set. How can I prevent loading it at the same time? You have two options:\n Run a JIPipe project within a another Use a node group and set it to iterative mode  Nested JIPipe projects You can run JIPipe projects within other JIPipe projects. This will separate them and into individual runs that are iterated one-by-one. JIPipe comes with nodes to extract specific results from those outputs.\nCreate the analysis for only one data set and export project-wide parameters via its project settings. Those parameters will be later modified and should contain anything you need for the project setup. Save it into a *.jip project.\nThen create a separate project and add the nodes Run JIPipe project and Define JIPipe project parameters. In both nodes, you load the main analysis projects.\nIterative group nodes Group a set of nodes that contains functions with a large memory footprint. This will create a Group node. By default group nodes will just act as simple group and pass data from its slots to the wrapped graph. To reduce the memory footprint, set the Graph iteration mode to iterate/merge, which changes the behavior of the node: The code now will be repeated for each data batch, which prevents loading all data at once.\nPlease ensure that the wrapped nodes can handle this kind of iteration.\nI do not want to always put in the credentials into each OMERO node. What can I do? Go to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; OMERO and set your credentials there. Any OMERO node will supplement unset credentials by those settings.\nWhere can I find information about the formats used in JIPipe output? You will find information in the data type compendium. Concerning the standardized JIPipe output format, you will find information here\n"
},
{
	"uri": "https://www.jipipe.org/faq/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Questions about the integration into ImageJ and popular plugins like OMERO",
	"content": "Can I use plugins from ImageJ in JIPipe? Yes. Either there is an integration available, or you just use the macro node and input the corresponding macro code that runs the plugin.\nCan I use existing ImageJ macros in JIPipe? Yes, use Images \u0026gt; ImageJ macro. The input slots are opened as image windows and can be addressed from within the macro with selectWindow(). You can also load an example that shows how to use the node.\nCan I use JIPipe from within ImageJ macros? Yes. You can use both pipelines and individual JIPipe algorithms from within ImageJ macros and the GUI.\nWhy are some JIPipe algorithms not availabe from within ImageJ? JIPipe has a very general data model that makes it possible to develop pipelines for processing any kind of data. The communication between JIPipe\u0026rsquo;s data types and ImageJ is handled by adaptors that will handle the \u0026ldquo;translation\u0026rdquo; back \u0026amp; forth. For some of such data types, there is no adaptor. The reason behind this is that ImageJ might not have an equivalent data type or feature.\n"
},
{
	"uri": "https://www.jipipe.org/faq/result-analysis/",
	"title": "Result analysis",
	"tags": [],
	"description": "Questions concerning the export and further analysis of results",
	"content": "Can I open a table in ImageJ instead of JIPipe or vice versa? Yes, and even more: Depending on the data type there are multiple options on displaying data available. Select the data in the result view or cache browser and click the ... button at the bottom. JIPipe will even remember the last setting for you.\nCan I save data by their metadata? Yes, use the node Miscellaneous \u0026gt; Export data. It will export all incoming data into one or multiple folders and generates names based on metadata.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph-node/",
	"title": "Algorithm node",
	"tags": [],
	"description": "Node in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm-node.schema.json\n\rNode in a graph\r\r\rjipipe:slot-configuration:\r\robject\r\r\r[object Object]\r\r\r\r\r\rUser-defined slots. Might be ignored depending on the algorithm. The keys are the slot names.\rSee slot-definition\r\r\r\r\r\r\r\rjipipe:algorithm-ui-location:\r\robject\r\r\r[object Object]\r\r\r\r\rLocations of this node within the UI. Optional. The keys depend on the UI implementation.\rSee point\r\r\r\r\r\r\r\rjipipe:algorithm-type:\r\rstring\r\r\r\r\r\r\rAlgorithm type ID\r\r\rjipipe:algorithm-compartment:\r\rstring\r\r\rDEFAULT\r\r\r\r\r\rCompartment ID. Only important for the UI.\r\r\rname:\r\rstring\r\r\r\r\r\r\rA custom name for this algorithm. Only important for the UI. If null or empty, the UI will default to the algorithm type name.\r\r\rdescription:\r\robject\r\r\r\r\r\r\rA custom description. Only important for the UI.\r\r\r\r\r\rExample {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Folders\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Annotated folders\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Annotated folders\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;default-preprocessing\u0026#34; : {\r\u0026#34;x\u0026#34; : 525,\r\u0026#34;y\u0026#34; : 100\r},\r\u0026#34;default-preprocessing{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 250\r},\r\u0026#34;default-preprocessing{Horizontal}\u0026#34; : {\r\u0026#34;x\u0026#34; : 450,\r\u0026#34;y\u0026#34; : 50\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-annotate-by-name\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;default-preprocessing\u0026#34;,\r\u0026#34;generated-annotation\u0026#34; : \u0026#34;project-sample\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;Folders to annotations\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation/batch-pipelines/",
	"title": "Batch pipelines",
	"tags": [],
	"description": "Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.",
	"content": "JIPipe was designed to always process data in batches, meaning that algorithms always work on multiple data sets at once. This greatly reduces the required work to upscale a processing pipeline from one or few to a large amount of data sets.\nWe will use this pipeline as example:\nmermaid.initialize({startOnLoad:true});\rgraph LR;\rA[File] -- B[Load image]\rB -- C[Apply gaussian]\r In the pipeline, a file is provided as input. Then the file is loaded as image. Finally, the image is processed with a gaussian filter.\nA possible implementation of such a pipeline consists of three algorithms, one for each processing step. An algorithm consumes input and produces output. The exception is the algorithm that loads a user-defined file path into the pipeline.\nJIPipe extends on this concept by allowing input and output slots contain multiple data sets at once. And depending on the algorithm, it either processes each data set individually, or splits, merges, or transforms the list of input data.\nHandling multiple inputs There might be algorithms that require multiple inputs:\nmermaid.initialize({startOnLoad:true});\rgraph LR;\rA[Image channel 1] -- B[Merge channels]\rC[Image channel 2] -- B\r The Merge channels algorithm merges the two image channels into one image with two channels. If each data slot only contains one entry, finding image channels that belong to the same data set is trivial.\nFor list-based data slots, like in JIPipe, it is not trivial to find images that should be merged. For example, image1_C1 and image1_C2 should be merged to image1_merged:\nData annotations JIPipe solves this issue by allowing to annotate each data entry (shown as purple entries). Those annotations are in this case automatically extracted and used to group input data. There also can be algorithms that use the annotation information to for example filter or sort data.\nThere are predefined algorithms located within the Annotate menu that for example create annotations based on filenames. JIPipe supports an unlimited amount of annotations that can be attached to data.\nFollowing JIPipe pipeline provides an example of making use of annotations to allow multiple inputs:\nTutorial video We created a video that illustrates how to create a batch processing pipeline:\n\r"
},
{
	"uri": "https://www.jipipe.org/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "Sorry, the download is not available, yet.\r\rWe are currently working hard on getting the first release of JIPipe out.\nThe release will be announced in the image.sc forum.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/iterating-algorithms/",
	"title": "Handling multiple inputs",
	"tags": [],
	"description": "",
	"content": "JIPipe data slots store multiple data rows. This means that algorithms have to iterate their workload for each input row and generate equivalent output in the respective output slots.\nThere can be issues if data from multiple input slots need to be combined (e.g. merge channels into RGB, see user documentation). JIPipeAlgorithm has no capabilities to help with such cases.\nA solution can be JIPipeIteratingAlgorithm or JIPipeSimpleIteratingAlgorithm that use the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeDataBatch instances that represent one data set iteration.\nFor simple algorithms, we recommend JIPipeSimpleIteratingAlgorithm. It does not have the additional parameters that might confuse some users, but creates the same runIteration(\u0026hellip;) command as JIPipeIteratingAlgorithm. It only works for algorithms with at most one input and will generate error messages if you have more than one input.\n\rPlease access data via the data interface. It reads exactly one JIPipeData for each input.\n\rThe only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm\r@JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;)\r// Sets the algorithm category\r@JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class)\r// Input and output slots\r@AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true)\r@AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true)\rpublic class MyAlgorithm extends JIPipeIteratingAlgorithm {\r/*\rThis is the main constructor of the algorithm.\rIt contains a reference to the algorithm info that contains\rsome important metadata\r*/\rpublic MyAlgorithm(JIPipeNodeInfo info) {\rsuper(info);\r}\r/*\rA deep copy constructor. It is required.\rPlease do not forget to deep-copy all important fields\r*/\rpublic MyAlgorithm(MyAlgorithm original) {\rsuper(original);\r// Deep-copy additional fields here\r }\r/*\rThe workload is run in this functon.\rYou can also have the ability to inform the user about the current algorithm status\rfor more complex algorithms.\rYou can also query if the user requested cancellation\rPlease read and write only via the data interface.\r*/\r@Override\rpublic runIteration(JIPipeDataBatch dataBatch, JIPipeProgressInfo progress) {\r// Run your workload here\r }\r}\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/analysis/",
	"title": "Image analysis pipeline",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": "\rThis tutorial is also available as video.\r\r\r1. First start\rOn starting JIPipe, you will see such a screen: It contains a short introduction, the graph compartment editor,\ran three pre-defined graph compartments Preprocessing, Analysis, and Postprocessing. As described in the graph compartment documentation, you\rcan ignore graph graph compartments. But in this tutorial we will make use of its capabilities to clearly separate the pipeline into the mentioned tree steps.\r\r\r\r2. Graph compartments\rHere you can see how the data flows between graph compartments. You do not have to do anything here, as this is the default configuration.\rData flows from Preprocessing to Analysis, and finally to Postprocessing.\r\rYou can ignore the graph compartments and of course define your own data flow. Graph compartments are very flexible. Just take a look at the documentation.\r\r\r\r3. Preprocessing\rIn this tutorial, the preprocessing step should consist of algorithms that load and organize data for the following processes.\rTo switch to the graph editor for the preprocessing step, just click the Preprocessing tab.\rYou will find an empty graph aside of the Preprocessing output node. We will utilize this node in\ra later step to pass preprocessed data to other steps.\r\rThe graph is stored project-wide. You can just close all graph editors that you do not need for the current task.\rYou can re-open them via the graph compartment editor. If you closed it, you can re-open it via the Compartment menu in the project menu bar.\r\r\r\r4. Adding a data source\rThe most common way how data is provided is to load them from files or folders. JIPipe comes preinstalled with data-types and algorithms\rthat handle filesystem operations. The tutorial data is supplied as set of folders\rthat contain the input images as TIFF files in a sub-directory.We begin by adding a data source that supplies a list of folders.\rYou can find it in Add data \u0026gt; Folder \u0026gt; Folder list. After selecting the item, it will appear in the graph.\r\rYou can also drag folders and/or files directly into the graph editor area. Corresponding file data source nodes are then created.\rFor this example, you could just drag the input data folders directly into the graph.\r\r\rYou do not have to navigate via the menu. You can also type the algorithm name or some keywords into the bar that reads Search ....\r\r\r\r5. Including the input folders\rSelect the newly created algorithm node by clicking it. The panel on the right-hand side will update and allow you to change\rthe parameters of the selected algorithm node. Click the  Add button and select the\rinput folders.\r\rYou can save the current project at any time and re-load it later. If you save it in a parent directory relative to where your data is located,\rJIPipe automatically saves all paths relative to the project file. This means you can just move all your data, including the project to other machines or\rhard drive partitions without breaking anything.\r\r\r\r6. Annotating data\rJIPipe is designed as batch processing tool, meaning that it can be always scaled from small test data up to large data sets.\rIt can be helpful for you and some algorithms to know which data belongs together. JIPipe introduces the concept of data annotations that\rassign data to an unique data set and are passed through the pipeline. You can find more about this in the documentation about how JIPipe processes data.\rIn this step we add the data annotation directly at the beginning by attaching the input folder name to each folder that was passed into the pipeline.\rThis is done via the Annotations \u0026gt; Generate \u0026gt; Path to annotation algorithm. Just add this algorithm into the graph.\rFor more advanced projects there are plenty of other sources for annotations, like importing them from tables, or extracting and modifying annotations.\r\r\r7. Connecting slots\rThe input folders are converted into a format understandable by JIPipe by the Folder list algorithm. The output then can be passed to following algorithms\rlike the Folders to annotations algorithm we added in the last step.\rTo make a connection click the  or  button and select the available data slot.\rYou can see that a connection between the two data slots was created.\rThis list is always sorted from the closest to the farthest away slot.\r\rYou can also use your mouse to drag a connection between slots.\r\r\r\r8. Annotation type\rAnnotations are like columns in a table - only that our table contains complex data types. The Path to annotation algorithm automatically extracts\rthe path's file name (or directory name) and annotates it to the input row. By default, the algorithm creates a column Dataset. If you want you can\rchange it to another meaningful column name. And with more complex projects you will probably have many different columns.\r\r\r9. Extracting the image file\rWe have now the folders and can extract the input image file from each one of them.\rYou can find an algorithm designed for such purposed in File system \u0026gt; List \u0026gt; List files. Add it to the graph and connect it to the Subfolder name output.\rThis algorithm is not only able to list files, but also filter them directly.\rIn this case, we exactly know that our files are located within a sub-folder in. Please update the Subfolder parameter by setting it to in.\rThe filter uses an expression that allows highly flexible filters. But for this example, we only want to test if the filename contains .tif.\rTo do this, type name CONTAINS \".tif\" into the filter box.\r\rIf you have more complicate folder structures, you can apply the \"Navigate to sub-folder\" operation with a distinct algorithm. You can find it in the Filesytem category.\r\r\rWe highly recommend that you get familiar with expressions, as they are present in most filtering or generation nodes. They are easy to learn and write, but also allow extremely powerful operations.\r\r\r\r10. Testing if the pipeline is correct (Optional)\rThe Quick Run feature allows you to run the pipeline until the selected algorithm and compare multiple parameter sets.\rIt is a good way to test if the pipeline works so far. To create a quick run right-click the List files node and select  Run \u0026amp; show results.\r\rThe quick run will check if the pipeline is valid might show some error. If you think that the pipeline is valid, click  Retry\rto check the pipeline again. It sometimes does not update for performance reasons.\r\r\rYou can also do a quick-run that just refreshes the Cache.\r\r\rYou can also start a Quick Run from the parameter panel if you select the algorithm.\r\r\r\r11. Testing if the pipeline is correct - results (Optional)\rNavigate to the output if the List files algorithm and check if the file paths are correct.\rSee our Quick Run documentation for more information about the testbench and its features.\r\r\r12. Importing the images\rAfter correctly setting up the files, you can import them as images. You can find various importers for\rimage types in Add data.\rOur images do not require Bio-Formats, so we choose Add data \u0026gt; Image \u0026gt;Import image. Connect it to the output of List files.\r\rThe Import image node does not ensure the exact bit depth and dimensionality of the output image. You can change this via a parameter that allows you\rto choose the exact image type.\r\r\r\r13. Preprocessing output\rYou could continue with the analysis directly from the Import image node. But to showcase the graph compartments feature, we decide to\rhave the imported greyscale image as output for of the Preprocessing compartment. The output of a graph compartment is only interfaced through a special node,\rin this case Preprocessing output.We first have to define an output slot by clicking the  button. Select Import image,\rset a name, and click  Add.\r\r\r14. Connecting the output\rFinally, connect the output of Import image to the new input slot of Preprocessing output.\r\r\r15. The analysis\rNow we are finished with the preprocessing. Switch to the Analysis graph compartment by selecting the tab in the tab bar.\rYou see that it also contains a node called Preprocessing output. This is the same node as in the preprocessing compartment, but\rit only contains output data this time.\rWe continue the analysis with a Gaussian filter that can be found in Images \u0026gt; Blur \u0026gt; Gaussian blur 2D.\rAdd it to the graph and connect it to the output of Preprocessing output.\r\r\r16. Finding the particles\rAdd following algorithms to the graph and connect them the the previous output:\r\rImages \u0026gt; Threshold \u0026gt; Auto Threshold 2D\rImages \u0026gt; Binary \u0026gt; Distance transform watershed 2D\rImages \u0026gt; Analyze \u0026gt; Find particles 2D\r\r\rThis will create a more or less accurate segmentation of the objects (spores) that are visible in the data.\rThe generated masks are then analyzed to extract ROI and measurements.\r\r\r17. Analysis output\rCreate multiple analysis output slots via the  button. Export at least the measurements table.\rIn our example, we exported the mask, ROI, and the measurements.\r\rYou can hide edges if you want. Just click the  or  and select Hide edge.\r\r\r\r18. Postprocessing\rThe postprocessing consists of generating a histogram plot of the spore particle areas.\rYou can find a node that generates plots in Tables \u0026gt; Plot \u0026gt; Plot tables.\rConnect the measurements to the plotting node and set its plot type to  Histogram plot.\rYou see that the node parameters change. They adapt to the the currently selected plot and expect from you to input from which table column(s)\rto extract the data from. Either you know the name of the columns, or you can use the testbench to generate output and check it yourself. Some algorithms\ralso write the names of their output columns in their description.\rThe correct column for the measurements is Area.\rYou can also change various plot-specific settings and determine how output images are generated.\r\rThe plot node automatically generates SVG and PNG renders in the selected resolution. This is not a definite choice, as JIPipe has its own plot builder that\rcan import generated plots from within the results UI.\r\r\rAside from exact matching, plot input columns can be matched via a regular expression\ror generated. Use the generator by selecting . A generator can be useful if you have no matching column within your data.\r\r\r\r19. Running the pipeline\rTo run the pipeline, click the  Run button at the top right corner. This will open a new tab where you can select the output directory.\rYou can also generate a random folder that will be located on your operating system's temporary directory\rby clicking the button.\rAfter setting up the parameters, click  Run now.\r\rJIPipe attempts to prevent the most common errors (such as wrong parameters) and displays a message if something was found. Please follow the instructions of those messages.\rDepending on the data and algorithms, the behavior might not be forseeable and a crash occurs during the processing. A similar easy-to-understand message is shown on how\rto proceed or repair the issue.\r\r\r\r20. Displaying results\rAfter the pipeline was successfully executed, a result analysis interface is shown. It displays the\rresults of all output slots. You can navigate through the results via the tree on the left-hand side.\rOn selecting a row, an interface is displayed below the table that contains various operations to import or open the data.\r\r\r21. Displaying plots\rTo open the generated plots, navigate to Results \u0026gt; Postprocessing \u0026gt; Plot tables \u0026gt; Output and double-click an entry in the list.\rAlternatively, you can also select the row and click Open in JIPipe. This will open a new tab with a plot builder tool.\rPlease take a look at the plots and tables documentation for more information how the tool works.\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/javadocs/",
	"title": "JavaDocs",
	"tags": [],
	"description": "Provides a link to the JavaDocs",
	"content": "The JavaDocs of the Java API can also be found here\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/python/api/",
	"title": "Python API",
	"tags": [],
	"description": "Documentation of the Python API to communciate with JIPipe.",
	"content": "\njipipe \njipipe.data_slot This file provides functions that are used to manage the contents of a data slot\nZoltán Cseresnyés, Ruman Gerst\nResearch Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge https://www.leibniz-hki.de/en/applied-systems-biology.html HKI-Center for Systems Biology of Infection Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Institute (HKI) Adolf-Reichwein-Straße 23, 07745 Jena, Germany\nThe project code is licensed under BSD 2-Clause. See the LICENSE file provided with the code for the full license.\n\nDataSlot Objects class DataSlot()\rModels a JIPipe data slot.\n\n__init__ | __init__(data_type: str, storage_path: Path, node_id=\u0026#34;\u0026#34;, internal_path: Path = \u0026#34;\u0026#34;, name: str = \u0026#34;\u0026#34;, slot_type: str = \u0026#34;\u0026#34;)\rInitializes a new data slot\nArguments:\n data_type: the JIPipe data type ID that is accepted in this slot. The most basic type is \u0026lsquo;jipipe:data\u0026rsquo; slot_type: the type of the slot. Allowed values are \u0026lsquo;input\u0026rsquo; and \u0026lsquo;output\u0026rsquo;. Can be empty. storage_path: a directory where the slot data is stored. If it does not exist, one will be created node_id: Metadata that indicates the node associated to this slot. Can be empty. internal_path: Metadata that indicates the placement of this data within a hierarchy of data. Can be empty. name: Name of the slot. Can be empty.  \nget_row_storage_path | get_row_storage_path(row: int)\rReturns the storage path for the provided row\nArguments:\n row: the row index  Returns:\nthe storage path for the row\n\ncopy_row | copy_row(source_data_slot, source_row: int)\rCopies data from the source slot into this slot\nArguments:\n source_data_slot: the source slot source_row: the source row  \nadd_row | add_row(n: int = 1, annotations: dict = None, true_data_type: str = None)\rAdds n rows into the slot\nArguments:\n true_data_type: the true data type ID of this entry. If none, the slot data type is used annotations: annotations to set for these rows n: how many rows to add  Returns:\nthe last row index\n\nto_table | to_table()\rConverts the data slot into a Pandas table.The format is equivalent to data-table.csv generated by JIPipe.\nReturns:\nPandas table\n\nto_dict | to_dict()\rConverts the data slot into a dict that can be serialized into JSON\nReturns:\na dictionary that describes this slot\n\nsave | save(with_csv=False)\rSaves all metadata related to this slot in the storage folder. This will overwrite data-table.json and data-table.csv (if enabled)\nArguments:\n with_csv: Also write the table as CSV. The format is equivalent to the one generated by JIPipe. Writing with CSV requires pandas to be installed.  Returns:\nNone\n\nimport_from_folder import_from_folder(storage_path: Path)\rImports a data slot from a storage path. A valid storage path contains \u0026lsquo;data-table.json\u0026rsquo; and multiple numeric folders.\nArguments:\n storage_path: the storage path  Returns:\na DataSlot instance\n\njipipe.imagej This file provides functions to read/write ImageJ data types\nZoltán Cseresnyés, Ruman Gerst\nResearch Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge https://www.leibniz-hki.de/en/applied-systems-biology.html HKI-Center for Systems Biology of Infection Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Institute (HKI) Adolf-Reichwein-Straße 23, 07745 Jena, Germany\nThe project code is licensed under BSD 2-Clause. See the LICENSE file provided with the code for the full license.\n\nget_image_file get_image_file(data_slot: DataSlot, row: int)\rFinds the image file located in imagej-imgplus-* data slot rows\nArguments:\n data_slot: the data slot row: the row  Returns:\npath to the image file or None if not found\n\nget_table_file get_table_file(data_slot: DataSlot, row: int)\rFinds the CSV table file located in imagej-results-table (and related) data slow rows\nArguments:\n data_slot: the data slot row: the row  Returns:\npath to the CSV file or None if not found\n\nload_image_file load_image_file(data_slot: DataSlot, row: int)\rFinds and loads the image file located in imagej-imgplus-* data slot rows and loads it with Skimage. Requires that Skimage is installed.\nArguments:\n data_slot: the data slot row: the row  Returns:\nImage data or None if no image was found\n\nload_table_file load_table_file(data_slot: DataSlot, row: int)\rFinds and loads the CSV table file in imagej-results-table (and related) data slow rows as pandas data frame Requires that pandas is installed.\nArguments:\n data_slot: the data slot row: the row  Returns:\nImage data or None if no image was found\n\nadd_table add_table(table, data_slot: DataSlot, annotations: dict = None)\rAdds a new table into a new row of the specified slot\nArguments:\n table: the table. must be a Pandas table or dictionary that can be converted into a data frame data_slot: the data slot annotations: optional annotations (a dict of string keys and string values)  Returns:\nindex of the newly added row\n\nadd_image add_image(image, data_slot: DataSlot, annotations: dict = None)\rAdds a new image into a new row of the specified slot. The image will be saved as TIFF. Requires Skimage.\nArguments:\n image: an image. must be a numpy array data_slot: the data slot annotations: optional annotations (a dict of string keys and string values)  Returns:\nindex of the newly added row\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/result-ui/",
	"title": "Result view",
	"tags": [],
	"description": "",
	"content": "After processing, users should be able to continue processing the data from within JIPipe. The data instances are cleared from memory after processing, meaning that the data needs to be loaded from its output folder after processing.\nAn user interface is shown when a user select a row in the results table. There are two ways to modify the user interface:\n Registering additional operations that will be available to users (recommended) Replacing the interface with a custom one  Adding custom operations JIPipe already comes with some default operations, such as opening the containing folder. Any other operation must be added manually to each data type.\nThere are two types of operations: one for importing data written into a results folder, and one for displaying already loaded data from memory. The corresponding interfaces are JIPipeDataImportOperation and JIPipeDataDisplayOperation.\nYou can implement one or both interfaces as shown here:\npublic class MyOperation implements JIPipeDataImportOperation, JIPipeDataDisplayOperation {\r@Override\rpublic void display(JIPipeData data, String displayName, JIPipeWorkbench workbench) {\r// Here you can pu a custom display function\r // Currently it just uses the default function\r data.display(displayName, workbench);\r}\r@Override\rpublic String getName() {\r// Name as shown in the menu\r // The name should be unique\r return \u0026#34;Open in JIPipe\u0026#34;;\r}\r@Override\rpublic String getDescription() {\rreturn \u0026#34;Opens the table in JIPipe\u0026#34;;\r}\r@Override\rpublic int getOrder() {\r// The lower the order the higher it is placed in the menu\r // The lowest ist used as default\r return 100;\r}\r@Override\rpublic Icon getIcon() {\rreturn UIUtils.getIconFromResources(\u0026#34;apps/jipipe.png\u0026#34;);\r}\r@Override\rpublic JIPipeData show(JIPipeDataSlot slot, JIPipeExportedDataTable.Row row, Path rowStorageFolder, String compartmentName, String algorithmName, String displayName, JIPipeWorkbench workbench) {\r// This function should import the data contained in the rowStorageFolder and display it\r // You can return the data (which is currently not used) or return null\r if (rowStorageFolder == null || !Files.isDirectory(rowStorageFolder))\rreturn null;\rPath csvFile = PathUtils.findFileByExtensionIn(rowStorageFolder, \u0026#34;.csv\u0026#34;);\rif (csvFile != null) {\rResultsTableData result = JIPipeTableEditor.importTableFromCSV(csvFile, (JIPipeProjectWorkbench) workbench);\rworkbench.getDocumentTabPane().switchToLastTab();\rreturn result;\r}\rreturn null;\r}\r}\rThe operations must be registered in JIPipeJavaExtension either via the data type ID or when registering a new data type.\nCurrently you have to register all your operations per data type. It its not enough to register them for the base class only.\n\r@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r// ... See previous tutorial for other methods\r @Override\rpublic void register() {\r// Registering the operation when registering the data type\r registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null, new MyOperation());\r// alternative ...\r\r// Registering the operation by itself\r registerDatatypeOperation(\u0026#34;my-data\u0026#34;, new MyOperation());\r}\r}\r\rYou can register an operation for all data types by leaving the data type ID empty.\n\rUsing a custom interface This UI can be replaced with a custom one that is designed to handle this specific data type.\nSuch UIs inherit from JIPipeResultDataSlotRowUI, which is a panel that has access to\n the data location the annotation of this data row the project workbench UI  We recommend to inherit from JIPipeDefaultResultDataSlotRowUI that allows to inherit actions from inherited data types.\nJIPipeDefaultResultDataSlotRowUI requires you to register actions with a name, description and function. The action that was added last is shown in the main UI and triggered by double-clicking the data row in the table. All other actions are put into the ... menu.\npublic class MyDataDataSlotRowUI extends JIPipeDefaultResultDataSlotRowUI {\rpublic MyDataDataSlotRowUI(JIPipeProjectWorkbench workbenchUI, JIPipeDataSlot slot, JIPipeExportedDataTable.Row row) {\rsuper(workbenchUI, slot, row);\r}\r// This method is required because we need to find the JSON file\r // we can load MyData from it\r private Path findJsonFile() {\rif (getRowStorageFolder() != null \u0026amp;\u0026amp; Files.isDirectory(getRowStorageFolder())) {\rreturn PathUtils.findFileByExtensionIn(getRowStorageFolder(), \u0026#34;.json\u0026#34;);\r}\rreturn null;\r}\r@Override\rprotected void registerActions() {\rsuper.registerActions();\rPath jsonFile = findJsonFile();\rif (imageFile != null) {\rregisterAction(\u0026#34;Show value\u0026#34;, \u0026#34;Shows the value as message box\u0026#34;,\rUIUtils.getIconFromResources(\u0026#34;open.png\u0026#34;), e -\u0026gt; {\rMyData data = MyData.fromJson(jsonFile);\rJOptionPane.showMessageDialog(this, data.value, \u0026#34;The value is ...\u0026#34;)\r});\r}\r}\r}\rThe UI class can be directly registered in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r// ... See previous tutorial for other methods\r @Override\rpublic void register() {\r// The last null parameter will be handled in the next tutorial\r registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, null);\r}\r}\r"
},
{
	"uri": "https://www.jipipe.org/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "To get started, you can take a look at some example pipelines and other kind of examples:\n\rSegmenting spores\rThis example applies auto-thresholding to segment spores from microscopy images.\rIt makes use of the particle analyzer to extract ROI and measurements and shows how to create an area histogram plot.\rThere are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.\rThis example is based on one of the tutorials.\r\r Download (Offline)\r Download (Online)\r Tutorial\r\r\r\rSegmenting glomeruli\rThis example applies auto-thresholding and morphological operations to segment glomeruli in 2D slices of whole murine kidney light sheet microscopy images. This algorithm is part\rof a 3D segmentation published by Klingberg et al. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.\r\r Download (Offline)\r Download (Online)\r Publication\r\r\r\rSegmenting worms\rThis example segments worms. This algorithm is part\rof a 3D segmentation published by Klingberg et al. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.\r\r Download (Offline)\r Download (Online)\r Publication\r\r\r\rStack hypermontage\rA useful node that creates a montage of each incoming image stack and creates a montage of the montages. It is very useful when trying out different parameters for 3D analyses.\rJust copy the node from this website and paste it into your JIPipe pipeline.\r\r Copy\r Download example pipeline\r\r\r\r\r$(document).ready(function(){\r// Landing page slideshow\r$('.examples').slick({\rinfinite: true,\rdots: true,\rslidesToShow: 3,\rslidesToScroll: 3,\rautoplay: true,\rautoplaySpeed: 10000,\rcenterMode: true,\rcenterPadding: '5rem',\rinitialSlide: 1,\rresponsive: [\r{\rbreakpoint: 1024,\rsettings: {\rslidesToShow: 1,\rslidesToScroll: 1\r}\r}\r]\r});\r});\rfunction copyTextToClipboard(text, onsuccess) {\rif (!navigator.clipboard) {\rfallbackCopyTextToClipboard(text);\rreturn;\r}\rnavigator.permissions.query({name:'geolocation'}).then(function(result) {\rif (result.state == \"granted\" || result.state == \"prompt\") {\rnavigator.clipboard.writeText(text).then(function() {\ralert(onsuccess);\r}, function(err) {\rconsole.error('Async: Could not copy text: ', err);\r});\r}\relse {\ralert(\"Unable to copy to clipboard! You might be using an older browser that does not support this.\");\r}\r});\r}\rfunction copyMontageExample() {\rvar url = window.location.origin + '/examples/example-montage.json';\rfetch(url)\r.then(function(response) {\rresponse.text().then(text = copyTextToClipboard(text, \"Copied the node to clipboard! Paste it into an existing JIPipe project.\"));\r});\r}\r\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/analysis_video/",
	"title": "Image analysis pipeline (Video)",
	"tags": [],
	"description": "This step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": "\rThis tutorial is also available as text tutorial.\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/merging-algorithms/",
	"title": "Merging input data",
	"tags": [],
	"description": "",
	"content": "You might need to develop an algorithm that does not simply iterate through its input(s), but organize it into groups to be merged. JIPipe comes with JIPipeMergingAlgorithm that uses the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeMergingDataBatch instances that represent multiple data rows merged into one group.\nPlease access data via the data interface.\n\rThe only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm\r@JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;)\r// Sets the algorithm category\r@JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class)\r// Input and output slots\r@AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true)\r@AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true)\rpublic class MyAlgorithm extends JIPipeMergingAlgorithm {\r/*\rThis is the main constructor of the algorithm.\rIt contains a reference to the algorithm info that contains\rsome important metadata\r*/\rpublic MyAlgorithm(JIPipeNodeInfo info) {\rsuper(info);\r}\r/*\rA deep copy constructor. It is required.\rPlease do not forget to deep-copy all important fields\r*/\rpublic MyAlgorithm(MyAlgorithm original) {\rsuper(original);\r// Deep-copy additional fields here\r }\r/*\rThe workload is run in this functon.\rYou can also have the ability to inform the user about the current algorithm status\rfor more complex algorithms.\rYou can also query if the user requested cancellation\rPlease read and write only via the data interface.\r*/\r@Override\rpublic runIteration(JIPipeMergingDataBatch dataBatch, JIPipeProgressInfo progress) {\r// Run your workload here\r }\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/algorithm/",
	"title": "Algorithm type",
	"tags": [],
	"description": "Defines a new algorithm",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm.schema.json\n\rDefines a new node type\r\r\rid:\r\rstring\r\r\r\r\r\r\rUnique algorithm ID\r\r\rmetadata:\r\rSee metadata\r\r\r\r\r\r\r\rGeneral algorithm metadata\r\r\rcategory:\r\rstring\r\r\rorg.hkijena.jipipe:miscellaneous\r\r\r\r\r\rThe category\r\r\rexported-parameters:\r\robject\r\r\r[object Object]\r\r\r\r\rList of parameters that will be exported to users of the node\r\r\rgraph:\r\rSee graph\r\r\r\r\r\r\r\rThis graph is executed when the algorithm is run\r\r\rmenu-path:\r\rstring\r\r\r\r\r\r\rOptional menu path within the category menu\r\r\rjipipe:project-type:\r\rstring\r\r, x ∈ {\rgraph-wrapper-algorithm\r\r(default)\r}\r\r\r\r\r\r\rIdentifies the JSON as algorithm\r\r\r\r\r\rExample {\r\u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;,\r\u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;,\r\u0026#34;website\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;,\r\u0026#34;parameter-visibilities\u0026#34; : {\r\u0026#34;visible-keys\u0026#34; : [ ]\r},\r\u0026#34;graph\u0026#34; : {\r\u0026#34;nodes\u0026#34; : {\r\u0026#34;default-preprocessing-filter-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Filtered files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 250\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;filters\u0026#34; : [ {\r\u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;,\r\u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34;\r} ],\r\u0026#34;jipipe:trait-generation\u0026#34; : {\r\u0026#34;modification\u0026#34; : {\r\u0026#34;per-slot\u0026#34; : { },\r\u0026#34;global\u0026#34; : { }\r},\r\u0026#34;transfer\u0026#34; : {\r\u0026#34;transfers\u0026#34; : [ ],\r\u0026#34;transfer-all-to-all\u0026#34; : true\r}\r},\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r},\r\u0026#34;default-preprocessing-list-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Folders\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 50\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;jipipe:trait-generation\u0026#34; : {\r\u0026#34;modification\u0026#34; : {\r\u0026#34;per-slot\u0026#34; : { },\r\u0026#34;global\u0026#34; : { }\r},\r\u0026#34;transfer\u0026#34; : {\r\u0026#34;transfers\u0026#34; : [ ],\r\u0026#34;transfer-all-to-all\u0026#34; : true\r}\r},\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r}\r},\r\u0026#34;edges\u0026#34; : [ {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;\r} ]\r},\r\u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;,\r\u0026#34;preferred-traits\u0026#34; : [ ],\r\u0026#34;unwanted-traits\u0026#34; : [ ],\r\u0026#34;added-traits\u0026#34; : [ ],\r\u0026#34;removed-traits\u0026#34; : [ ]\r}\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/extension/",
	"title": "Creating an extension",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.",
	"content": "\r1. Existing pipeline\rIn this tutorial, we will create a custom algorithm extension based on parts of the pipeline created in the other tutorial.\rPlease open the project file for the pipeline and navigate to the Preprocessing tab.\r\r\r\r2. Selecting the algorithms\rPlease select the following algorithms (you can either do this by holding the Shift keyboard button and clicking the nodes or dragging a selection around the nodes):\r\rFolder list\rPath to annotation\rList files\rImport image\r\rAfter selecting the algorithms, right-click a selected node and click Export.\r\rSelecting one or multiple algorithms is only one way to create a custom algorithm. You can also export a whole project compartment (via the Compartments tab) or\rthe whole pipeline (via Project \u0026gt; Export as custom algorithm)\r\r\r\r\r3. Preview\rThis will open a new tab where you can see a preview of the pipeline that will be exported.\rYou see that the connections between the selected algorithms were kept, while two additional nodes were added:\r\rGroup input\rGroup output\r\rThose two nodes respectively act as input and output of the whole exported algorithm. Its input and output slots will be accessible to users of your custom algorithm.\rJIPipe automatically creates matching input and output slots based on the selected algorithms, but you can choose to modify your pipeline in this step.\rNow click Export to extension and then New extension.\r\rYou can always modify custom algorithms within the extension builder. This will be shown in a later step.\r\r\r\r\r4. Extension builder\rThis will open the JIPipe extension builder tool that allows you to package one or multiple custom algorithms into an extension. Such extensions can be just put\rinto the ImageJ plugin directory and will be automatically picked up by JIPipe just like any ImageJ plugin.\rAn extension has a set of metadata that you need to set up. To do this, switch to Extension settings.\r\rYou can always find the extension builder in Plugins \u0026gt; New JSON extension ...\r\r\r\r\r5. Extension metadata\rJIPipe utilizes a unique extension ID to identify an extension. This is the most important setting and should be chosen carefully. The format must follow a specific structure: [Author]:[Extension], where [Author] provides information about the extension author, and [Extension] contains some identifier. We recommend to let the [Author] information follow the Maven naming conventions.\rAll the other metadata can be freely chosen or left out (with the exception of the name). Use the other metadata to add authors (including affiliations), a website, define a license, and cite\rwork your pipeline is depending on.\rFinally, you can review or modify the extension contents by going to Extension contents.\r\rAny dependency to other JIPipe extensions are automatically stored within any project or extension file. JIPipe uses this information to figure out a valid load order.\r\r\r\r\r6. Extension content\rOur custom algorithm is already included in the list of extension contents (left-hand side). You only need to provide metadata. The most important setting is the unique algorithm ID that is\rused by JIPipe to identify your algorithm. Please choose a meaningful string that avoids having duplicate identifiers. Then you can provide a name, category, icon and menu location.\r\rThe extension builder will warn you if an algorithm ID already exists (we will show this function later). You can choose to ignore this if a duplicate ID is intentional - this will\roverride an algorithm and replace it by the new one.\r\r\rAlgorithm IDs are not namespaced, meaning that they are independent of the extension ID.\r\r\r\r\r7. Parameters\rBy default, your algorithm does not come with parameters aside of the few default parameters (name, description, pass-through, enable). For your pipelines it can be useful to\rlet users change some parameters. The Exported parameters section gives you full control on which parameters can be changed and how they are organized.\rFirst, you need to create a group by clicking the  Add group button. This will create a new section in the final parameter UI. Then you can\rreference parameters by clicking  Add parameter. You can customize the name and descriptions of any item.\r\rIt is always a good idea to check the parameters or maybe apply some corrections to the algorithm. To do this, click  Edit graph\r\rYou can just add all parameters of a specific algorithm by clicking Auto add algorithm. Just check if users can properly decipher the function of each parameter.\r\r\rHover over the blue  wrench icon to display information about the referenced parameter.\r\r\rEach parameter can only be referenced once. You will get a warning if you have duplicate references.\r\r\r\r\r8. Modifying the algorithm\rThe extension builder contains a fully function algorithm graph editor (aside of anything that runs the graph) that allows you to modify an algorithm or create\rone from scratch. Use the editor to check the parameters of your algorithm. For example, it is a good idea to remove the folders from the Folder list algorithm.\r\r\r\r9. Validation and installation\rClick the  Validate button on the top right corner to check for any issues. This tool will also detect duplicate extension and algorithm IDs.\rErrors about duplicates can be ignored if they are intentional.\r\rFinally, you can install the extension by clicking  Install. This will open a dialog to save the extension into the ImageJ plugin directory and\rattempt to load the extension.\r\rWe still recommend to restart ImageJ, especially if you are installing duplicate IDs.\r\r\r\r\r10. Using the algorithm\rYou can find your algorithm in the menu, navigation bar, and algorithm finder just like any other algorithm. You can see that the parameters are included according to the settings within\rthe extension builder.\r\rJSON Algorithms can be always converted into  Group nodes that unlink the underlying pipeline from the JSON algorithm definition\rand allows users to modify them. Just select  Convert to group to apply such conversions.\r\r\r Group nodes are related to JSON algorithms. If you export a single group node, its contents are exported into an algorithm instead of\rthe node itself.\r\r\r\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/create-extension/",
	"title": "Creating an extension project",
	"tags": [],
	"description": "Explains how to setup a SciJava plugin project to extend JIPipe",
	"content": "Prerequisities  Java 8 (Java 9+ are not working)  If you are using Windows or a Linux distribution without Java 8, we recommend AdoptOpenJDK (Please choose OpenJDK 8)   Maven  Creating the project The project should have following structure:\nProject root\r└── pom.xml\r└── src\r└── main\r├── java\r└── resources\rBoth the java and resources folder should contain a folder structure that is equivalent the groupId and artifactId of the project. This is done to prevent conflicts with other plugins.\nJIPipe is based on SciJava and requires libraries provided by the SciJava Maven repository.\nHere is an example *.pom file that makes use of SciJava:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;project xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/version\u0026gt;\r\u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt;\r\u0026lt;description\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/description\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;inceptionYear\u0026gt;2020\u0026lt;/inceptionYear\u0026gt;\r\u0026lt;organization\u0026gt;\r\u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;/organization\u0026gt;\r\u0026lt;licenses\u0026gt;\r\u0026lt;license\u0026gt;\r\u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;distribution\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/distribution\u0026gt;\r\u0026lt;/license\u0026gt;\r\u0026lt;/licenses\u0026gt;\r\u0026lt;developers\u0026gt;\r\u0026lt;developer\u0026gt;\r\u0026lt;id\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/id\u0026gt;\r\u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;/developer\u0026gt;\r\u0026lt;/developers\u0026gt;\r\u0026lt;contributors\u0026gt;\r\u0026lt;contributor\u0026gt;\r\u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt;\r\u0026lt;/contributor\u0026gt;\r\u0026lt;/contributors\u0026gt;\r\u0026lt;mailingLists\u0026gt;\r\u0026lt;mailingList\u0026gt;\r\u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt;\r\u0026lt;archive\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/archive\u0026gt;\r\u0026lt;/mailingList\u0026gt;\r\u0026lt;/mailingLists\u0026gt;\r\u0026lt;scm\u0026gt;\r\u0026lt;connection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/connection\u0026gt;\r\u0026lt;developerConnection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/developerConnection\u0026gt;\r\u0026lt;tag\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/tag\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;/scm\u0026gt;\r\u0026lt;issueManagement\u0026gt;\r\u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;/issueManagement\u0026gt;\r\u0026lt;ciManagement\u0026gt;\r\u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt;\r\u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt;\r\u0026lt;/ciManagement\u0026gt;\r\u0026lt;parent\u0026gt;\r\u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;pom-jipipe\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2021.2\u0026lt;/version\u0026gt; \u0026lt;!-- Update the version accordingly --\u0026gt;\r\u0026lt;relativePath/\u0026gt;\r\u0026lt;/parent\u0026gt;\r\u0026lt;repositories\u0026gt;\r\u0026lt;repository\u0026gt;\r\u0026lt;id\u0026gt;imagej.public\u0026lt;/id\u0026gt;\r\u0026lt;url\u0026gt;http://maven.imagej.net/content/groups/public\u0026lt;/url\u0026gt;\r\u0026lt;/repository\u0026gt;\r\u0026lt;/repositories\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;imagej\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;net.imglib2\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;imglib2-ij\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;imagej-legacy\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;scijava-log-slf4j\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- JIPipe core library --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jipipe-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- ImageJ integration --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jipipe-ij\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- Add more JIPipe libraries if you need --\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;license.licenseName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.licenseName\u0026gt;\r\u0026lt;license.copyrightOwners\u0026gt;N/A\u0026lt;/license.copyrightOwners\u0026gt;\r\u0026lt;license.projectName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.projectName\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;build\u0026gt;\r\u0026lt;plugins\u0026gt;\r\u0026lt;!-- This plugin can be useful to create a manually-installable package --\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.1.1\u0026lt;/version\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt;\r\u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;outputDirectory\u0026gt;${project.build.directory}/dependencies\u0026lt;/outputDirectory\u0026gt;\r\u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt;\r\u0026lt;overWriteSnapshots\u0026gt;false\u0026lt;/overWriteSnapshots\u0026gt;\r\u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt;\r\u0026lt;excludeGroupIds\u0026gt;net.imagej, net.imglib2, org.scijava, com.google.code.gson,\rcom.google.guava, org.swinglabs, ome\r\u0026lt;/excludeGroupIds\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;scijava-maven-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;set-rootdir\u0026lt;/id\u0026gt;\r\u0026lt;phase\u0026gt;validate\u0026lt;/phase\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;set-rootdir\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;copy-jars\u0026lt;/id\u0026gt;\r\u0026lt;phase\u0026gt;install\u0026lt;/phase\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;copy-jars\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt;\rCreating an extension service JIPipe uses the SciJava plugin API to register Java extensions. In your project, you can create as many extensions as you want.\nJava extension inherit from JIPipeJavaExtension and require a @Plugin annotation.\nWe recommend to inherit from JIPipeDefaultJavaExtension that comes with some convenience-functions.\nA minimal extension can be found here:\n@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r@Override\rpublic String getName() {\rreturn \u0026#34;My extension\u0026#34;;\r}\r@Override\rpublic HTMLText getDescription() {\rreturn new HTMLText()\u0026#34;A Java extension\u0026#34;);\r}\r@Override\rpublic String getDependencyId() {\r// We recommend the following structure: \u0026lt;groupId\u0026gt;.\u0026lt;artifactId\u0026gt;:\u0026lt;dependencyId\u0026gt;\r // (!) The dependency Id should be unique for your plugin (!)\r return \u0026#34;org.hkijena.jipipe:my-extension\u0026#34;;\r}\r@Override\rpublic String getDependencyVersion() {\rreturn \u0026#34;1.0.0\u0026#34;;\r}\r@Override\rpublic String getAuthors() {\rreturn \u0026#34;Ruman Gerst\u0026#34;;\r}\r@Override\rpublic String getWebsite() {\rreturn \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;;\r}\r@Override\rpublic String getLicense() {\rreturn \u0026#34;BSD-2\u0026#34;;\r}\r@Override\rpublic URL getLogo() {\r// This code loads the default JIPipe logo from JIPipe resources\r // You can replace it with your own logo if you want\r // Just do not use JIPipe\u0026#39;s ResourceUtils for this, as its always pointing to JIPipe resource directories\r return ResourceUtils.getPluginResource(\u0026#34;logo-400.png\u0026#34;);\r}\r@Override\rpublic String getCitation() {\r// Here you can enter a citation for your publication\r // It will be displayed in the plugin manager\r return \u0026#34;\u0026#34;;\r}\r@Override\rpublic void register() {\r// Content is registered here\r }\r}\rTesting your extension Use following code to create an ImageJ2 instance that immediately loads JIPipe:\npublic static void main(final String... args) {\rfinal ImageJ ij = new ImageJ();\rij.ui().showUI(); // If your ImageJ freezes, you can leave this out. JIPipe will show anyways.\r ij.command().run(JIPipeGUICommand.class, true);\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/slot-configuration/",
	"title": "Customizing slots",
	"tags": [],
	"description": "",
	"content": "In the previous examples, we used the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations with autoCreate = true to automatically configure the slots.\nThis is not sufficient for more complicated algorithms that require\n Restricting the number of slots Restricting the allowed data types Users to add more slots or remove existing ones  A custom JIPipeSlotConfiguration can be used to implement such more advanced behaviors.\nFor many cases, the default implementation JIPipeMutableSlotConfiguration is sufficient.\nThe slot configuration can be overriden during instantiation of the algorithm:\npublic MyAlgorithm(JIPipeNodeInfo info) {\rsuper(info, JIPipeMutableSlotConfiguration.builder()\r.addInputSlot(\u0026#34;Input\u0026#34;, ImagePlusData.class)\r.restrictOutputTo(ImagePlusData.class)\r.build());\r}\r\rThe slots of JIPipeMutableSlotConfiguration are by default unsealed - meaning that users can add more slots. Use the seal() functions to prevent this.\n\rDo not create static slot configurations. Each algorithm should have its own instance. Use a private static function if you want to work outside the capabilities of the builder.\n\rYou should keep the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations. They are required for the algorithm finder and generating tooltips.\n\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "This library provides integration of ImageJ data types, as well as common ImageJ algorithms.",
	"content": "The ImageJ integration library integrates common data types from ImageJ into JIPipe:\n Multi-dimensional images (ImagePlus). The standard output file format are TIFF files. Result tables. They are serialized to CSV files. Region of interest (ROI Manager). JIPipe handles ROI as *.zip files.  The ImageJ data types are marked as accessible from outside JIPipe, meaning that algorithms that only use those types can be executed standalone\nImage data types Various ImageJ algorithms only work on data with a specific color type, or dimensionality. To make it easier for algorithms to specifiy which types are suitable, the JIPipe standard library introduces various image sub-types (e.g. 8-bit greyscale 3D image).\nThe library is set up to automatically convert any image data type into any other image data type. During this conversion, the data types automatically attempt to satisfy their constraints or raise an error. The conversion automatically converts a lower-dimensional image into a higher-dimensional image (e.g. 2D to 3D), but not the other way around.\nThe image data types are organized in the following way:\nmermaid.initialize({startOnLoad:true});\rgraph LR;\rImgPlus[\"Image (nD)\"] -- ImgPlusGreyscale[\"Greyscale image (nD)\"]\rImgPlusGreyscale -- ImgPlusGreyscale8U[\"8-bit greyscale image (nD)\"]\rImgPlusGreyscale8U -- ImgPlusGreyscaleMask[\"8-bit mask (nD)\"]\rImgPlusGreyscale -- ImgPlusGreyscale16U[\"16-bit greyscale image (nD)\"]\rImgPlusGreyscale -- ImgPlusGreyscale32F[\"32-bit float greyscale image (nD)\"]\rImgPlus[\"Image (nD)\"] -- ImgPlusColor[\"Color image (nD)\"]\rImgPlusColor -- ImgPlusColor8U[\"8-bit color image (nD)\"]\rImgPlusColor -- ImgPlusColorRGB[\"RGB color image (nD)\"]\r The graph above shows the structure for non-dimensional (nD) images. This structure is repeated for 2D, 3D, \u0026hellip; 5D images.\nColor space conversions are automatically applied (e.g. from RGB to greyscale). While trivial for specific color types (like RGB color), JIPipe falls back to following color spaces for generic colors (e.g. greyscale image):\n   Color space Fallback colorspace     Greyscale 32-bit float greyscale   Color RGB color    Frequency space image data types The JIPipe standard library contains color types that are intended to hold frequency-space (FFT) data. While the standard library only provides methods to handle 2D FFT, there are 3D, \u0026hellip;, 5D data types available for future extensions.\nWe rely on the mechanisms provided by ImageJ. For example, the ImageJ FFT generates a 8-bit greyscale power spectrum image and attaches data to the image instance. JIPipe has no special methods to load and save the FFT data, aside from the image data itself. We recommend to generate FFT data within the pipeline to generate the correct data.\n\rImageJ algorithms The standard library provides a selection of common ImageJ algorithms as JIPipe algorithm nodes. Those algorithms wrap around the respective ImageJ methods and have the same feature set, aside from some changes that are required to make algorithms usable in a batch-environment like JIPipe.\nYou can find a list of all algorithms via the  Help menu on the top right corner and the item Algorithm compendium.\nMacro node If an algorithm is not available as JIPipe node, you can use the Macro node.\n"
},
{
	"uri": "https://www.jipipe.org/tutorials/jipipe-for-imagej-users/",
	"title": "JIPipe for ImageJ users (Video)",
	"tags": [],
	"description": "This video explains the basics of creating pipelines in JIPipe - aimed towards users already familiar with ImageJ.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/documentation/graph-editor/",
	"title": "Pipeline editor",
	"tags": [],
	"description": "Explains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.",
	"content": "\rThis guide is also available as video tutorial.\r\rThe graph editor (pipeline editor) allows you to edit the processing steps of a graph compartment. Its user interface is separated into three sections:\n The analysis graph contains the processing steps (also referred as algorithms) The settings panel shows the properties of the currently selected algorithms The toolbar allows you to add more algorithms into the graph, navigate to existing algorithms, change some behavior settings of the graph editor, and create screenshots  Analysis graph The analysis graph contains algorithms that are represented by rectangles. The algorithm graph area will automatically grow depending on where you place the algorithms. Scroll bars will appear if the graph area is larger than the available screen size.\nAn alternative to using the scroll bars is to hold the middle mouse button while dragging the your mouse.\n\rAlgorithms read data from their input slots and output the results into the output slots. There are some algorithms that do not have input slots - they produce output based on their current parameters. The algorithm user interface has three sections:\n Input slots are located on the top of the algorithm UI. Each slot has a unique name that is displayed below the arrow. The arrow opens a menu that allows you to make/modify connections or change other options specific to the slot. Depending on the algorithm, a + button is created that allows you to add more slots. The drag area allows you to move the algorithm around. Move your  mouse pointer over the area and drag your mouse while holding the 🖱 left mouse button. On clicking the  button, a menu will open that contains some algorithm options. Alternatively you can right-click the drag area to open this menu. Output slots are located on the bottom and allow you to connect your output data to the input of another algorithm.  Any output data is always saved automatically by JIPipe. After generating the final output data, there is no need to connect it to any input.\n\rSlot connections You can connect two slots by clicking the  or  button of a slot and by selecting the source/target slot. Input slots can only receive one connection, while outputs can be distributed to as many inputs as you wish. The selection menu shows all available target slots and its sorted from the nearest to the slot that is furthest away.\nA connection is shows as line between the connected slots. The color of the line indicates if this connection is valid or invalid depending on the data types of the source and target.\n A black line indicates that the data types match exactly. A blue line indicates that the types dont match exactly, but can be converted by JIPipe A red line indicates that the types are incompatible. You will probably get an error message during the calculation.  Hover with your mouse over a slot\u0026rsquo;s name to show information about its data type.\n\rSlot options The slot context menu opened by  or  contain additional entries to managing connections.\n  Label this slot allows you to give the slot a custom name without changing the internal workings of the algorithm (As many algorithms are designed to adress specific slots). On selecting the entry, you can give a custom name that is displayed in cursive. To remove the custom label, label it with an empty text.  Find matching algorithm \u0026hellip; opens a tool that lists all compatible algorithms that can receive the output data as input. Depending on the algorithm, you can remove a slot from within this menu  Algorithm settings The algorithm settings are displayed on the right-hand side and contain all settings of the selected algorithm. There are usually four categories:\n  Parameters contains general parameters, like the name displayed in the drag area, and algorithm-specific parameters like thresholds, the selection of methods, and other parameters.  Slots is an alternative to modifying slots via the algorithm UI. Here, you can also re-order slots.  Annotations is an alternative to modifying slot annotations via the algorithm UI. See above for more info about annotations.  Quick run is a tool to run the analysis only up to the selected algorithm. It allows you to try and compare multiple parameters without creating new nodes. See the testbench documentation for more info.  Toolbar The toolbar contains functions to add new algorithms into the graph, navigate to existing algorithms or search the list of available algorithms, and functions to control the algorithm graph display.\n On the left-hand side you can find a menu containing all available algorithms. On selecting an entry, the corresponding algorithm is added to the graph. The navigator allows you to quickly navigate to an existing algorithm instance or create a new one. Just type one or multiple search terms into the field. On pressing the  arrow down key on your keyboard, the first entry is selected. The view options control how the graph editor behaves and contains some additional utility functions.  Additional tools  and allow you to switch between horizontal and vertial view modes. This does not change the pipeline, but just how it is displayed in the editor. By default, a vertical view is enabled. If you prefer that data flows from left to right, choose the horizontal view mode. automatically aligns all nodes in the algorithm graph according to the algorithm by Sugiyama et. al allows you to change how dragging the middle mouse button changes the current view. is enabled by default and makes it that nodes are automatically aligned on creating connections. This feature does not reorganize the whole graph, but only places the target algorithm to a location that better represents the data flow. crops the graph area to the area taken by the algorithm nodes. Use this tool to find your nodes after scrolling too far away. creates a screenshot of the whole graph compartment that is currently being displayed.  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/result-preview/",
	"title": "Preview from results folder",
	"tags": [],
	"description": "",
	"content": "While JIPipeData allows you to define a custom function for previewing, this only works for data already present in memory. To allow previewing of data stored in a results folder, you need to suppy a JIPipeResultDataSlotPreviewUI that loads the data from disk and generates a preview. We recommend to use JIPipeAsyncResultDataPlotPreviewUI This class will offload the loading and preview generation into a separate thread to prevent the UI from freezing. By default it will use the already defined importFrom(Path) method present in the JIPipeData class and use its already defined preview function.\nYou can override the data loading and other methods for customization.\npublic class MyDataPreviewUI extends JIPipeAsyncResultDataPlotPreview {\rpublic MyDataPreviewUI(JTable table) {\rsuper(table);\r}\r}\rThe preview class is registered as last argument of registerDataType():\n@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r// ... See previous tutorial for other methods\r @Override\rpublic void register() {\r// The last null parameter will be handled in the next tutorial\r registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, MyDataPreviewUI.class);\r}\r}\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "Are you new to JIPipe? Do you want to find out what this tool is about? Then watch our video abstract:\n\rTutorial list You will find text and video tutorials in the following list. All tutorials are also available as playlist on YouTube.\n Image analysis pipeline\nThis step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n\r Image analysis pipeline (Video)\nThis step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n\r Creating an extension\nThis step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.\n\r JIPipe for ImageJ users (Video)\nThis video explains the basics of creating pipelines in JIPipe - aimed towards users already familiar with ImageJ.\n\r User interface (Video)\nThis video explains the basics of the JIPipe user interface.\n\r Data caches (Video)\nThis video explains the basics of the caching system.\n\r Graph editor user interface (Video)\nThis video explains the basics of the graph editor user interface.\n\r How to do batch processing (Video)\nThis video explains how to create a batch processing pipeline.\n\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/macro-node/",
	"title": "Macro node",
	"tags": [],
	"description": "The macro node allows to run ImageJ macros.",
	"content": "The macro node allows to run existing ImageJ macros or execute algorithms that are not directly available as JIPipe nodes. You will find it in Images \u0026gt; ImageJ Macro.\nInputs and outputs By default, the node has no inputs and outputs. Use to the + button to add them. For example, if you want to process one image and output the processed result, create one input and one output.\nBy default, there are four data types that can be used as input and output:\n Any image data type Results table ROI List Paths  Depending on the data type, JIPipe converts inputs into a format that can be processed by an ImageJ macro. The other way around, JIPipe extracts outputs from via modes that are commonly used in macros.\nDevelopers can provide their own integrations to add more data types.\n\rImage data As input: The image is opened as ImageJ image window, named according to the slot name. We recommend to use the macro command select(\u0026lt;window name\u0026gt;) to first select the image window before applying the processing.\nAs output: The image is extracted from an image window, named according to the slot name. Use the rename() command to rename outputs accordingly.\nExample (for the node shown above)\n// The input is created as window \u0026#34;Input\u0026#34;\rselectWindow(\u0026#34;Input\u0026#34;);\rrun(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=2\u0026#34;);\r// The node expects an image window \u0026#34;Output\u0026#34;\rrename(\u0026#34;Output\u0026#34;);\rResults table As input: The table data is opened as the main \u0026ldquo;Results\u0026rdquo; table. We recommend to have only one results table input, as the conversion overwrites the current table.\nAs output: The table data is extracted from the main \u0026ldquo;Results\u0026rdquo; table.\nYou should only have one results table input, as only the latest input is used. If you want to merge tables, use JIPipe nodes for this.\n\rROI data As input: The ROI are added to the ROI manager. Like with the results table data, the existing ROI manager is cleared.\nAs output: The ROI are extracted from the ROI manager.\nYou should only have one results ROI List data input, as only the latest input is used.\n\rPath data As input: Paths are defined as string variable, named according to the input slot name. Please note that the slot name must be a valid variable name.\nAs output: A path is extracted from a results table window (row 0, column 0). We do not recommend to extact paths as output, as ImageJ does not have native handling for such data.\nWe recommend to only use paths as input. The extraction as output is unpredictable, as ImageJ has not a native way to display this type in a way that can be distinguished from result tables.\n\rParameters The most important parameters are\n The macro code The list of variables  The Code parameter contains the macro code. You can hide it with Collapse or open the code in a larger editor (in a separate tab).\nVariables The macro node allows you to create parameters that can be directly accessed from within JIPipe. The benefit is that those variables can be exported (custom nodes/group node) for ease of use or applying multiple parameter sets.\nClick the Add parameter button in the Macro parameters category to add a variable/parameter.\nIn the dialog, you have to set following options:\n Select the data type of the parameter The Unique identifier acts both as identifier inside JIPipe and the variable name inside the macro. The Name is displayed in the JIPipe GUI The Description field allows you to provide a documentation displayed at the bottom of the parameter list  Variables inside macros On running the macro node, the final code is assembled by adding variables at the top.\nVariables are assembled as var \u0026lt;Unique identifier\u0026gt; = \u0026lt;Value\u0026gt;. The values are converted as following:\n   JIPipe parameter type ImageJ macro variable type     String String   Byte Integer   Short Integer   Double Double   Float Double   Path String   Boolean Boolean    For example, a Gaussian blur node with a Sigma parameter will generate following code:\n// Code generated from parameters\rvar sigma = 2.0;\r// Code written in the \u0026#34;Code\u0026#34; parameter\rselectWindow(\u0026#34;Input\u0026#34;);\rrun(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=\u0026#34; + sigma);\rrename(\u0026#34;Output\u0026#34;);\r\rPath inputs are converted in a similar way.\n\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-user-interface/",
	"title": "User interface (Video)",
	"tags": [],
	"description": "This video explains the basics of the JIPipe user interface.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-data-caches/",
	"title": "Data caches (Video)",
	"tags": [],
	"description": "This video explains the basics of the caching system.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-graph-editor/",
	"title": "Graph editor user interface (Video)",
	"tags": [],
	"description": "This video explains the basics of the graph editor user interface.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/tutorials/guide-batch-processing/",
	"title": "How to do batch processing (Video)",
	"tags": [],
	"description": "This video explains how to create a batch processing pipeline.",
	"content": "\r"
},
{
	"uri": "https://www.jipipe.org/documentation/expressions/",
	"title": "Expression parameters",
	"tags": [],
	"description": "Explains the expression parameter type language that is often used for filtering or generating numbers.",
	"content": "When using nodes that filter or generate data, you might encounter a parameter type called \u0026ldquo;Expression\u0026rdquo;. This parameter allows to to write simple to complex functions that can test for one or multiple conditions or act as input for a generator node. The basic concept of this expression language is to mix string, boolean, and numeric operations into one simple but powerful language. It allows you for example to first calculate a numeric metric and use it for filtering objects within one line.\nThere are always four components you will interact with:\n Literals like numbers (0.5), strings (\u0026quot;hello world\u0026quot;), and boolean values (TRUE, FALSE) Variables that are supplied from the node itself like x, y, or Area Functions that process literals or variables like MIN(x, 5), STRING_EQUALS(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;). Parameters are separated by commas. Operators that do something with the literals, variables, or function results, like subtraction, concatentation, or conditions  The expression language is interpreted as one line and you cannot write own variables. The result of the one expression is supplied to the node for processing.\nThe user interface of the expression parameter allows you to type the expression via a text field. You can also create new lines if you have longer expressions. They will be all merged automatically. If you are unfamiliar with the expression language, you can click the button to open a tool that lists all available functions and operators. This tool will help you to build expressions and check the syntax.\nTo get familiar with expression, use JIPipe\u0026rsquo;s integrated calculator tool (Tools \u0026gt; Development \u0026gt; Calculator). You can play around with any expression you like without breaking something.\n\rVariables Variables are set externally by the node and can contain various useful values. For example, filter nodes will put numbers into the variables. Image generator nodes might put the pixel coordinates into them.\nExample Here the node supplies the variables x and y and expects a number back. You can input a formula that will be automatically applied to ally x and y values:\n(x + y) + x/y + 1\r\rThe expression builder shows a list of all variables. This list might be incomplete if variables are generated during the runtime (e.g., extracted from a table).\n\rOperators The expressions understand a wide range of common operators for numeric, string, and boolean data:\n You can add, subtract, divide, \u0026hellip; numbers Strings can be concatenated or checked for if one string contains another All basic boolean operators are available  Example You can combine various operators to do complex filtering. Here the node supplies variables Area and MaxWidth:\n(Area \u0026gt; 1000) AND ((MaxWidth^2 / Area \u0026gt; 0.5))\rFunctions The expression language comes with a large library of predefined functions that you can use for more complex tasks:\nExample To find files, it can be useful to utilize a Glob-filter that can reliably test for the file extension. Here name is the file name and supplied by the node.\nSTRING_MATCHES_GLOB(name, \u0026quot;*.tif\u0026quot;) AND (\u0026quot;data\u0026quot; IN name)\rData types The expression language supports five basic data types: Numbers, strings, arrays, and maps\nNumbers Numbers are any kind of number (integer or floating point). Number literals are read as floating point numbers (double).\nExample: 1, 0.5\nStrings Strings are character sequences (texts). They are defined by putting double quotes around a text. If you want to have a double quote inside your string, escape it via \\. If you want a \\ in your text, escape it with another \\.\nExample: \u0026quot;hello world\u0026quot;, \u0026quot;this text has a \\\u0026quot; quote and \\\\ backslash\u0026quot;\nArrays Arrays are collections of values. They are defined via the ARRAY(...) function. Individual items are access via the @ operator and a numeric index starting from zero.\nExample: ARRAY(1,2,3,4) @ 2 will return 3.\nExample: ARRAY(1,2,3,4) @ ARRAY(0,1) will return an array with 1 and 2\nMaps Maps are collections of values where each value is given a unique name. They are defined via the MAP(...) function that should be provided with 2-item arrays (there is a PAIR(key, value) function for this). You can get an array of all keys via the KEYS() function and can access elements via the @ operator.\nExample: MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3)) @ \u0026quot;b\u0026quot; returns 2\nExample: KEYS(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with a, b, and c\nExample: VALUES(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with 1, 2, and 3\nOperators There are many operators with alternative ways to write them available. There are two kinds of operators:\n Symbolic operators are using symbols like $, \u0026amp; or * Textual operators are written words like AND or CONTAINS  The difference between the operators is that symbolic operators can be written without spaces. For example you can write 5+5 or !x. Textual operators require spaces to be separated. For example you cannot write NOTx. You have to write NOT x.\n   Operator Description Usage     Logical AND Returns TRUE if both operands are TRUE x AND y or x \u0026amp; y   Logical OR Returns TRUE if one of the operands is TRUE x OR y or x | y   Logical XOR Returns TRUE if exactly one operand is TRUE x XOR y   Logical NOT Returns TRUE if input is FALSE and vice versa NOT x or ! x   Numeric division Divides the left by the right operand x / y   Numeric exponent Calculates left to the power of the right operand x ^ y   Numeric subtraction / Array removal Subtracts right from left (Numbers). If the operands are arrays, the right items are removed from the left array x - y   Numeric multiplication Multiplies the two operands x * y   Numeric addition / String concatenation / Array concatentation Adds two numbers. Concatenates if the operands are strings. Merges two arrays x + y   Numeric greater than Returns TRUE if the left operand is greater than the right one x \u0026gt; y   Numeric greater or equal Returns TRUE if the left operand is greater or equal to the right x \u0026gt;= y   Numeric less than Returns TRUE if the left operand is less than the right one x \u0026lt; y   Numeric less or equal Returns TRUE if the left operand is less or equal to the right one x \u0026lt;= y   Numeric / String / Boolean equality Returns TRUE if the operands are equal x == y or x EQUALS y   Numeric / String / Boolean inequality Returns TRUE if the operands are unequal x != y or x UNEQUAL y   Numeric negation This is technically an operator -x   Numeric modulo Calculates the modulo x % y   Contains Returns TRUE if the one string is contained in the other one (both operands are strings), or if an array contains an item, or a map contains a values x IN y or y CONTAINS x   Variable exists Returns TRUE if the a variable with the name exists x EXISTS   Resolve variable Returns the value of the variable with name. Useful for variables that have spaces in their names or special characters. $ x (Alternative function: GET_VARIABLE(x))   Get item in array/map Returns the array item(s) or string characters of the left operands. The right-hand side can be a number (the index starting from 0) or an array of indices. If the left operand is a map, the indices are whatever the map uses as index x @ y or x AT y    Precedence The operators are ordered according to a precedence table. You might need to use brackets (()) to force the order you expect:\nThe higher the number is the more the operator is preferred.\n   1 2 3 4 5 6 7 8 9 10     OR AND NOT           XOR                Subtraction (x - y) Divide (x / y)  Power (x^y) Negate (-x)         Modulo (x % y)            Multiply (x * y)          Greater than or equal (x \u0026gt;= y)            Greater than (x \u0026gt; y)            Less than or equal (x \u0026lt;= y)            Less than (x \u0026lt; y)            Equal (x == y)            Unequal (x != y)             String contains (x IN y)            Addition (x + y)            String contains (x CONTAINS y)             Variable exists (x EXISTS)              Array/Map access (x @ y) Variable resolve ($ x)    Compatible types Not all operators are compatible to all types. See following table for the operator\u0026rsquo;s behavior:\n   Operator Number Boolean String Array Map     AND Error OK Error Error Error   NOT Error OK Error Error Error   OR Error OK Error Error Error   XOR Error OK Error Error Error   Divide (x / y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Multiply (x * y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Modulo (x % y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Subtract (x - y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) OK (both operands are arrays) OK (left operand is map, right operand is array or map)   Addition (x + y) OK OK (TRUE=1, FALSE=0) OK (Conversion to strings, string concatenation) OK (both operands are arrays) OK (both operands are maps)   Equality (x == y) OK OK OK (If types differ, conversion to strings) OK OK   Inequality (x != y) OK OK OK OK OK   Contains (x IN y / x CONTAINS y) Error Error OK OK OK   Less than (x \u0026lt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Less than or equal (x \u0026lt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than (x \u0026gt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than or equal (x \u0026gt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Variable exists (x EXISTS) Works (Converted to string) Works (Converted to string) OK Error Error   Variable resolve ($ x) Works (Converted to string) Works (Converted to string) OK Error Error   Get item in array or map (x @ y) Error Error Error OK OK    "
},
{
	"uri": "https://www.jipipe.org/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": " General questions\nGeneral questions about JIPipe\n\r User interface\nQuestions concerning the user interface\n\r Data processing\nQuestions about how data is processed\n\r ImageJ integration\nQuestions about the integration into ImageJ and popular plugins like OMERO\n\r Result analysis\nQuestions concerning the export and further analysis of results\n\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/",
	"title": "Creating an algorithm",
	"tags": [],
	"description": "Explains how to create a custom algorithm",
	"content": "All algorithms inherit from JIPipeAlgorithm. An algorithm consists of following parts:\n A run() function that runs the workload A reference to an algorithm info that describes the general properties of the algorithm A slot configuration that describes which slots the algorithm should have  JIPipe comes with different base algorithms that provide different feature sets:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Any algorithm should have the following basic structure:\n// Annotates documentation to the algorithm\r@JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;)\r// Sets the algorithm category\r@JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class)\r// Input and output slots autoCreate automatically creates the slots if set to true and no slot configuration was provided\r@AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true)\r@AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true)\r// You can add multiple JIPipeCitation annotations to provide citations for this node only\r@JIPipeCitation(\u0026#34;Additional citation\u0026#34;)\rpublic class MyAlgorithm extends JIPipeAlgorithm {\r/*\rThis is the main constructor of the algorithm.\rIt contains a reference to the algorithm info that contains\rsome important metadata\r*/\rpublic MyAlgorithm(JIPipeNodeInfo info) {\rsuper(info);\r}\r/*\rA deep copy constructor. It is required.\rPlease do not forget to deep-copy all important fields\r*/\rpublic MyAlgorithm(MyAlgorithm original) {\rsuper(original);\r// Deep-copy additional fields here\r }\r/*\rThe workload is run in this functon.\rYou can also have the ability to inform the user about the current algorithm status\rfor more complex algorithms.\rYou can also query if the user requested cancellation\r*/\r@Override\rpublic run(JIPipeProgressInfo progress) {\r// Run your workload here\r }\r}\rTo register the algorithm and provide it with an Id, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r// ... See previous tutorial for other methods\r @Override\rpublic void register() {\r// Registers our algorithm with a unique ID and an icon\r registerNodeType(\u0026#34;my-algorithm\u0026#34;, MyAlgorithm.class, UIUtils.getIconURLFromResources(\u0026#34;actions/viewimage.png\u0026#34;));\r}\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/dependency/",
	"title": "Dependency",
	"tags": [],
	"description": "Project or extension dependency. Refers to an JIPipe extension.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: dependency.schema.json\n\rProject or extension dependency. Refers to a JIPipe extension.\r\r\rmetadata:\r\rSee metadata\r\r\r\r\r\r\r\r\rid:\r\rstring\r\r\r\r\r\r\rUnique ID of this dependency should have format\r\r.\r\r:\r\r\r\r\r\r\rversion:\r\rstring\r\r\r\r\r\r\rVersion of this dependency\r\r\r\r\r\rExample {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;,\r\u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;,\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "This section explains the JIPipe user interface, how to create an analysis pipeline, and some concepts behind how analysis pipelines work.\nBatch processing JIPipe is a tool to create data processing workflows via a graphical language. A special feature of JIPipe processing is always done in batches, meaning that workflows are always designed to scale for large amounts of data without the need of external scripts or major changes in a pipeline.\nThe JIPipe graphical language is graph-based where nodes represent data processing algorithms and edges represent that data is transferred from an algorithm output to another algorithm\u0026rsquo;s input.\nAn example is the application of a gaussian filter to an image after loading it:\nmermaid.initialize({startOnLoad:true});\rgraph LR;\rA[File] -- B[Load image]\rB -- C[Apply gaussian]\r To design efficient and scalable pipelines yourself, it is a good idea to look into the JIPipe data model.\nGraph compartments A common issue with graphical programming languages is that larger pipelines are hard to navigate. Another issue with such languages is that it is hard to separate functional units for easier readability.\nJIPipe solves both issues with the concept of strongly separated graph components that group a set of algorithms together. Components only can interact via special interface algorithms, making it easier to structure the pipeline.\nPlease take a look at our graph compartment documentation for more information.\nUser interface overview The JIPipe user interface is designed around managing an analysis project. A project contains all information to run an analysis, outside of the input data and can be saved into JSON files. The user interface is separated into three sections:\n The project menu contains all operations for the current project / window. It allows you to open/save projects, access and modify graph compartments, manage plugins, and run the analysis The tab bar allows you to switch between different interfaces associated to the current project. You can close thabs by clicking the x icon. If a tab contains some data that will be lost after closing it, you will have to confirm the action. If no question is asked on closing a tab, you will be able to open it later again without losing data. The current content depends on the selected tab  You can also close a tab by clicking it with the middle mouse button.\n\rFurther reading  Batch pipelines\nExplains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.\n\r Pipeline editor\nExplains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.\n\r Expression parameters\nExplains the expression parameter type language that is often used for filtering or generating numbers.\n\r Graph compartments\nExplains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.\n\r Running a pipeline\nExplains how to run a pipeline and navigate through the results.\n\r Running a single node\nExplains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.\n\r Data caching\nExplains the how JIPipe caches intermediate results and how to access them.\n\r ImageJ integration\nExplains functionality that allows ImageJ to run JIPipe algorithms or pipelines.\n\r Managing plugins\nExplains how to install and manage plugins.\n\r Standard library\nContains some explanations about the algorithms that are included in the JIPipe standard distribution.\n\r Extension builder\nExplains the extension builder tool\n\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/filesystem/",
	"title": "Filesystem algorithms",
	"tags": [],
	"description": "This library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.",
	"content": "The JIPipe standard library contains data types and algorithms to apply file system operations. The common use case is to extract the list of input files for the following algorithms.\nThe filesystem library has two basic data types:\n A  File contains a path to a file A  Folder contains a path to a folder A Path contains a path to a file or folder  In the Add data menu you can define one file/folder or a list of files/folders.\nWe recommend to create a list of files/folders. This makes it easier to scale your workflow up.\n\rDrag any set of files or folders into the graph editor to create corresponding file/folder data source algorithms.\n\rFile/folder manipulation algorithms The standard library comes with various algorithms that apply common operations to input filesystem data. This includes listing the files in a folder, filtering files/folders, or navigating to a subfolder. They are placed in the Filesystem category.\nAutomated relativization File and folder data source algorithms by default store absolute paths. If you save your project in a parent folder where the data is stored, the paths are automatically converted into relative paths that make data transfer between devices easier.\nAnnotation It is helpful to add data annotations to the file data at some point. This allows algorithms and users to assign data rows to an unique data set. See the annotation standard library documentation for more information.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/graph-compartment/",
	"title": "Graph compartments",
	"tags": [],
	"description": "Explains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.",
	"content": "A common issue with graphical programming languages is that large graphs are hard to navigate. JIPipe solves this issue by separating the pipeline graph into sub-graphs. Each sub-graph has a predetermined output node that is visible to other compartments. Other nodes on the other hand are not visible to other compartments.\nThe difference between compartments and simple node groups is that compartments only communicate with each other via the compartment output node. JIPipe also only allows you to edit a specific compartment, instead of the whole graph. By default, JIPipe creates three compartments: Preprocessing, Analysis, and Postprocessing.\nBy default a compartment\u0026rsquo;s output node is not visible in any other compartment. The have to be connected in a similar manner on how algorithms are connected. To do this, use the compartment editor that is described in the following section.\n\rYou can ignore the compartment feature if you want. You can delete the default compartments without any issue. Just leave one graph compartment and edit the remaining one.\n\rCompartments behave similar to algorithms. This means you can create a directed acyclic graph of compartments.\n\rCreating and connecting compartments JIPipe comes with an editor that allows to control the graph compartments. This editor is similar to the pipeline editor and allows you to create new compartments, connect them, as well as import or export compartments. Instead of containg algorithms, the editor contains graph compartment nodes that can be connected similar to how algorithms are connected.\nYou can one or multiple compartments in the editor. Click the  Edit button to open the compartment in the pipeline editor.\nYou can also double-click a compartment node to open the editor.\n\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/multi-parameter/",
	"title": "Multi-parameter algorithms",
	"tags": [],
	"description": "This library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.",
	"content": "Most algorithms allow handling of multiple parameters via an additional slot that can be optionally enabled. You can find the setting in an algorithm\u0026rsquo;s settings as Multiple parameters. On selecting the item, a new slot will appear that consumes parameter data.\nTo define parameters, use the algorithms found in Add data \u0026gt; Parameters. There are currently two data source algorithms available:\n Define parameter defines a single set of parameters Define multiple parameters lets you define a table of parameters  Use Process \u0026gt; Merge \u0026gt; Merge slots to merge multiple parameter sets.\n\rDefining parameters Both data sources require you to determine which parameters should be created. To do this, add parameters into the Parameters section (red box).\nFor Define multiple parameters, there is an additional element (blue box) that contains a parameter table. Each row represents a parameter set, while a column represents a parameter type. Columns can be added by adding parameters into the Parameters section.\nYou can leave the table empty. In this case, the parameters are extracted from the \u0026lsquo;Parameters\u0026rsquo; section.\n\rSelect a table cell to open the parameter editor below the table.\nThere are following buttons available:\n Add row adds a new row with standard parameters Generate row allows you to create new rows where one column is generated by the selected generator Replace cells allows you to replace the selected cells in one column with a set of generated parameters  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/parameters/",
	"title": "Parameters",
	"tags": [],
	"description": "",
	"content": "You can add parameters to your algorithm by creating a property with a getter and setter. Then you annotate the getter and setter with the same @JIPipeParameter keys. Also add an @JIPipeDocumentation annotation to either the getter or setter.\nParameters are automatically serialized and deserialized.\nPlease make sure to send an event when the parameter is set, so the UI can update.\n// ... see previous tutorials\rpublic class MyAlgorithm extends JIPipeIteratingAlgorithm {\rprivate float roundness = 0.5f;\r// ... see previous tutorials\r\r@JIPipeParameter(\u0026#34;roundness\u0026#34;)\r@JIPipeDocumentation(name = \u0026#34;Roundness\u0026#34;, description = \u0026#34;Value within [0, 1]\u0026#34;)\rpublic float getRoundness() {\rreturn roundness;\r}\r@JIPipeParameter(\u0026#34;roundness\u0026#34;)\rpublic boolean setRoundness(float roundness) {\rif(roundness \u0026lt; 0 || roundness \u0026gt; 1)\rreturn false; // Reject this value\r this.roundness = roundness;\r// Send the change out to listeners\r getEventBus().post(new ParameterChangedEvent(this, \u0026#34;roundness\u0026#34;));\r}\r}\r\rYour setter can return a boolean. If the output is true, JIPipe considers the value as valid. If false, the JIPipe UI re-loads a valid value via the getter.\n\rPlease make sure that your parameter key is unique. Only one getter and one setter should have the same key.\n\rNot all data types are supported. Data types are registered into JIPipe and available via JIPipeUIParametertypeRegistry.getInstance(). In a later tutorial we show how to register custom data types. JIPipe supports common primitives like boolean, int, float, double, String, and all enum data types.\n\rParameter settings Some parameter types have different styles or other settings that can change the behavior of the parameter editor UI. An example is StringParameterSettings that allows to change between single-line and multi-line editors.\nSub-parameters JIPipeAlgorithm, like any JIPipeParameterHolder allows sub-parameters.\nTo create a sub-parameter create a getter to an JIPipeParameterHolder and annotate it with @JIPipeParameter. The key provided with the annotation should be an unique parameter key. The parameters in the sub-parameter instance are automatically displayed as new group in the parameter editor.\nPlease do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm\u0026rsquo;s event bus. Otherwise there can be issues with the extension builder. You can use the registerSubParameter() method in the constructor and copy constructor as a shortcut.\n\rUser-defined parameters If you want to make it possible for users to create custom parameters, create an JIPipeDynamicParameterHolder as sub-parameter. You can control the list of allowed parameter types and other settings.\n\rDo not forget to deep-copy the JIPipeDynamicParameterHolder. The class has a copy constructor for such an operation.\n\rPlease do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm\u0026rsquo;s event bus. Otherwise there can be issues with the extension builder. JIPipeAlgorithm comes with a pre-made function registerSubParameters() that should be called in the constructors.\n\rFull control You can inherit from JIPipeCustomParameterHolder to define all parameters manually without the need for an JIPipeDynamicParameterHolder or annotations.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/parallelization/",
	"title": "Parallelization",
	"tags": [],
	"description": "",
	"content": "The current version of JIPipe supports parallelization via a fixed thread pool. Parallelization is done on an per-algorithm-level, meaning that the algorithms are responsible for providing parallelization capabilities.\nThe included base algorithms JIPipeIteratingAlgorithm, JIPipeSimpleIteratingAlgorithm, and JIPipeMergingAlgorithm already come with support for parallelization that has to be manually enabled via code. The inherit from JIPipeParallelizedAlgorithm and completely apply parallelization automatically.\nAutomated parallelization (JIPipeParallelizedAlgorithm) The automated parallelization is controlled by three factors:\n If the user enabled parallelization via a parameter If parallelization is supported In how many batches the data is separated  To enable parallelization, let supportsParallelization() return true (defaults to false). This will parallelize the processing of data interfaces (see previous chapters). As sometimes third-party algorithms apply their own parallelization, you can restrict how many threads are allocated by JIPipe by setting getParallelizationBatchSize.\nFor example, there are many image analysis algorithm implementations that use Runtime.getRuntime().availableProcessors() for their own parallelization. To ensure that only as many threads as the user selected are allocated, return Runtime.getRuntime().availableProcessors() from getParallelizationBatchSize(). The implementation then will adapt to this value.\npublic class MyAlgorithm extends JIPipeIteratingAlgorithm {\r/*\rEnable parallelization. By default false.\r*/\r@Override\risParallelizationEnabled() {\rreturn true;\r}\r/*\rAssume that each runIteration() executes a third-party algorithm with its own parallelization based on Runtime.getRuntime().availableProcessors() threads.\rTell this to the JIPipe implementation to limit the number of threads.\r*/\r@Override\rgetParallelizationBatchSize() {\rreturn Runtime.getRuntime().availableProcessors();\r}\r}\rManual parallelization You can choose to do your own parallelization (leave isParallelizationEnabled() to return false). Each JIPipeAlgorithm object has a method getThreadPool() that returns the thread pool assigned to the current run. Please note that this thread pool can be null.\nThe thread pool provides methods to schedule workloads. If the number of threads is set to 1, the thread pool will schedule the workload into the current thread. You also have raw access to the ExecutorService behind the thread pool - just do not forget that the service can be null.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/custom-info/",
	"title": "Custom algorithm info",
	"tags": [],
	"description": "",
	"content": "In the previous tutorials we used the standard way of creating algorithms. This might not be sufficient if you want to generate algorithms, for example by importing ImageJ algorithms, loading algorithms from JSON or generate algorithms for an unknown list of data types.\nHow algorithms are registered Algorithm instances are created by an JIPipeNodeInfo. This info is the object that is actually registered into JIPipe. It is able to create new instances of the declared algorithm, or copy it. It also carries basic metadata such as a name, description, or annotation preferences.\nDeclarations should be unique and have a unique ID within the JIPipe algorithm registry.\nOn registering an algorithm like in previous tutorials, following code is run:\npublic void registerNodeType(String id, Class\u0026lt;? extends JIPipeAlgorithm\u0026gt; algorithmClass) {\rregisterNodeType(new JIPipeJavaAlgorithmRegistrationTask(id, algorithmClass, this));\r}\rThe code generates a task that just checks if all algorithm dependencies are loaded. If all dependencies are available, the task runs:\nJIPipeAlgorithmRegistry.getInstance().register(new JIPipeNodeInfo(id, algorithmClass), source);\rThe important bit is JIPipeNodeInfo. In the end an algorithm info is created that extract algorithm information from the class annotations.\nCreating a custom info To create a custom info, inherit from JIPipeNodeInfo. The most important functions are clone() and newInstance().\nRegister the info either via a direct call to registerNodeType(JIPipeNodeInfo) or (recommended) via a task that inherits from JIPipeNodeRegistrationTask. You can inherit from the default implementation JIPipeDefaultNodeRegistrationTask that comes with pre-made functionality to check for common dependencies. The reason behind using a task is that some algorithm-internal classes might require that data types or annotation types are already registered.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph-edge/",
	"title": "Graph Edge",
	"tags": [],
	"description": "Edge in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph-edge.schema.json\n\rEdge in a graph\r\r\rsource-node:\r\rstring\r\r\r\r\r\r\rAlgorithm ID of the edge source\r\r\rtarget-node:\r\rstring\r\r\r\r\r\r\rAlgorithm ID of the edge target\r\r\rsource-slot:\r\rstring\r\r\r\r\r\r\rSlot name within the edge source algorithm\r\r\rtarget-slot:\r\rstring\r\r\r\r\r\r\rSlot name within the edge target algorithm\r\r\r\r\r\rExample {\r\u0026#34;source-node\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;,\r\u0026#34;target-node\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/",
	"title": "Java API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe Java API that allows you to create SciJava plugins to extend JIPipe. The Java API is very powerful and allows you to add algorithms, annotation types and new data types. It also allows you to create UI-only components such as parameter editors, plots, and table processing operations.\nYou can refer to the JIPipe JavaDocs for more information about the API specifics. The following tutorials will show you to implement your own Java extensions via small examples.\n JavaDocs\nProvides a link to the JavaDocs\n\r Creating an extension project\nExplains how to setup a SciJava plugin project to extend JIPipe\n\r Creating an algorithm\nExplains how to create a custom algorithm\n\r Creating a data type\nExplains how to create custom data types\n\r Creating a parameter type\nExplains how to create an UI for a parameter\n\r Usage in Java\nExplains how to use the JIPipe API to run graphs, algorithms, or projects within pure java code\n\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation/result-analysis/",
	"title": "Running a pipeline",
	"tags": [],
	"description": "Explains how to run a pipeline and navigate through the results.",
	"content": "JIPipe stores its results in a user-defined output folder. After clicking  Run (located at the top right corner of a project window) JIPipe will query the output folder from you. You can also generate a random folder that will be located on your operating system\u0026rsquo;s temporary directory by clicking the button.\nAfter confirming the settings by clicking  Run now, JIPipe will start processing the pipeline.\nYou can have as many runs as you want. Runs will not execute in parallel, but be scheduled to wait until the current run finishes.\n\rThe JIPipe output folder is automatically organized in a standardized way, so JIPipe can open a result folder. You find the \u0026ldquo;Open analysis output \u0026hellip;\u0026rdquo; button in the \u0026ldquo;Project\u0026rdquo; menu.\n\rResult analysis After all results are generated, the result analysis UI will be automatically opened. It allows you to navigate through the results, and import them back into ImageJ (if supported by the generated data type).\nThe UI has two main components:\n The slot tree shows a hierarchy of all data slots. It is organized by compartment, then algorithm, and finally data slot. By selecting any of the entries, all data associated to the selection or any n-child is displayed. The output data table lists the stored data of the selected slot(s) as table (if you are unfamiliar why this is, please take a look at the explanation on how JIPipe processes data)  After selecting a set of slots in the slot tree the output data table will update to only display the data of the selected slots. The table has following columns:\n (Optional) Compartment shows in which graph compartment the generating algorithm is located (Optional) Algorithm shows the name of the algorithm that generated the data. Location is the folder name where the data is located relative to the slot directory Data shows a string representation of the data row. The contents vary depending on the slot data type. For example, file system data display their path at this location. Additional columns correspond to the data annotations that were attached by various algorithms  Importing results back into JIPipe/ImageJ/\u0026hellip; On selecting one or multiple rows, additional UI elements are displayed below the table. They contain various actions that can be applied to the output data, such as opening the results directory, importing the data back into ImageJ or JIPipe, or any other operation.\nDouble-click a row to execute the default action, which is the one most commonly used.\n\r--\rUsing third-party software for further analysis JIPipe stores outputs in a standardized format that can be easily read with third-party software. The output folder of always contains a file project.jip, which is the project that generated the output.\nThis folder contains sub-folders named according to the graph compartment. The ID is the unique ID of the graph compartment and can be looked up in the project.jip file or the compartment graph editor.\nEach of these compartment folders contains a set of additional sub-folders based on unique ID of the node (also visible in the graph editor).\nA node folder contains a set of folders, one for each output slot. This folder may be empty if JIPipe is instructed to not save the output slot.\nEach slot folder contains a metadata file data-table.json that contains information about all stored outputs, including the data type and annotations. The metadata is also usually available as data-table.csv file that can be read more easily. The folder contains sub-folders with numeric names that correspond to the table rows. The contents of each of these folders is determined by the standardized storage format of the data type (true-data-type in the data table).\nYou can open existing project folders in JIPipe. Just go to Project \u0026gt; Open analysis output and select the folder that contains the project.jip file.\n\rWe recommend to always copy the whole project folder. This will ensure the highest reproducibility.\n\rSlot output folders are used beyond result analysis for importing/exporting cache states and to communicate with external applications like Python or R. Only the JSON file carries the metadata.\n\rA description of the contents of a table row folder can be viewed in the data type compendium (help menu).\n\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/context-actions/",
	"title": "Context actions",
	"tags": [],
	"description": "",
	"content": "Context actions allow you to add custom buttons into an algorithm\u0026rsquo;s parameter group that by default will also appear within a node\u0026rsquo;s context menu. They can be used for multiple purposes such as loading example data, applying an auto-configuration, opening websites, or displaying documentation or data in a new tab.\nTo create one, annotate a public function with @JIPipeDocumentation and @JIPipeContextAction. The function should have one parameter: an instance of JIPipeWorkbench.\n@JIPipeDocumentation(name = \u0026#34;Load example\u0026#34;, description = \u0026#34;Loads example parameters that showcase how to use this algorithm.\u0026#34;)\r@JIPipeContextAction(iconURL = ResourceUtils.RESOURCE_BASE_PATH + \u0026#34;/icons/actions/graduation-cap.png\u0026#34;)\rpublic void setToExample(JIPipeWorkbench parent) {\r// Insert code here\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/",
	"title": "Creating a data type",
	"tags": [],
	"description": "Explains how to create custom data types",
	"content": "Custom JIPipe data types must inherit from JIPipeData. It is required to add an @JIPipeDocumentation annotation that provides a name and brief description of the data type.\nJIPipe requires that data can be saved to a folder within the output directory. We also recommend that you include code that can load the data back into JIPipe or ImageJ in some form.\nThere are no requirements on the constructor of the data type. The only requirements are that there is a function importFrom(Path) that imports JIPipeData from a row storage folder, and an annotation of type @JIPipeStorageDocumentation that explains the structure of the storage folder.\nThe folder that is provided in storageFilePath is unique to the data and empty. The name parameter in storageFilePath is usually the data slot name and can be used as template for file names. It can be ignored undless forceName is true. The reason behind this is that then the name is pre-generated in a unique way for saving the data at a non-standard location (e.g. exporting the data). In such cases all file or folder names within the storage path should contain the name in some way, even if the import function cannot load the exported data anymore.\nThere are two optional functions that you can override:\n display() shows the data in ImageJ, JIPipe, or any other GUI preview() generates a GUI component that acts as thumbnail/preview of the contained data  @JIPipeDocumentation(name = \u0026#34;My data\u0026#34;, description = \u0026#34;This is some data\u0026#34;)\r@JIPipeStorageDocumentation(\u0026#34;Contains exactly one *.json file that stores the string value.\u0026#34;)\r// You can use @JIPipeHidden to hide this data from data type list UIs\rpublic class MyData implements JIPipeData {\rString value;\rpublic MyData() {\r}\r// Constructor that initializes the data\r public MyData(String value) {\rthis.value = value;\r}\r@JsonGetter(\u0026#34;value\u0026#34;)\rpublic String getValue() {\rreturn value;\r}\r@JsonSetter(\u0026#34;value\u0026#34;)\rpublic String setValue(String value) {\rthis.value = value;\r}\r// This should return a deep copy\r @Override\rpublic JIPipeData duplicate() {\rreturn new MyData(value);\r}\r// The display method is optional, but recommended\r @Override\rpublic void display(String displayName, JIPipeWorkbench workbench) {\rJIPipeTextEditor editor = JIPipeTextEditor.openInNewTab(workbench, displayName);\reditor.setMimeType(getMimeType());\reditor.setText(data);\r}\r// The preview method is optional, but recommended for many cases\r // The width and height are guidelines you should adhere to (especially the height)\r @Override\rpublic Component preview(int width, int height) {\r// This example would overlap with toString()\r return new JLabel(value);\r}\r// Do not forget to override this\r @Override\rpublic String toString() {\rreturn StringUtils.orElse(value, \u0026#34;\u0026#34;);\r}\r@Override\rpublic void saveTo(Path storageFilePath, String name, boolean forceName, JIPipeProgressInfo progress) {\rtry {\rJsonUtils.getObjectMapper().writeValue(storageFilePath.resolve(name + \u0026#34;.json\u0026#34;).toFile(), this);\r}\rcatch(Exception e) {\rthrow new RuntimeException(e);\r}\r}\r// We will use this method later to load the data back from disk\r public static MyData fromJson(Path jsonFile) {\rtry {\rreturn JsonUtils.getObjectMapper().readValue(jsonFile.toFile(), MyData.class);\r}\rcatch(Exception e) {\rthrow new RuntimeException(e);\r}\r}\r// Do not forget to add this method or JIPipe will refuse to start\r public static MyData importFrom(Path rowStorageFolder) {\r// You can use the PathUtils\r Path targetFile = PathUtils.findFileByExtensionIn(storageFilePath, \u0026#34;.json\u0026#34;);\rreturn fromJson(targetFile);\r}\r}\r\rYou can use JIPipe\u0026rsquo;s JsonUtils class to get access to a Jackson JSON ObjectMapper.\n\rDo not forget to override toString(), as the string representation will be displayed in the cache browser.\n\rTo register the data type and provide it with an id, and icon, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r// ... See previous tutorial for other methods\r @Override\rpublic void register() {\r// The two null parameters will be handled in the next tutorials\r // You can leave them null if you want. This is valid.\r registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null);\r}\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/annotations/",
	"title": "Data annotation algorithms",
	"tags": [],
	"description": "This library provides basic functionality to add annotations to data slot rows.",
	"content": "Data annotations allow JIPipe algorithms and users to assign an unique data set to the data located in a data slot. The standard library contains various algorithms that allow to generate, manipulate, and utilize those annotations.\nWe recommend to use the algorithms in Annotation \u0026gt; Generate while setting up filesystem operations or any other import step to prevent issues in following algorithm steps.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph/",
	"title": "Graph",
	"tags": [],
	"description": "A graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph.schema.json\n\rA graph\r\r\rnodes:\r\robject\r\r\r[object Object]\r\r\r\r\r\rThe nodes. Keys are the unique algorithm instance IDs.\rSee graph-node\r\r\r\r\r\r\r\redges:\r\robject[]\r\r\r\r\r\r\rThe edges. IDs in the edge definition must be consistent to the IDs in the 'nodes' entry\rSee graph-edge\r\r\r\r\r\r\r\r\r\r\rExample {\r\u0026#34;nodes\u0026#34; : {\r\u0026#34;default-preprocessing-filter-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Filtered files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 250\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;filters\u0026#34; : [ {\r\u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;,\r\u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34;\r} ],\r\u0026#34;jipipe:trait-generation\u0026#34; : {\r\u0026#34;modification\u0026#34; : {\r\u0026#34;per-slot\u0026#34; : { },\r\u0026#34;global\u0026#34; : { }\r},\r\u0026#34;transfer\u0026#34; : {\r\u0026#34;transfers\u0026#34; : [ ],\r\u0026#34;transfer-all-to-all\u0026#34; : true\r}\r},\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r},\r\u0026#34;default-preprocessing-list-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Folders\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 50\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;jipipe:trait-generation\u0026#34; : {\r\u0026#34;modification\u0026#34; : {\r\u0026#34;per-slot\u0026#34; : { },\r\u0026#34;global\u0026#34; : { }\r},\r\u0026#34;transfer\u0026#34; : {\r\u0026#34;transfers\u0026#34; : [ ],\r\u0026#34;transfer-all-to-all\u0026#34; : true\r}\r},\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r}\r},\r\u0026#34;edges\u0026#34; : [ {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;\r} ]\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/",
	"title": "JSON API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe JSON API that includes the API for creating JSON extensions, but also other data types like a project.\n\r Project file specification \r JSON extension file specification \r\rJSON objects The JSON API is object-oriented and re-uses different object types in multiple occasions. You will be referred to the specified documentation.\n Algorithm node\nNode in a graph\n\r Algorithm type\nDefines a new algorithm\n\r Dependency\nProject or extension dependency. Refers to an JIPipe extension.\n\r Graph Edge\nEdge in a graph\n\r Graph\nA graph\n\r Extension\nAn extension that can be put into the ImageJ plugin folder\n\r Metadata\nCommonly used metadata type in JIPipe.\n\r Point\nA point\n\r Project\nAn analysis project\n\r Slot definition\nDefines a data slot\n\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation/quick-run/",
	"title": "Running a single node",
	"tags": [],
	"description": "Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.",
	"content": "Many algorithms require plenty of user-defined parameters to create the expected results. Finding those parameters on the other hand can be very time-consuming due to the requirement of repeating all previous and following processing steps.\nJIPipe comes with a feature termed Quick Run that makes it easier to only test a part of an analysis pipeline. You can find the testbench by selecting an algorithm in the algorithm graph and selecting the  Quick Run tab.\nIt will ask for a folder where to store algorithm outputs. For most cases, you can leave the folder as is - but if you expect to generate large amounts of output data, you should select a folder on a drive that can store as much data. Click  Run \u0026amp; open results to create the testbench. JIPipe then will run the pipeline up until the selected algorithm and open a new tab.\nThe Quick Run expects that all relevant algorithms are valid and will tell you if it finds issues. Please fix the issues and click \u0026ldquo;Retry\u0026rdquo;.\n\rYou can also do a Quick Run from an algorithm\u0026rsquo;s right-click context menu. Here you will also find a related option called \u0026ldquo;Update cache\u0026rdquo; that just updates the cache of the selected node.\n\rIf you click  Run, the results will not be shown. Instead, if enabled, data will just be stored into the Cache\nResult UI After clicking  Run \u0026amp; open results and generating the results, JIPipe will open a new tab in its user interface. It contains a modified version of the result analysis interface that also allows you to change the algorithm parameters and create and load result snapshots of the current algorithm.\nThe user interface is separated into following components:\n The algorithm parameters of the selected algorithm are displayed on the left-hand side. You can change them and create a  New test The results are displayed in the result analysis panel. See the result analysis documentation for more information on how it is used. The testbench allows you to compare multiple parameter sets. On creating a  New test, the results from previous tests are accessible via the drop-down menu. You can also re-label the current parameter set by clicking the  button.  Testing a batch of parameters The testbench currently has not the capabilites to generate a set of parameters. We recommend to use the multi-parameter algorithm feature that was designed to manage parameter sets.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/cache/",
	"title": "Data caching",
	"tags": [],
	"description": "Explains the how JIPipe caches intermediate results and how to access them.",
	"content": "JIPipe has a project-wide cache for generated results. This cache can be accessed by algorithms to prevent repeating previous calculation steps.\nLoad data into the cache To cache data, right click a node and click  Update cache. This will execute a Quick run and store all results into the cache.\nAccessing the cache Cache items are assigned a unique identifier ( Snapshot) that is based on relevant algorithm parameters and the processing pipeline behind the data generation. You have multiple ways to manage and access the cache. First, in the top tool bar, there is a summary on how many items are currently cached. If items are stored in the cache, you have multiple options to clear the cache.\nIf you select an algorithm, you have access to its  Cache browser that lists all  Snapshots and all stored data, including a string representation, and annotations if available. By selecting a row in the data table below, you can  Show the item\u0026rsquo;s data. The operation depends on the exact data type. ImageJ images for example are opened in ImageJ.\nIf an algorithm data slot has cached data, icons appear next to the slot. Hover the items with your mouse to show a summary. Clicking the items allows you to manage the cache or display the results in a full-window cache browser.\nManaging the cache The cache consumes large amounts of memory, depending on the pipeline. Use the button at the top (menu bar) to clean all cached data or remove cached items that are invalid (e.g., because the node parameters were changed).\nYou can also enable the \u0026ldquo;Reduce memory\u0026rdquo; mode (bottom) to store unused data on the hard drive, or explicitly move cached items to the hard disk.\n"
},
{
	"uri": "https://www.jipipe.org/citation/",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nThe publication is currently in preparation. Please visit this page again later.\n\rThanks!\nJIPipe was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n   \n\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/parameter-type/",
	"title": "Creating a parameter type",
	"tags": [],
	"description": "Explains how to create an UI for a parameter",
	"content": "JIPipe requires you to register custom parameter types, where they are assigned an unique identifier. This is done to allow future refactoring without breaking a user\u0026rsquo;s project.\nA custom parameter type must be JSON-serializable via the Jackson library. It is associated to an editor UI that is responsible for updating the parameter value from the GUI.\nA parameter type cannot be a generic class. This is due to restrictions in the JVM. We recommend to create a sub-class for a list of a parameter if you require a list of it down the line. The list parameter inherits from the ListParameter class.\n\rCreating an editor To create an editor UI, you have to inherit from JIPipeParameterEditorUI.\nThe UI class provides access to the JIPipeParameterHolder object and the JIPipeParameterAccess object that encapsulates the getter and setters, as well as additional annotations.\nThere is also access to the SciJava context object.\nPlease be careful to avoid infinite loops between reloading and setting parameters from UI elements.\n\rRegistering a parameter Register the parameter type and its UI in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class)\rpublic class MyExtension extends JIPipeDefaultJavaExtension {\r// ... See previous tutorial for other methods\r @Override\rpublic void register() {\r// You have to provide an unique ID, the parameter class, a method to create a new instance, a method to create a deep copy, and an UI class\r registerParameterType(\u0026#34;my-parameter\u0026#34;,\rMyParameter.class,\rMyParameter::new,\rp -\u0026gt; p.clone(),\r\u0026#34;My parameter\u0026#34;,\r\u0026#34;A custom parameter type\u0026#34;,\rMyParameterParameterEditorUI.class);\r// If you have a hierarchy of parameters, you can register the editor for the whole hierarchy:\r registerParameterEditor(MyCollectionBase.class, MyCollectionParameterEditorUI.class);\r// There is a predefined method to register enum values:\r registerEnumParameterType(\u0026#34;my-enum\u0026#34;, MyEnum.class, \u0026#34;My Enum\u0026#34;, \u0026#34;Enum of values\u0026#34;);\r}\r}\r\rDo not forget to register all algorithm parameter types. JIPipe will throw an error if it detects a missing parameter registration.\n\rThere is an overload of registerParameterType that takes the matching list directly and automatically generates the ID, name, and description.\n\rYou can set the instance creation function to null if the parameter is default-constructable. You can set the clone function to null if the parameter type can be copied via a copy constructor.\n\rYou can review your parameter UI via Tools \u0026gt; Development \u0026gt; Show all parameter types.\n\rMaking use of the parameter registration You can use the parameter type registry to get a parameter type info. The info provides access to all metadata from the registry.\nJIPipe comes preinstalled with some common Java types (String, numerics, file and folder paths). You can take a look at the Parameters Extension package for all default parameters that are provided by JIPipe.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/json-extension/",
	"title": "Extension",
	"tags": [],
	"description": "An extension that can be put into the ImageJ plugin folder",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: json-extension.schema.json\n\rAn extension that can be put into the ImageJ plugin folder\r\r\rid:\r\rstring\r\r\r\r\r\r\rUnique ID of this extension. Should have format\r\r.\r\r:\r\r\r\r\r\r\rversion:\r\rstring\r\r\r\r\r\r\rVersion of this extension\r\r\rmetadata:\r\rSee metadata\r\r\r\r\r\r\r\rGeneral metadata about the extension\r\r\ralgorithms:\r\robject[]\r\r\r\r\r\r\rList of added algorithms\rSee algorithm\r\r\r\r\r\r\r\r\r\r\rExample {\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:example-list-tiff\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Example extension\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;An example extension\u0026#34;,\r\u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;,\r\u0026#34;website\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;algorithms\u0026#34; : [ {\r\u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;,\r\u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;,\r\u0026#34;website\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;,\r\u0026#34;graph\u0026#34; : {\r\u0026#34;nodes\u0026#34; : {\r\u0026#34;default-preprocessing-filter-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Filtered files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 250\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;filters\u0026#34; : [ {\r\u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;,\r\u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34;\r} ],\r\u0026#34;jipipe:trait-generation\u0026#34; : {\r\u0026#34;modification\u0026#34; : {\r\u0026#34;per-slot\u0026#34; : { },\r\u0026#34;global\u0026#34; : { }\r},\r\u0026#34;transfer\u0026#34; : {\r\u0026#34;transfers\u0026#34; : [ ],\r\u0026#34;transfer-all-to-all\u0026#34; : true\r}\r},\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r},\r\u0026#34;default-preprocessing-list-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;Folders\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Files\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;{Vertical}\u0026#34; : {\r\u0026#34;x\u0026#34; : 25,\r\u0026#34;y\u0026#34; : 50\r}\r},\r\u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;,\r\u0026#34;description\u0026#34; : null,\r\u0026#34;jipipe:trait-generation\u0026#34; : {\r\u0026#34;modification\u0026#34; : {\r\u0026#34;per-slot\u0026#34; : { },\r\u0026#34;global\u0026#34; : { }\r},\r\u0026#34;transfer\u0026#34; : {\r\u0026#34;transfers\u0026#34; : [ ],\r\u0026#34;transfer-all-to-all\u0026#34; : true\r}\r},\r\u0026#34;jipipe:dynamic-parameters\u0026#34; : { }\r}\r},\r\u0026#34;edges\u0026#34; : [ {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;\r} ]\r},\r\u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;,\r\u0026#34;preferred-traits\u0026#34; : [ ],\r\u0026#34;unwanted-traits\u0026#34; : [ ],\r\u0026#34;added-traits\u0026#34; : [ ],\r\u0026#34;removed-traits\u0026#34; : [ ]\r} ],\r\u0026#34;dependencies\u0026#34; : [ {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;,\r\u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;,\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r} ],\r\u0026#34;jipipe:project-type\u0026#34; : \u0026#34;json-extension\u0026#34;\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Explains functionality that allows ImageJ to run JIPipe algorithms or pipelines.",
	"content": "ImageJ to JIPipe JIPipe integrates commonly used data types and popular algorithms from ImageJ. If an algorithm is not available for JIPipe, you can still run them via the Macro node. There is also a Python script node available that behaves similar to the macro node.\nJIPipe to ImageJ JIPipe algorithms and pipelines can be executed from within an ImageJ environment. There are two ways JIPipe integrates back into ImageJ:\n You can run a pipeline project from a macro/command You can run JIPipe algorithms from a macro/command if the slot data types are supported by ImageJ  Running a pipeline You can run an JIPipe pipeline via the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe project. It will ask you the project file and the output directory.\nTo run the command via a macro, run:\nrun(\u0026quot;Run JIPipe project\u0026quot;, \u0026quot;projectFile=\u0026lt;Project\u0026gt;, outputDirectory=\u0026lt;Directory\u0026gt;, threads=\u0026lt;Threads\u0026gt;\u0026quot;)\r\rThere can be issues using the macro recorder depending on which ImageJ algorithms are used. This issue is especially prevalent in ImageJ macro algorithm nodes.\n\rYou can also run JIPipe in headless-mode just like any ImageJ2 algorithm:\n./ImageJ-linux64 --headless --ij2 --run \u0026#34;Run JIPipe project\u0026#34; \u0026#39;projectFile=\u0026#34;\u0026lt;Project\u0026gt;\u0026#34;, outputDirectory=\u0026#34;\u0026lt;Directory\u0026gt;\u0026#34;, threads=\u0026lt;Threads\u0026gt;\u0026#39;\r\rWhile JIPipe works in Headless-mode, some ImageJ algorithms don\u0026rsquo;t. You will get an error message if an algorithm requires a graphical environment.\n\rRunning a single algorithm JIPipe algorithms can be run from ImageJ macros/commands if the slot data types are compatible with ImageJ. By default, this includes any image data type, result tables, and regions of interest (via ROIManager). If you run the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe algorithm, a dialog with all available algorithms, parameters, and more information is shown.\nA difference to the parameter panel of an algorithm within the graph editor UI is that you have to select the input image.\nOutput data is created according to the slot name. For example if the output slot name is Output, the created image window will also be named Output.\nJust as in a graph, images are converted automatically to the data type specified by the algorithm.\n\rThere may be issues if multiple ROI or result table outputs are generated. JIPipe will merge multiple ROI List data items into one Results Table.\n\rThere can be issues using the macro recorder depending on which ImageJ algorithm is executed. This issue is especially prevalent in ImageJ macro algorithm nodes.\n\rTo run the command via a macro, run:\nrun(\u0026quot;Run JIPipe algorithm\u0026quot;, \u0026quot;nodeId=\u0026lt;Algorithm\u0026gt;, parameters=\u0026lt;Parameters\u0026gt;\u0026quot;)\rThe algorithm ID can be looked up via the plugin manager. Parameters are provided as string in JSON format. The JSON data should have following structure:\n (Optional) An object parameters that contains the algorithm parameters. They are equal to the parameters saved in an JIPipe project file. We recommend to use the Copy command button to obtain the parameters. If you leave out parameters, the default value is assumed. (Optional) An object add-input that contains additional input slot definitions. The entry keys are the slot names. (Optional) An object add-output that contains additional output slot definitions. The entry keys are the slot names. (Optional) An object input. Entry keys correspond to the slot name. The entry value is a string that corresponds to the Window name that contains the data. Only required for image data types, as JIPipe accesses the global ROI manager and global result table.  Use the \u0026ldquo;Copy command\u0026rdquo; button in the \u0026ldquo;Run JIPipe algorithm\u0026rdquo; GUI command to quickly create a valid macro for your parameters.\n\rIf you are a developer of a JIPipe node (Java only) and want to provide your node as separate entry in the ImageJ menu, you can use our Java API to create custom SciJava commands that provide a similar UI to the single algorithm run. You just have to inherit from JIPipeRunCustomAlgorithmCommand and provide the constructor with the node ID. Then add the Plugin annotation just as with any SciJava command.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/plugins/",
	"title": "Managing plugins",
	"tags": [],
	"description": "Explains how to install and manage plugins.",
	"content": "JIPipe has its own plugin (extension) system that is independent of the one provided by ImageJ/SciJava. You can find a list of plugins in Plugins \u0026gt; Manage plugins.\nJIPipe by default supports two types of extensions:\n Java extensions are similar to ImageJ plugins (*.jar) and are the most powerful plugin type. Just like ImageJ plugins, they are located in the plugins directory. JSON plugins are similar to ImageJ macros or scripts, as they are pure text files. Such extensions can be created without programming via the JSON Extension Builder  Some plugins require that dependencies are installed and will notify you if something is wrong. To check if all plugins are in working condition, check if the top right button displays  All plugins valid. Otherwise click the button to show what went wrong and how to solve the issue.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/plots-tables/",
	"title": "Plots and tables",
	"tags": [],
	"description": "This library provides operations to generate and modify tables, as well as creating plots.",
	"content": "The standard library contains algorithms and data types that allows to manipulate tables, and create plots. The table data type is the JIPipe wrapper for the ImageJ results table (see ImageJ integration).\nManipulating tables Table manipulation operations are located in Process \u0026gt; Tables and allow you to add, remove, or replace columns.\nCreating plots Plots can be created via the Analyze \u0026gt; Plot \u0026gt; Plot tables algorithm that processes each incoming result table and produces an automatically generated plot. You can decide which plot type is generated, and how to assign the columns of the input tables to the data series as expected by the plot. Plots are exported automatically as PNG and SVG in the size set up within the algorithm node settings.\nYou can later import the plot back into the JIPipe plot editor that has more options available.\nPlot editor JIPipe comes with a plot editor GUI that allows more refined control over plots than by the standard Plot tables algorithm (for example multiple series). You can either open a plot from results, or create a new plot from scratch via Project \u0026gt; New plot.\nThe settings panel of the plot editor is split into three tabs:\n  Settings contains all general parameters of the plot. It also allows you to change the plot type.  Series contains all data series. A series is a collection of string or number arrays that is used as input for the plot. Depending on the plot type, there can be multiple series (e.g. the line XY plot can display multiple lines)  Data contains a list of data columns that can be assembled to series. You can open the columns in the table editor or import columns from a CSV file. JIPipe also supports generating columns that do not carry any data, but instead generate the requested number of rows.  Table editor While JIPipe prefers opening tables in ImageJ\u0026rsquo;s table view, it contains a table editor that allows you to do basic operations directly from within JIPipe.\nYou can find the operations on the right-hand side. They include some basic operations like modifying rows and columns, and specialized operations for scientific data, such as splitting values by category, quickly integrating the table, and combining columns into a single condition column.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/jython/",
	"title": "Jython integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts via the Jython library",
	"content": "The standard library contains nodes that allow to run Python scripts using the Jython library. Python scripts have access to all JIPipe and ImageJ APIs that are available at runtime.\n\rDue to restrictions in the Jython library, Python libraries that are built on a native backend (such as Numpy) will not work.\n\rAs JIPipe builds on the functionality provided by ImageJ. Please refer to the ImageJ documentation to find information on how to expand Jython with additional libraries.\n\rYou can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Node Based on Purpose     Jython script JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   Jython script (simple iterating) JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   Jython script (iterating) JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   Jython script (merging) JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Common functions All Python script nodes share a set of variables that are available in the code:\n   Variable Purpose     input_slots A list of all effective input slots. This means, slots like the \u0026lsquo;Parameters\u0026rsquo; slot are not listed here. Each slot is using the Jython API to access the native Java data type. Refer to the JIPipeDataSlot documentation for further information.   output_slots A list of all output slots. Each slot is using the Jython API to access the native Java data type. Refer to the JIPipeDataSlot documentation for further information.   input_slot_map A dictionary from input slot name to input slot instance.   output_slot_map A dictionary from output slot name to output slot instance.    Data batch access Python nodes based on JIPipeSimpleIteratingAlgorithm, JIPipeIteratingAlgorithm, and JIPipeMergingAlgorithm repeat the script for each data batch (or at least once if there is none). Data batches organize the data of various input slots into one bundle that should be processed. Access to this data batch is provided via a variable data_batch.\nThis variable points to an instance of JIPipeDataBatch (or JIPipeMergingDataBatch for the merging algorithm).\nScript parameters Each node provides means to define Python variables inside the JIPipe environment via custom parameters. Each parameter value is passed as variable into Python - the name of the variable being determined by the unique ID of the parameter.\nAll Python nodes are multi-parameter capable (including iterating and merging nodes). \u0026ldquo;Jython script (multi-parameter capable)\u0026rdquo; provides a unique variable parameter_annotations that contains any annotations of the current parameter set.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/metadata/",
	"title": "Metadata",
	"tags": [],
	"description": "Commonly used metadata type in JIPipe.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: metadata.schema.json\n\rCommonly used metadata type in JIPipe.\r\r\rname:\r\rstring\r\r\r\r\r\r\rA name\r\r\rdescription:\r\rstring\r\r\r\r\r\r\rA description\r\r\rauthors:\r\rstring\r\r\r\r\r\r\rComma-separated list of authors\r\r\rwebsite:\r\rstring\r\r\r\r\r\r\rWebsite of the project\r\r\rlicense:\r\rstring\r\r\r\r\r\r\rName of the license\r\r\rcitation:\r\rstring\r\r\r\r\r\r\rCitation for the publication\r\r\r\r\r\rExample {\r\u0026#34;name\u0026#34; : \u0026#34;Image property annotations\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Commonly used annotations for describing image properties\u0026#34;,\r\u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;,\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/usage-in-java/",
	"title": "Usage in Java",
	"tags": [],
	"description": "Explains how to use the JIPipe API to run graphs, algorithms, or projects within pure java code",
	"content": "The JIPipe API allows you to run algorithms, graphs, and projects in a pure Java environment without the need for a GUI or through ImageJ1 or ImageJ2 scripts.\nPrerequisites To use the JIPipe API JIPipe must be initialized first. This requires an ImageJ instance or any other way to load SciJava plugins. The following example shows how to initialize JIPipe.\npublic static void main(String[] args) {\r// Extract necessary SciJava variables\r // An alternative is to create a @Plugin and execute this plugin via ImageJ\r final ImageJ ij = new ImageJ();\rContext context = ij.context();\r// Execute the JIPipe registration if necessary\r if (JIPipe.getInstance() == null) {\rJIPipe.createInstance(context);\rJIPipe.getInstance().initialize();\r}\r// JIPipe is now ready to use\r}\rLoading and running a project You can load a project via a static method. Running the project either involves enqueuing a run into the global queue or running it on the current thread. The run has a multitude of settings that control how/if output is written or how many threads are used.\npublic static void main(String[] args) {\r// First initialize JIPipe before this line!\r\r// Load the project\r // JIPipe will put any non-exception errors or warnings into the report\r JIPipeValidityReport report = new JIPipeValidityReport();\rJIPipeProject project = JIPipeProject.loadProject(Paths.get(\u0026#34;my-project.jip\u0026#34;), report);\r// Create a run that generates a deep-copy of the project\u0026#39;s graph\r // The run is controlled by the JIPipeRunSettings instance that allows you to\r // have runs without caching or writing outputs if needed\r JIPipeRunSettings settings = new JIPipeRunSettings();\rsettings.setOutputPath(Paths.get(\u0026#34;/data/my-project-output\u0026#34;));\rJIPipeRun run = new JIPipeRun(project, settings);\r// Option 1: Run in separate thread (Async)\r JIPipeRunnerQueue.getInstance().enqueue(run);\r// Option 2: Run it on the current thread\r // The run itself has a property getProgressInfo() that allows access to the progress \u0026amp; log\r run.run();\r}\rLoading a result To load an existing result folder, the run is imported back into JIPipe. The run itself contains a graph instance with nodes that are aware of the data storage location. The storage location contains a data-table.json file that can be imported into an exported data table. This table contains all metadata and the relative storage location of each row.\nRow data is always stored in folders that correspond to the row index. For example, the first row\u0026rsquo;s data is stored in a folder 0.\npublic static void main(String[] args) {\r// First initialize JIPipe before this line!\r\r// Load the run\r // It will load the project as well\r Path path = Paths.get(\u0026#34;/data/my-project-output\u0026#34;);\rJIPipeRun run = JIPipeRun.loadFromFolder(path, report);\rrun.getProject().setWorkDirectory(path);\r// You can now access the run\u0026#39;s graph and access the data slots\r JIPipeDataSlot slot = run.getGraph().getNodes().get(\u0026#34;some-node\u0026#34;).getOutputSlot(\u0026#34;Output\u0026#34;);\r// Load the slot\u0026#39;s data table\r JIPipeExportedDataTable table = slot.getStorageDataTable();\r// Example: Get the folder where the first row stores its data\r Path firstRowStorage = slot.getRowStoragePath(0);\r}\rBuilding and running a graph JIPipe allows to create and run graphs without involving a project. A simple graph runner is available to execute a graph.\npublic static void main(String[] args) {\r// First initialize JIPipe before this line!\r\rJIPipeGraph graph = new JIPipeGraph();\r// There are multiple ways to instantiate a new node:\r\r// Option 1: Utility function\r JIPipeGraphNode first = JIPipe.createNode(\u0026#34;import-file\u0026#34;, JIPipeGraphNode.class);\r// Option 2: Using the registry\r JIPipeGraphNode second = JIPipeNodeRegistry.getInstance().getInfoById(\u0026#34;import-imagej-imgplus-from-file\u0026#34;).newInstance();\r// Add the nodes into the graph and connect them\r graph.insertNode(first, JIPipeGraph.COMPARTMENT_DEFAULT);\rgraph.insertNode(second, JIPipeGraph.COMPARTMENT_DEFAULT);\rgraph.connect(first, second);\r// Use the graph runner\r // We always recommend to make a copy of the graph if it is used somehere else\r JIPipeGraphRunner run = new JIPipeGraphRunner(new JIPipeGraph(graph));\r// Option 1: Run in separate thread (Async)\r JIPipeRunnerQueue.getInstance().enqueue(run);\r// Option 2: Run it on the current thread\r // The run itself has a property getProgressInfo() that allows access to the progress \u0026amp; log\r run.run();\r}\rRunning a single node You can run single algorithm nodes without involving a project or a graph:\npublic static void main(String[] args) {\r// First initialize JIPipe before this line!\r\rJIPipeSimpleIteratingAlgorithm node = JIPipe.createNode(\u0026#34;import-imagej-imgplus-from-file\u0026#34;, JIPipeSimpleIteratingAlgorithm.class);\r// Always clear the node first (allows you to re-use it)\r node.clearSlotData();\r// Add inputs\r node.getFirstInputSlot().addData(new FileData(Paths.get(\u0026#34;/data/image.tif\u0026#34;)));\r// The node requires a progress info  JIPipeProgressInfo progress = new JIPipeProgressInfo();\r// Run the node\r node.run(progress);\r// Extract the output\r ImagePlusData image = node.getFirstOutputSlot().getData(0, ImagePlusData.class);\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/python/",
	"title": "Python integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts.",
	"content": "The standard library contains nodes that allow to run Python scripts using an existing installation of Python. This means you will need to download Python, Anaconda, or Miniconda.\nSetting up Python If not already done, please install Python. Then open JIPipe and navigate to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; Python integration.\nDepending on the used Python distribution, you will need to put in different settings:\nStandard Python If you use the global System Python from https://www.python.org/ (No virtualenv), set Python executable to the main Python executable (python.exe).\nSet Python arguments to ARRAY(script_file).\nConda If you use a Python distribution provided by Anaconda or Miniconda, you need to set Python executable to conda.exe. You will find it in the Conda installation folder (e.g., Scripts/conda.exe on Windows).\nSet Python arguments to ARRAY(\u0026quot;run\u0026quot;, \u0026quot;-n\u0026quot;, \u0026quot;base\u0026quot;, \u0026quot;python\u0026quot;, script_file). Please note the that script_file is not quoted. You can replace \u0026ldquo;base\u0026rdquo; by the name of another Conda environment if needed.\nvirtualenv virtualenv environments do not have a way to run scripts directly (like Conda does). You can try to set Python executable to the Python executable contained in the environment (e.g., Scripts/python.exe on Windows). Set Python arguments to ARRAY(script_file).\nIf this does not work, you will need to write a wrapper script (bat/sh) file that activates the environment before running the script. Please ensure that script_file is always passed in some way.\nIncluded nodes You can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Node Based on Purpose     Python script JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   Python script (simple iterating) JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   Python script (iterating) JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   Python script (merging) JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Common functions All Python script nodes share a set of variables that are available in the code:\n   Variable Purpose     jipipe_inputs A dict of slot name to an instance of DataSlot. Each item represents the input data of the current data batch/current input.   jipipe_outputs A dict of slot name to an instance of DataSlot. Each item represents the output data of the current data batch/current output.    Data I/O Python nodes based on JIPipeSimpleIteratingAlgorithm, JIPipeIteratingAlgorithm, and JIPipeMergingAlgorithm repeat the script for each data batch (or at least once if there is none). Data batches organize the data of various input slots into one bundle that should be processed.\nData access is handled through temporary folders that contain input/output data in JIPipe standardized format. The nodes are supplied with a Python API that allows to read/write data and metadata in this format.\nYou can choose to not use the reading/writing functions provided by this package and access the input/output folders directly.\nEach JIPipe data type provides information about the structure of the data folder. You can find it in [?] \u0026gt; Data type compendium.\n\rScript parameters Each node provides means to define Python variables inside the JIPipe environment via custom parameters. Each parameter value is passed as variable into Python - the name of the variable being determined by the unique ID of the parameter.\nAll Python nodes are multi-parameter capable (including iterating and merging nodes). \u0026ldquo;Python script (multi-parameter capable)\u0026rdquo; provides a unique variable parameter_annotations that contains any annotations of the current parameter set.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/point/",
	"title": "Point",
	"tags": [],
	"description": "A point",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: point.schema.json\n\rA point\r\r\rx:\r\rinteger\r\r\r\r\r\r\rX coordinate\r\r\ry:\r\rinteger\r\r\r\r\r\r\rY coordinate\r\r\r\r\r\rExample {\r\u0026#34;x\u0026#34; : 2900,\r\u0026#34;y\u0026#34; : 100\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/r-integration/",
	"title": "R integration",
	"tags": [],
	"description": "This library provides nodes that allow to run R scripts.",
	"content": "The standard library contains nodes that allow to run R scripts using the RCaller library that allows to run any existing R installation. This means that you will need to install a distribution of R.\nYou will need to install R (https://www.r-project.org/) and setup JIPipe to find this installation.\n\rSetting up R If not already done, please install R. Then open JIPipe and navigate to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; R integration.\nHere you will find two settings Override R executable and Override RScript executable. Check if both point to the correct R executables. If they are empty or the paths do not exist, please set them to the correct paths:\n The R executable should point to R.exe (Windows) or R (RScript). Example: C:\\Program Files\\R\\R-4.0.4\\bin\\R.exe or /usr/bin/R The RScript executable should point to RScript.exe (Windows) or RScript (Linux). Example: C:\\Program Files\\R\\R-4.0.4\\bin\\RScript.exe or /usr/bin/RScript  Included nodes You can find the R scripting nodes in the Miscellaneous menu. You can find algorithms equivalent to following Java standard algorithms:\n   Node Based on Purpose     R script (iterating) JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   R script (merging) JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Both nodes share a similar R API to communicate with JIPipe - the difference being how many data items can be processed in each iteration. All nodes repeat the script for each data batch (or at least once if there is none). Data batches organize the data of various input slots into one bundle that should be processed.\nData I/O As R is run in a separate environment, the data is communicated by writing it to the hard drive from one process and reading it back inside the other process. Currently, the nodes are designed for following data types:\n   Data type As input As output     Results table Provided as CSV file or data frame Saved as single CSV file. JIPipe will load this CSV file.   Colored Image (RGB) Not supported Saved as single PNG/TIFF/JPG. JIPipe will load the image.    Other data types are supported, although there are no predefined utility functions to load/save them for now.\nLoading results tables Result tables can be loaded via the JIPipe.GetInputAsDataFrame(slot, row=0) function. The slot parameter must be identical to the name of the input slot. The row parameter indicates which item of the current data batch should be returned. Please note that row can only be zero if you are using R script (iterating).\nIf you have multiple rows, you can find their count in JIPipe.InputSlotRowCounts\nfor( i in 1:JIPipe.InputSlotRowCounts$Tables) {\r# Note that the row has zero-based indices\r table \u0026lt;- JIPipe.GetInputAsDataFrame(slot=\u0026#34;Tables\u0026#34;, row=i-1)\r}\rWriting result tables Result tables can be written via a function JIPipe.AddOutputDataFrame(data, slot, annotations=list()). This will add a new result table to the specified output. Please note, that you can add multiple outputs.\nThe provided data must be of a type compatible with write.csv, like data.frame.\nOptionally, you can provide a list of annotations that should be added to the specified output data as list of named strings.\nlibrary(datasets)\rJIPipe.AddOutputDataFrame(iris, \u0026#34;Tables\u0026#34;, annotations=list(\u0026#34;data set\u0026#34;=\u0026#34;Iris\u0026#34;))\rWriting plots or other images As R does not have a dedicated data type for images, the JIPipe API will only provide means to generate a valid output file name. For this, two methods JIPipe.AddOutputPNGImagePath(data, slot, annotations=list()) and JIPipe.AddOutputTIFFImagePath(data, slot, annotations=list()) are available that produce a path for PNG or TIFF files respectively.\nWe recommend to use the \u0026lsquo;Image (RGB)\u0026rsquo; or any other RGB output type. This is due to the R behavior of generating images with indexed colors that are detected as greyscale images by JIPipe.\n\rlibrary(datasets)\r# Generate the output file name\r png.file.name \u0026lt;- JIPipe.AddOutputPNGImagePath(slot=\u0026#34;Plot\u0026#34;)\r# Use standard R functions. Write into this file.\r png(png.file.name, width = 800, height = 600)\rplot(iris$Petal.Length, iris$Petal.Width, pch=21, bg=c(\u0026#34;red\u0026#34;,\u0026#34;green3\u0026#34;,\u0026#34;blue\u0026#34;)[unclass(iris$Species)], main=\u0026#34;Edgar Anderson\u0026#39;s Iris Data\u0026#34;)\rdev.off()\r# JIPipe will automatically load the data\r Reading and writing other data types Currently, only reading and writing of tables, as well as writing of image data is supported via convience functions. The node supports all other JIPipe data types, although import and export must be written via custom functions.\nJIPipe provides the input of each data item via a dedicated folder that contains all files related to this data. Use JIPipe.GetInputFolder(slot, row=0) get obtain the path to this folder.\nOutputs are also expected to be provided in standardized JIPipe format. Use JIPipe.AddOutputFolder(slot, annotations=list()) to obtain a valid path to such a folder and register the output.\nEach JIPipe data type provides information about the structure of the data folder. You can find it in [?] \u0026gt; Data type compendium.\n\rScript parameters Each node provides means to define R variables inside the JIPipe environment via custom parameters. Each parameter value is passed as variable into R - the name of the variable being determined by the unique ID of the parameter.\nIndependent of the compatibility of a parameter\u0026rsquo;s unique key, all variables are also provided as named list entries in JIPipe.Variables.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/",
	"title": "Standard library",
	"tags": [],
	"description": "Contains some explanations about the algorithms that are included in the JIPipe standard distribution.",
	"content": "JIPipe comes with a standard library of data types, algorithms, and other functionality that makes it ready to use for most common image analysis projects. The library of course can be extended with plugins.\nPlease take a look at the following standard library components:\n ImageJ integration\nThis library provides integration of ImageJ data types, as well as common ImageJ algorithms.\n\r Macro node\nThe macro node allows to run ImageJ macros.\n\r Filesystem algorithms\nThis library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.\n\r Multi-parameter algorithms\nThis library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.\n\r Data annotation algorithms\nThis library provides basic functionality to add annotations to data slot rows.\n\r Plots and tables\nThis library provides operations to generate and modify tables, as well as creating plots.\n\r Jython integration\nThis library provides nodes that allow to run Python scripts via the Jython library\n\r Python integration\nThis library provides nodes that allow to run Python scripts.\n\r R integration\nThis library provides nodes that allow to run R scripts.\n\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation/create-json-extensions/",
	"title": "Extension builder",
	"tags": [],
	"description": "Explains the extension builder tool",
	"content": "JIPipe allows the creation of extensions that contain additional algorithms without the need for writing Java code. We recommend starting from a functional pipeline project and export the whole pipeline or a part of it into a JSON Extension. Alternatively, you can create custom algorithms from scratch within the extension builder.\nIf you want a step-by-step guideline on how to create a custom algorithm, please check out our tutorial.\nExporting from an existing pipeline Within the JIPipe interface, you can find contextual menu items and buttons that allow to generate an exported algorithm.\n To export the whole pipeline as algorithm, select Project \u0026gt; Export as custom algorithm To export a graph compartment, select it and click the Export button at the top-right corner. Then select  As custom algorithm To export a selection of nodes, click the Export button at the top-right corner. JIPipe ensures that connections within the selected nodes are exported as well. To export a single algorithm, click the Export button at the top-right corner. Please note that if the algorithm is a  Group algorithm, the group contents are exported instead of the group iself.  This will open a tab showing a preview of the pipeline. Select Export to extension to copy the custom algorithm into a new or existing extension.\n\rTo open a new extension builder or load a JSON extension, you can use Plugins \u0026gt; New JSON extension ...\r\rThe extension builder The extension builder opens three tabs:\n A short introduction A tab that allows you to change the extension settings and metadata A tab that lists all algorithms that are part of the extension  Extension settings All extension metadata can be changed from within this tab. There are only three fields that are mandatory and one where you have to put special care in deciding about the value:\n Unique extension ID is the most important field. It contains a unique identifier that is utilized by JIPipe to figure out project and algorithm dependencies. It must have following format: [Author]:[Id] where [Author] contains information about the author (ideally in Maven-compatible format) and [Id] is the identifier if this extension within the author\u0026rsquo;s group. Version is not used by JIPipe but can be helpful for users to find issues Name is displayed in the plugin manager  You can write anything you want into the other metadata fields or leave them out.\nExtension contents This interface allows you to manage the list of algorithms that are contained within the extension. If you want, you can also create algorithms from scratch (although we do not recommend this as you cannot test pipelines within the extension builder). On selecting an algorithm, you can edit its metadata.\n Algorithm ID is the most important field. It uniquely identifies the algorithm within JIPipe. The ID is not namespaced (meaning that it is independent of the extension ID). We recommend to choose a meaningful name that can be easily expanded for specialized algorithms. Category determines in which menu the algorithm is shown. Please note that if you select DataSource, the algorithm will be placed in a menu based on the output data type. Choosing Internal is not allowed.  You can edit the graph that defines the algorithm\u0026rsquo;s workload by clicking  Edit algorithm. Use this to modify the pipeline to your needs and change parameters. Please note that you cannot test the pipeline.\n\rWe recommend to check if you have some parameters that are invalid or dangerous (e.g. file paths that were copied when exportiong from a project). You algorithms should always\rhave sane defaults.\r\rExporting parameters By default (this excludes exporting from a  Group algorithm) your algorithm will not have any parameters aside of the default ones (name, description, pass-though, and enabled). The extension builder comes with a powerful editor to reference parameters within the algorithm\u0026rsquo;s graph.\nExported parameters are organized in Groups with each group having a title and optional description. Each group holds a collection of parameter references that can be assigned a custom name and description. Click  Add group to create a new empty group or use the  Auto add algorithm button to import parameters from a node and automatically create groups.\nIn a group, you can use the  Add parameter button to create a reference.\n\rHover over the blue  wrench icon to display information about the referenced parameter.\r\r\rEach parameter can only be referenced once. You will get a warning if you have duplicate references. If you ignore the warning, JIPipe will just skip them when creating the parameter UI.\r\r\rThe parameter editor UI implements a sub-set of the parameter reference standard to prevent overloading the UI. You always can change the JSON file to control additional properties like\ra manual order of the parameter items.\r\r"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/project/",
	"title": "Project",
	"tags": [],
	"description": "An analysis project",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: project.schema.json\n\rAn analysis project\r\r\rjipipe:project-type:\r\rstring\r\r, x ∈ {\rproject\r\r(default)\r}\r\r\r\r\r\r\rUsed to identify this JSON as JIPipe project\r\r\rmetadata:\r\rSee metadata\r\r\r\r[object Object]\r\r\r\r\r\rGeneral information about the project\r\r\rdependencies:\r\robject[]\r\r\r\r\r\r\rDependencies of this project\rSee dependency\r\r\r\r\r\r\r\rgraph:\r\rSee graph\r\r\r\r[object Object]\r\r\r\r\r\rContains the pipeline nodes\r\r\rcompartments:\r\robject\r\r\r[object Object]\r\r\r\r\r\rFor organization of compartments\r\rcompartment-graph:\r\rSee graph\r\r\r\r[object Object]\r\r\r\r\r\rStructural graph of compartments\r\r\r\r\r\r\r\r\r\rExample {\r\u0026#34;jipipe:project-type\u0026#34; : \u0026#34;project\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Empty (3 compartments)\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;This template contains three compartments \u0026#39;Preprocessing\u0026#39;, \u0026#39;Analysis\u0026#39;, and \u0026#39;Postprocessing\u0026#39; that are connected to each other.\u0026#34;,\r\u0026#34;authors\u0026#34; : [ ],\r\u0026#34;website\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;dependencies\u0026#34; : [ {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Standard plots\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Commonly used plot types\u0026#34;,\r\u0026#34;authors\u0026#34; : [ {\r\u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34;\r}, {\r\u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34;\r} ],\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:plots\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r}, {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;ImageJ algorithms\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Integrates ImageJ algorithms into JIPipe\u0026#34;,\r\u0026#34;authors\u0026#34; : [ {\r\u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34;\r}, {\r\u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34;\r} ],\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-algorithms\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r}, {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;,\r\u0026#34;authors\u0026#34; : [ {\r\u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34;\r}, {\r\u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34;\r} ],\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r}, {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Compartment management\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Data types required for graph compartment management\u0026#34;,\r\u0026#34;authors\u0026#34; : [ {\r\u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34;\r}, {\r\u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34;\r} ],\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:compartments\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r}, {\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;ImageJ integration\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Adds support for commonly used ImageJ data types\u0026#34;,\r\u0026#34;authors\u0026#34; : [ {\r\u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34;\r}, {\r\u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;,\r\u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;,\r\u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34;\r} ],\r\u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;,\r\u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;,\r\u0026#34;citation\u0026#34; : \u0026#34;\u0026#34;\r},\r\u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-integration\u0026#34;,\r\u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;\r} ],\r\u0026#34;additional-metadata\u0026#34; : {\r\u0026#34;pipeline-parameters\u0026#34; : {\r\u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;,\r\u0026#34;exported-parameters\u0026#34; : {\r\u0026#34;parameter-reference-groups\u0026#34; : [ ]\r}\r},\r\u0026#34;org.hkijena.jipipe:pipeline-parameters\u0026#34; : {\r\u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;,\r\u0026#34;exported-parameters\u0026#34; : {\r\u0026#34;parameter-reference-groups\u0026#34; : [ ]\r}\r},\r\u0026#34;org.hkijena.jipipe.ui:project-tabs\u0026#34; : {\r\u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.project.JIPipeProjectTabMetadata\u0026#34;,\r\u0026#34;data\u0026#34; : {\r\u0026#34;open-tabs\u0026#34; : [ \u0026#34;singleton:INTRODUCTION\u0026#34;, \u0026#34;singleton:COMPARTMENT_EDITOR\u0026#34;, \u0026#34;graph-compartment:preprocessing\u0026#34;, \u0026#34;graph-compartment:analysis\u0026#34;, \u0026#34;graph-compartment:postprocessing\u0026#34; ],\r\u0026#34;selected-tab\u0026#34; : null\r}\r}\r},\r\u0026#34;graph\u0026#34; : {\r\u0026#34;nodes\u0026#34; : {\r\u0026#34;preprocessing-folder-list\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;preprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 400,\r\u0026#34;y\u0026#34; : 300\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-folder-list\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;folder-paths\u0026#34; : [ \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5516\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5517\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5518\u0026#34; ],\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Folder list\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r},\r\u0026#34;preprocessing-path-to-annotation\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;preprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 400,\r\u0026#34;y\u0026#34; : 500\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;path-to-annotation-simple\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;,\r\u0026#34;annotation-merge-strategy\u0026#34; : \u0026#34;OverwriteExisting\u0026#34;,\r\u0026#34;remove-extensions\u0026#34; : true,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;generated-annotation\u0026#34; : \u0026#34;Dataset\u0026#34;,\r\u0026#34;full-path\u0026#34; : false,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Path to annotation\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;preprocessing-list-files\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;preprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 425,\r\u0026#34;y\u0026#34; : 700\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;folder-list-files\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;subfolder\u0026#34; : \u0026#34;in\u0026#34;,\r\u0026#34;recursive-follows-links\u0026#34; : true,\r\u0026#34;filters\u0026#34; : [ {\r\u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;,\r\u0026#34;filter-string\u0026#34; : \u0026#34;*.tif\u0026#34;,\r\u0026#34;invert\u0026#34; : false\r} ],\r\u0026#34;only-filenames\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;recursive\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;List files\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;preprocessing-import-image\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;preprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 425,\r\u0026#34;y\u0026#34; : 900\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-imagej-imgplus-from-file\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;generated-image-type\u0026#34; : \u0026#34;imagej-imgplus\u0026#34;,\r\u0026#34;title-annotation\u0026#34; : {\r\u0026#34;content\u0026#34; : \u0026#34;Image title\u0026#34;,\r\u0026#34;enabled\u0026#34; : false\r},\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Import image\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;preprocessing-preprocessing-output\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;input\u0026#34; : {\r\u0026#34;Data\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;output\u0026#34; : {\r\u0026#34;Data\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;preprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 425,\r\u0026#34;y\u0026#34; : 1100\r}\r},\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 100,\r\u0026#34;y\u0026#34; : 50\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing output\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r},\r\u0026#34;analysis-gaussian-blur-2d\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 100,\r\u0026#34;y\u0026#34; : 250\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-blur-gaussian2d\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;sigma-y\u0026#34; : -1.0,\r\u0026#34;sigma-x\u0026#34; : 1.0,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Gaussian blur 2D\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;analysis-auto-threshold-2d\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 100,\r\u0026#34;y\u0026#34; : 450\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-threshold-auto2d\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;method\u0026#34; : \u0026#34;Default\u0026#34;,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;dark-background\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Auto threshold 2D\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;analysis-distance-transform-watershed-2d\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 100,\r\u0026#34;y\u0026#34; : 650\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-binary-dtwatershed2d\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Distance transform watershed 2D\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;analysis-find-particles-2d\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 100,\r\u0026#34;y\u0026#34; : 850\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-analyze-find-particles2d\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;min-particle-circularity\u0026#34; : 0.0,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:parallelization:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Find particles 2D\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;min-particle-size\u0026#34; : 0.0,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;annotation-type\u0026#34; : {\r\u0026#34;content\u0026#34; : \u0026#34;Image index\u0026#34;,\r\u0026#34;enabled\u0026#34; : false\r},\r\u0026#34;max-particle-circularity\u0026#34; : 1.0,\r\u0026#34;split-slices\u0026#34; : true,\r\u0026#34;exclude-edges\u0026#34; : false,\r\u0026#34;measurements\u0026#34; : {\r\u0026#34;values\u0026#34; : [ \u0026#34;Centroid\u0026#34;, \u0026#34;PixelValueMinMax\u0026#34;, \u0026#34;Area\u0026#34; ]\r},\r\u0026#34;max-particle-size\u0026#34; : \u0026#34;Infinity\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;,\r\u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false\r},\r\u0026#34;analysis-analysis-output\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;input\u0026#34; : {\r\u0026#34;Spore Mask\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Spore ROI\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Spore measurements\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r},\r\u0026#34;output\u0026#34; : {\r\u0026#34;Spore Mask\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Spore ROI\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r},\r\u0026#34;Spore measurements\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;postprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 100,\r\u0026#34;y\u0026#34; : 50\r}\r},\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 50,\r\u0026#34;y\u0026#34; : 1050\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis output\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r},\r\u0026#34;postprocessing-plot-tables\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : { },\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;postprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 550,\r\u0026#34;y\u0026#34; : 250\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;plot-from-table\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;,\r\u0026#34;plot-type\u0026#34; : \u0026#34;plot-histogram\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Plot tables\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null,\r\u0026#34;plot-parameters/export-height\u0026#34; : 768,\r\u0026#34;plot-parameters/value-axis-label\u0026#34; : \u0026#34;Value\u0026#34;,\r\u0026#34;plot-parameters/bins\u0026#34; : 10,\r\u0026#34;plot-parameters/export-width\u0026#34; : 1024,\r\u0026#34;plot-parameters/bin-axis-label\u0026#34; : \u0026#34;Bin\u0026#34;,\r\u0026#34;plot-parameters/histogram-type\u0026#34; : \u0026#34;Frequency\u0026#34;,\r\u0026#34;plot-parameters/title\u0026#34; : \u0026#34;Histogram plot\u0026#34;,\r\u0026#34;column-assignments\u0026#34; : {\r\u0026#34;parameters\u0026#34; : {\r\u0026#34;Value\u0026#34; : {\r\u0026#34;name\u0026#34; : \u0026#34;Value\u0026#34;,\r\u0026#34;description\u0026#34; : \u0026#34;Values to generate a histogram from. (Numeric column)\u0026#34;,\r\u0026#34;visibility\u0026#34; : \u0026#34;TransitiveVisible\u0026#34;,\r\u0026#34;field-class\u0026#34; : \u0026#34;org.hkijena.jipipe.extensions.tables.parameters.TableColumnSourceParameter\u0026#34;,\r\u0026#34;value\u0026#34; : {\r\u0026#34;mode\u0026#34; : \u0026#34;PickColumn\u0026#34;,\r\u0026#34;column-source\u0026#34; : {\r\u0026#34;mode\u0026#34; : \u0026#34;Equals\u0026#34;,\r\u0026#34;filter-string\u0026#34; : \u0026#34;Area\u0026#34;,\r\u0026#34;invert\u0026#34; : false\r},\r\u0026#34;generator-source\u0026#34; : {\r\u0026#34;generator-type\u0026#34; : null,\r\u0026#34;generated-type\u0026#34; : \u0026#34;NumericColumn\u0026#34;\r}\r},\r\u0026#34;short-key\u0026#34; : \u0026#34;Value\u0026#34;,\r\u0026#34;ui-order\u0026#34; : 0,\r\u0026#34;field-class-id\u0026#34; : \u0026#34;table-column-source\u0026#34;\r}\r}\r}\r},\r\u0026#34;postprocessing-postprocessing-output\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;input\u0026#34; : { },\r\u0026#34;output\u0026#34; : { }\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;postprocessing\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 1100,\r\u0026#34;y\u0026#34; : 50\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;,\r\u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true,\r\u0026#34;jipipe:algorithm:enabled\u0026#34; : true,\r\u0026#34;jipipe:algorithm:pass-through\u0026#34; : false,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing output\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r}\r},\r\u0026#34;edges\u0026#34; : [ {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing-plot-tables\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Image\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Data\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Spore Mask\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : true\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Data\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Mask\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Annotated paths\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Folders\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Measurements\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-folder-list\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Folder paths\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Paths\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;ROI\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Spore ROI\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r} ]\r},\r\u0026#34;compartments\u0026#34; : {\r\u0026#34;compartment-graph\u0026#34; : {\r\u0026#34;nodes\u0026#34; : {\r\u0026#34;preprocessing\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;input\u0026#34; : { }\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;DEFAULT\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 50,\r\u0026#34;y\u0026#34; : 50\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r},\r\u0026#34;analysis\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;input\u0026#34; : {\r\u0026#34;Preprocessing\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Preprocessing\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;DEFAULT\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 50,\r\u0026#34;y\u0026#34; : 250\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r},\r\u0026#34;postprocessing\u0026#34; : {\r\u0026#34;jipipe:slot-configuration\u0026#34; : {\r\u0026#34;input\u0026#34; : {\r\u0026#34;Analysis\u0026#34; : {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : null,\r\u0026#34;name\u0026#34; : \u0026#34;Analysis\u0026#34;,\r\u0026#34;custom-name\u0026#34; : null,\r\u0026#34;inheritance-conversions\u0026#34; : { }\r}\r}\r},\r\u0026#34;jipipe:algorithm-ui-location\u0026#34; : {\r\u0026#34;DEFAULT\u0026#34; : {\r\u0026#34;Vertical\u0026#34; : {\r\u0026#34;x\u0026#34; : 188,\r\u0026#34;y\u0026#34; : 450\r}\r}\r},\r\u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;,\r\u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;,\r\u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing\u0026#34;,\r\u0026#34;jipipe:node:description\u0026#34; : null\r}\r},\r\u0026#34;edges\u0026#34; : [ {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Analysis\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r}, {\r\u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing\u0026#34;,\r\u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;,\r\u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;target-slot\u0026#34; : \u0026#34;Preprocessing\u0026#34;,\r\u0026#34;metadata\u0026#34; : {\r\u0026#34;ui-hidden\u0026#34; : false\r}\r} ]\r}\r}\r}\r"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/slot-definition/",
	"title": "Slot definition",
	"tags": [],
	"description": "Defines a data slot",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: slot-definition.schema.json\n\rDefines a data slot\r\r\rslot-data-type:\r\rstring\r\r\r\r\r\r\rThe data type ID of the data stored in this slot\r\r\rslot-type:\r\rstring\r\r, x ∈ {\rInput\r\r,\rOutput\r\r}\r\r\r\r\r\r\rDetermines if the slot is an input or an output\r\r\rinherited-slot:\r\robject\r\r\r\r\r\rOnly valid for output slot. Defines from which slot to inherit the data type. Can be '*' to select the first available slot.\r\r\rname:\r\rstring\r\r\r\r\r\r\rUnique slot name\r\r\rcustom-name:\r\robject\r\r\r\r\r\rUser-customizable name. Only displayed in UI.\r\r\rinheritance-conversions:\r\robject\r\r\r[object Object]\r\r\r\r\rOnly valid for slot inheritance. Applies conversiuons to the inherited type. Must contain map from input data type ID to output data type ID. Conversion is a finite text replacement system.\r\r\r\r\r\rExample {\r\u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d\u0026#34;,\r\u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;,\r\u0026#34;inherited-slot\u0026#34; : \u0026#34;Input\u0026#34;,\r\u0026#34;inheritance-conversions\u0026#34;: {\r\u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;: \u0026#34;imagej-imgplus-2d-greyscale-8u\u0026#34;\r},\r\u0026#34;name\u0026#34; : \u0026#34;Output\u0026#34;\r}\r"
},
{
	"uri": "https://www.jipipe.org/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "https://www.jipipe.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.jipipe.org/",
	"title": "JIPipe",
	"tags": [],
	"description": "",
	"content": "Macro programming for everyone! \rJIPipe is a graphical batch processing programming language for ImageJ that\rallows you to create macros without any programming  by just creating a flowchart!\r\r Download now \r Learn how to use it \r Show examples \r\r\r --\r\rIntuitive user interface\rJIPipe comes with a modern and easy to use interface that is simple by default, but powerful when needed.\rAll options are logically organized and located where you expect them to be.\r\r\r\rEasy to learn\rJIPipe comes with helpful tools such as the Algorithm finder that guides you in creating a pipeline by offering compatible processing steps for your current data.\r\r\r\rEasy to organize \u0026amp; document\rJIPipe allows you to organize your pipelines into compartments and node groups to help you to keep track of your analysis. Furthermore, you can document your pipeline by adding\rlabels, names, and custom descriptions to inputs, outputs, and nodes.\r\r\r\rBuilt on ImageJ\rJIPipe is built on the established ImageJ software and comes with commonly used ImageJ functions and plugins, just as CLIJ2 and MorphoLibJ.\rYou can re-use your existing macros and ImageJ2 scripts and create easy-to-use graphical interfaces for them, which will also be available directly within ImageJ via JIPipe's two-way integration.\r\r\r\rEasy sharing \u0026amp; extending\rJIPipe allows you to export your pipelines as custom nodes that can be installed just like any other ImageJ plugin. Programmers can make use of the powerful API to enhance the feature set even more.\r\r\r\rPowerful result evaluation\rYou can either analyze results directly after processing or load existing results\rdirectly into JIPipe. The powerful result analysis tool lets you import data back\rinto ImageJ, or summarize and plot them directly within JIPipe.\r\r\r\rIntegrated table editor\rJIPipe comes with a tool to summarize and concatenate tables without\rany external tools. The tool can directly import table data generated\rby ImageJ.\r\r\r\rIntegrated plot editor\rJIPipe comes with a powerful plot builder that supports a multitude of different plot types,\rsuch as XY plots, bar charts, histograms, and box plots.\r\r\r\r\rDo you want to try it?\r\rYou can try JIPipe right now in three simple steps!\r\r\rDownload ImageJ or open your existing ImageJ installation\rActivate the JIPipe update site (Help \u0026gt; Update ...)\rRun the JIPipe GUI from within the plugin menu\r\r\rAfter starting JIPipe, we recommend you to follow our tutorial or load an example pipeline.\r\r\rDo you have a question or require some help?\r\rPlease do not hesitate to contact us! You can always contact the JIPipe developers via the community, or via E-Mail.\rIf you find a bug, you can also report it directly on GitHub.\r\r\r Community \r Send E-Mail \r Report a bug \r\r\rJIPipe was developed by Research Group Applied Systems BiologyHead: Prof. Dr. Marc Thilo Figge\rHKI-Center for Systems Biology of Infection\rLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\rAdolf-Reichwein-Straße 23, 07745 Jena, Germany\r\r\r\r\r\r\r$(document).ready(function(){\r// Landing page slideshow\r$('.landing-features').slick({\rinfinite: true,\rdots: true,\rslidesToShow: 3,\rslidesToScroll: 3,\rautoplay: true,\rautoplaySpeed: 10000,\rcenterMode: true,\rcenterPadding: '5rem',\rinitialSlide: 1,\rresponsive: [\r{\rbreakpoint: 1024,\rsettings: {\rslidesToShow: 1,\rslidesToScroll: 1\r}\r}\r]\r});\r});\r\r"
},
{
	"uri": "https://www.jipipe.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]