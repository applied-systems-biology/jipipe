[
{
	"uri": "https://www.jipipe.org/_header/",
	"title": "Header",
	"tags": [],
	"description": "",
	"content": "\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph-node/",
	"title": "Algorithm node",
	"tags": [],
	"description": "Node in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm-node.schema.json\n Node in a graph   jipipe:slot-configuration:  object   [object Object]      User-defined slots. Might be ignored depending on the algorithm. The keys are the slot names. See slot-definition        jipipe:algorithm-ui-location:  object   [object Object]     Locations of this node within the UI. Optional. The keys depend on the UI implementation. See point        jipipe:algorithm-type:  string       Algorithm type ID   jipipe:algorithm-compartment:  string   DEFAULT      Compartment ID. Only important for the UI.   name:  string       A custom name for this algorithm. Only important for the UI. If null or empty, the UI will default to the algorithm type name.   description:  object       A custom description. Only important for the UI.      Example { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Annotated folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Annotated folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;default-preprocessing\u0026#34; : { \u0026#34;x\u0026#34; : 525, \u0026#34;y\u0026#34; : 100 }, \u0026#34;default-preprocessing{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 }, \u0026#34;default-preprocessing{Horizontal}\u0026#34; : { \u0026#34;x\u0026#34; : 450, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-annotate-by-name\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;default-preprocessing\u0026#34;, \u0026#34;generated-annotation\u0026#34; : \u0026#34;project-sample\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Folders to annotations\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } "
},
{
	"uri": "https://www.jipipe.org/documentation/batch-pipelines/",
	"title": "Batch pipelines",
	"tags": [],
	"description": "Explains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.",
	"content": "JIPipe was designed to always process data in batches, meaning that algorithms always work on multiple data sets at once. This greatly reduces the required work to upscale a processing pipeline from one or few to a large amount of data sets.\nWe will use this pipeline as example:\nmermaid.initialize({startOnLoad:true}); graph LR; A[File] -- B[Load image] B -- C[Apply gaussian]  In the pipeline, a file is provided as input. Then the file is loaded as image. Finally, the image is processed with a gaussian filter.\nA possible implementation of such a pipeline consists of three algorithms, one for each processing step. An algorithm consumes input and produces output. The exception is the algorithm that loads a user-defined file path into the pipeline.\nJIPipe extends on this concept by allowing input and output slots contain multiple data sets at once. And depending on the algorithm, it either processes each data set individually, or splits, merges, or transforms the list of input data.\nHandling multiple inputs There might be algorithms that require multiple inputs:\nmermaid.initialize({startOnLoad:true}); graph LR; A[Image channel 1] -- B[Merge channels] C[Image channel 2] -- B  The Merge channels algorithm merges the two image channels into one image with two channels. If each data slot only contains one entry, finding image channels that belong to the same data set is trivial.\nFor list-based data slots, like in JIPipe, it is not trivial to find images that should be merged. For example, image1_C1 and image1_C2 should be merged to image1_merged:\nData annotations JIPipe solves this issue by allowing to annotate each data entry (shown as purple entries). Those annotations are in this case automatically extracted and used to group input data. There also can be algorithms that use the annotation information to for example filter or sort data.\nThere are predefined algorithms located within the Annotate menu that for example create annotations based on filenames. JIPipe supports an unlimited amount of annotations that can be attached to data.\nFollowing JIPipe pipeline provides an example of making use of annotations to allow multiple inputs:\n"
},
{
	"uri": "https://www.jipipe.org/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "Please choose how you want to install JIPipe     ImageJ update site  Windows installer  Linux installer  MacOS installer    JAR files   Recommended. An update site allows you to easily update JIPipe to newer versions with one click. It requires from you to have an existing installation of ImageJ.  Download ImageJ or open your existing ImageJ installation Go to Help \u0026gt; Update ... and activate the JIPipe update site. Then let ImageJ download all necessary files. Run the JIPipe GUI from within the plugin menu    Tip: If you want a desktop shortcut (Windows) or an entry in your application menu (Linux), open JIPipe and run Tools \u0026gt; Create launchers  You can download an installer that provides an existing Fiji installation plus all necessary files for JIPipe.   Download  the installer Run the installer and follow the instructions You will find a JIPipe icon in the start menu and on the desktop   Info: The installer requires an online connection.  You can download an installer that provides an existing Fiji installation plus all necessary files for JIPipe.   Download  the installer Make the installer runnable (Required for older Linux versions)  Ubuntu/GNOME Right-click the installer file and click PropertiesNavigate to PermissionsEnable Allow executing file as program KDE Right-click the installer file and click PropertiesNavigate to PermissionsEnable Is executable Terminal Navigate into the folder where the file is located and run chmod +x JIPipe-Installer-Linux  Run the installer by double-clicking it (GUI) or by running ./jipipe-installer-x86_64.AppImage from within a terminal. Follow the instructions. You will find a JIPipe icon in the start menu and on the desktop   Info: The installer requires an online connection.  You can download an installer that provides an existing Fiji installation plus all necessary files for JIPipe.   Download  the installer Drag the file to your desktop   Info: The installer requires an online connection.  Info: Please do not install the app globally (using administrator rights). This can prevent ImageJ updates.  JIPipe is available as standalone ImageJ plugin in *.jar format that you can install into an existing installation of ImageJ.   Download  the *.jar files Download ImageJ if you have no ImageJ installation, then open the ImageJ plugin folder    Windows/Linux Open the Fiji.app directory and navigate into the plugins folder  OSX Right-click the Fiji icon on the desktop and click Show package contents. Navigate into the plugins folder.  Open the *.zip file you downloaded and extract its contents into the plugins folder. Start ImageJ. You can find the JIPipe GUI inside the plugin menu    Tip: If you want a desktop shortcut (Windows) or an entry in your application menu (Linux), open JIPipe and run Tools \u0026gt; Create launchers   Source code The software is Open Source and licensed under BSD-2-Clause. You can find the source code on GitHub at https://github.com/applied-systems-biology/jipipe.\n// Download page menus $(\".download-panel-content\").css(\"display\", \"none\"); $('input:radio[name=\"download-options\"]').change(function(){ $(\".download-panel-content\").css(\"display\", \"none\"); $(\"#\" + $(this).val() + \"-content\").css(\"display\", \"block\"); }); $('input:radio[value=\"download-via-update-site\"]').change(); $('input:radio[value=\"download-via-update-site\"]').prop(\"checked\", true);  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/iterating-algorithms/",
	"title": "Handling multiple inputs",
	"tags": [],
	"description": "",
	"content": "JIPipe data slots store multiple data rows. This means that algorithms have to iterate their workload for each input row and generate equivalent output in the respective output slots.\nThere can be issues if data from multiple input slots need to be combined (e.g. merge channels into RGB, see user documentation). JIPipeAlgorithm has no capabilities to help with such cases.\nA solution can be JIPipeIteratingAlgorithm or JIPipeSimpleIteratingAlgorithm that use the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeDataBatch instances that represent one data set iteration.\n For simple algorithms, we recommend JIPipeSimpleIteratingAlgorithm. It does not have the additional parameters that might confuse some users, but creates the same runIteration(...) command as JIPipeIteratingAlgorithm. It only works for algorithms with at most one input and will generate error messages if you have more than one input.   Please access data via the data interface. It reads exactly one JIPipeData for each input.  The only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeIteratingAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation Please read and write only via the data interface. */ @Override public runIteration(JIPipeDataBatch dataBatch, JIPipeProgressInfo progress) { // Run your workload here  } } "
},
{
	"uri": "https://www.jipipe.org/tutorials/analysis/",
	"title": "Image analysis pipeline",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": " This tutorial is also available as video.   1. First start On starting JIPipe, you will see such a screen: It contains a short introduction, the graph compartment editor, an three pre-defined graph compartments Preprocessing, Analysis, and Postprocessing. As described in the graph compartment documentation, you can ignore graph graph compartments. But in this tutorial we will make use of its capabilities to clearly separate the pipeline into the mentioned tree steps.    2. Graph compartments Here you can see how the data flows between graph compartments. You do not have to do anything here, as this is the default configuration. Data flows from Preprocessing to Analysis, and finally to Postprocessing.  You can ignore the graph compartments and of course define your own data flow. Graph compartments are very flexible. Just take a look at the documentation.    3. Preprocessing In this tutorial, the preprocessing step should consist of algorithms that load and organize data for the following processes. To switch to the graph editor for the preprocessing step, just click the Preprocessing tab. You will find an empty graph aside of the Preprocessing output node. We will utilize this node in a later step to pass preprocessed data to other steps.  The graph is stored project-wide. You can just close all graph editors that you do not need for the current task. You can re-open them via the graph compartment editor. If you closed it, you can re-open it via the Compartment menu in the project menu bar.    4. Adding a data source The most common way how data is provided is to load them from files or folders. JIPipe comes preinstalled with data-types and algorithms that handle filesystem operations. The tutorial data is supplied as set of folders that contain the input images as TIFF files in a sub-directory.We begin by adding a data source that supplies a list of folders. You can find it in Add data \u0026gt; Folder \u0026gt; Folder list. After selecting the item, it will appear in the graph.  You can also drag folders and/or files directly into the graph editor area. Corresponding file data source nodes are then created. For this example, you could just drag the input data folders directly into the graph.   You do not have to navigate via the menu. You can also type the algorithm name or some keywords into the bar that reads Search ....    5. Including the input folders Select the newly created algorithm node by clicking it. The panel on the right-hand side will update and allow you to change the parameters of the selected algorithm node. Click the  Add button and select the input folders.  You can save the current project at any time and re-load it later. If you save it in a parent directory relative to where your data is located, JIPipe automatically saves all paths relative to the project file. This means you can just move all your data, including the project to other machines or hard drive partitions without breaking anything.    6. Annotating data JIPipe is designed as batch processing tool, meaning that it can be always scaled from small test data up to large data sets. It can be helpful for you and some algorithms to know which data belongs together. JIPipe introduces the concept of data annotations that assign data to an unique data set and are passed through the pipeline. You can find more about this in the documentation about how JIPipe processes data. In this step we add the data annotation directly at the beginning by attaching the input folder name to each folder that was passed into the pipeline. This is done via the Annotations \u0026gt; Generate \u0026gt; Path to annotation algorithm. Just add this algorithm into the graph. For more advanced projects there are plenty of other sources for annotations, like importing them from tables, or extracting and modifying annotations.   7. Connecting slots The input folders are converted into a format understandable by JIPipe by the Folder list algorithm. The output then can be passed to following algorithms like the Folders to annotations algorithm we added in the last step. To make a connection click the  or  button and select the available data slot. You can see that a connection between the two data slots was created. This list is always sorted from the closest to the farthest away slot.  You can also use your mouse to drag a connection between slots.    8. Annotation type Annotations are like columns in a table - only that our table contains complex data types. The Path to annotation algorithm automatically extracts the path's file name (or directory name) and annotates it to the input row. By default, the algorithm creates a column Dataset. If you want you can change it to another meaningful column name. And with more complex projects you will probably have many different columns.   9. Extracting the image file We have now the folders and can extract the input image file from each one of them. You can find an algorithm designed for such purposed in File system \u0026gt; List \u0026gt; List files. Add it to the graph and connect it to the Subfolder name output. This algorithm is not only able to list files, but also filter them directly. In this case, we exactly know that our files are located within a sub-folder in. Please update the Subfolder parameter by setting it to in. The filter uses an expression that allows highly flexible filters. But for this example, we only want to test if the filename contains .tif. To do this, type name CONTAINS \".tif\" into the filter box.  If you have more complicate folder structures, you can apply the \"Navigate to sub-folder\" operation with a distinct algorithm. You can find it in the Filesytem category.   We highly recommend that you get familiar with expressions, as they are present in most filtering or generation nodes. They are easy to learn and write, but also allow extremely powerful operations.    10. Testing if the pipeline is correct (Optional) The Quick Run feature allows you to run the pipeline until the selected algorithm and compare multiple parameter sets. It is a good way to test if the pipeline works so far. To create a quick run right-click the List files node and select  Run \u0026amp; show results.  The quick run will check if the pipeline is valid might show some error. If you think that the pipeline is valid, click  Retry to check the pipeline again. It sometimes does not update for performance reasons.   You can also do a quick-run that just refreshes the Cache.   You can also start a Quick Run from the parameter panel if you select the algorithm.    11. Testing if the pipeline is correct - results (Optional) Navigate to the output if the List files algorithm and check if the file paths are correct. See our Quick Run documentation for more information about the testbench and its features.   12. Importing the images After correctly setting up the files, you can import them as images. You can find various importers for image types in Add data. Our images do not require Bio-Formats, so we choose Add data \u0026gt; Image \u0026gt;Import image. Connect it to the output of List files.  The Import image node does not ensure the exact bit depth and dimensionality of the output image. You can change this via a parameter that allows you to choose the exact image type.    13. Preprocessing output You could continue with the analysis directly from the Import image node. But to showcase the graph compartments feature, we decide to have the imported greyscale image as output for of the Preprocessing compartment. The output of a graph compartment is only interfaced through a special node, in this case Preprocessing output.We first have to define an output slot by clicking the  button. Select Import image, set a name, and click  Add.   14. Connecting the output Finally, connect the output of Import image to the new input slot of Preprocessing output.   15. The analysis Now we are finished with the preprocessing. Switch to the Analysis graph compartment by selecting the tab in the tab bar. You see that it also contains a node called Preprocessing output. This is the same node as in the preprocessing compartment, but it only contains output data this time. We continue the analysis with a Gaussian filter that can be found in Images \u0026gt; Blur \u0026gt; Gaussian blur 2D. Add it to the graph and connect it to the output of Preprocessing output.   16. Finding the particles Add following algorithms to the graph and connect them the the previous output:  Images \u0026gt; Threshold \u0026gt; Auto Threshold 2D Images \u0026gt; Binary \u0026gt; Distance transform watershed 2D Images \u0026gt; Analyze \u0026gt; Find particles 2D   This will create a more or less accurate segmentation of the objects (spores) that are visible in the data. The generated masks are then analyzed to extract ROI and measurements.   17. Analysis output Create multiple analysis output slots via the  button. Export at least the measurements table. In our example, we exported the mask, ROI, and the measurements.  You can hide edges if you want. Just click the  or  and select Hide edge.    18. Postprocessing The postprocessing consists of generating a histogram plot of the spore particle areas. You can find a node that generates plots in Tables \u0026gt; Plot \u0026gt; Plot tables. Connect the measurements to the plotting node and set its plot type to  Histogram plot. You see that the node parameters change. They adapt to the the currently selected plot and expect from you to input from which table column(s) to extract the data from. Either you know the name of the columns, or you can use the testbench to generate output and check it yourself. Some algorithms also write the names of their output columns in their description. The correct column for the measurements is Area. You can also change various plot-specific settings and determine how output images are generated.  The plot node automatically generates SVG and PNG renders in the selected resolution. This is not a definite choice, as JIPipe has its own plot builder that can import generated plots from within the results UI.   Aside from exact matching, plot input columns can be matched via a regular expression or generated. Use the generator by selecting . A generator can be useful if you have no matching column within your data.    19. Running the pipeline To run the pipeline, click the  Run button at the top right corner. This will open a new tab where you can select the output directory. You can also generate a random folder that will be located on your operating system's temporary directory by clicking the button. After setting up the parameters, click  Run now.  JIPipe attempts to prevent the most common errors (such as wrong parameters) and displays a message if something was found. Please follow the instructions of those messages. Depending on the data and algorithms, the behavior might not be forseeable and a crash occurs during the processing. A similar easy-to-understand message is shown on how to proceed or repair the issue.    20. Displaying results After the pipeline was successfully executed, a result analysis interface is shown. It displays the results of all output slots. You can navigate through the results via the tree on the left-hand side. On selecting a row, an interface is displayed below the table that contains various operations to import or open the data.   21. Displaying plots To open the generated plots, navigate to Results \u0026gt; Postprocessing \u0026gt; Plot tables \u0026gt; Output and double-click an entry in the list. Alternatively, you can also select the row and click Open in JIPipe. This will open a new tab with a plot builder tool. Please take a look at the plots and tables documentation for more information how the tool works.   "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/javadocs/",
	"title": "JavaDocs",
	"tags": [],
	"description": "Provides a link to the JavaDocs",
	"content": "The JavaDocs of the Java API can also be found here\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/result-ui/",
	"title": "Result view",
	"tags": [],
	"description": "",
	"content": "After processing, users should be able to continue processing the data from within JIPipe. The data instances are cleared from memory after processing, meaning that the data needs to be loaded from its output folder after processing.\nAn user interface is shown when a user select a row in the results table. There are two ways to modify the user interface:\n Registering additional operations that will be available to users (recommended) Replacing the interface with a custom one  Adding custom operations JIPipe already comes with some default operations, such as opening the containing folder. Any other operation must be added manually to each data type.\nThere are two types of operations: one for importing data written into a results folder, and one for displaying already loaded data from memory. The corresponding interfaces are JIPipeDataImportOperation and JIPipeDataDisplayOperation.\nYou can implement one or both interfaces as shown here:\npublic class MyOperation implements JIPipeDataImportOperation, JIPipeDataDisplayOperation { @Override public void display(JIPipeData data, String displayName, JIPipeWorkbench workbench) { // Here you can pu a custom display function  // Currently it just uses the default function  data.display(displayName, workbench); } @Override public String getName() { // Name as shown in the menu  // The name should be unique  return \u0026#34;Open in JIPipe\u0026#34;; } @Override public String getDescription() { return \u0026#34;Opens the table in JIPipe\u0026#34;; } @Override public int getOrder() { // The lower the order the higher it is placed in the menu  // The lowest ist used as default  return 100; } @Override public Icon getIcon() { return UIUtils.getIconFromResources(\u0026#34;apps/jipipe.png\u0026#34;); } @Override public JIPipeData show(JIPipeDataSlot slot, JIPipeExportedDataTable.Row row, Path rowStorageFolder, String compartmentName, String algorithmName, String displayName, JIPipeWorkbench workbench) { // This function should import the data contained in the rowStorageFolder and display it  // You can return the data (which is currently not used) or return null  if (rowStorageFolder == null || !Files.isDirectory(rowStorageFolder)) return null; Path csvFile = PathUtils.findFileByExtensionIn(rowStorageFolder, \u0026#34;.csv\u0026#34;); if (csvFile != null) { ResultsTableData result = JIPipeTableEditor.importTableFromCSV(csvFile, (JIPipeProjectWorkbench) workbench); workbench.getDocumentTabPane().switchToLastTab(); return result; } return null; } } The operations must be registered in JIPipeJavaExtension either via the data type ID or when registering a new data type.\n Currently you have to register all your operations per data type. It its not enough to register them for the base class only.  @Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // Registering the operation when registering the data type  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null, new MyOperation()); // alternative ...  // Registering the operation by itself  registerDatatypeOperation(\u0026#34;my-data\u0026#34;, new MyOperation()); } }  You can register an operation for all data types by leaving the data type ID empty.  Using a custom interface This UI can be replaced with a custom one that is designed to handle this specific data type.\nSuch UIs inherit from JIPipeResultDataSlotRowUI, which is a panel that has access to\n the data location the annotation of this data row the project workbench UI  We recommend to inherit from JIPipeDefaultResultDataSlotRowUI that allows to inherit actions from inherited data types.\nJIPipeDefaultResultDataSlotRowUI requires you to register actions with a name, description and function. The action that was added last is shown in the main UI and triggered by double-clicking the data row in the table. All other actions are put into the ... menu.\npublic class MyDataDataSlotRowUI extends JIPipeDefaultResultDataSlotRowUI { public MyDataDataSlotRowUI(JIPipeProjectWorkbench workbenchUI, JIPipeDataSlot slot, JIPipeExportedDataTable.Row row) { super(workbenchUI, slot, row); } // This method is required because we need to find the JSON file  // we can load MyData from it  private Path findJsonFile() { if (getRowStorageFolder() != null \u0026amp;\u0026amp; Files.isDirectory(getRowStorageFolder())) { return PathUtils.findFileByExtensionIn(getRowStorageFolder(), \u0026#34;.json\u0026#34;); } return null; } @Override protected void registerActions() { super.registerActions(); Path jsonFile = findJsonFile(); if (imageFile != null) { registerAction(\u0026#34;Show value\u0026#34;, \u0026#34;Shows the value as message box\u0026#34;, UIUtils.getIconFromResources(\u0026#34;open.png\u0026#34;), e -\u0026gt; { MyData data = MyData.fromJson(jsonFile); JOptionPane.showMessageDialog(this, data.value, \u0026#34;The value is ...\u0026#34;) }); } } } The UI class can be directly registered in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The last null parameter will be handled in the next tutorial  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, null); } } "
},
{
	"uri": "https://www.jipipe.org/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "To get started, you can take a look at some example pipelines and other kind of examples:\n Segmenting spores This example applies auto-thresholding to segment spores from microscopy images. It makes use of the particle analyzer to extract ROI and measurements and shows how to create an area histogram plot. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline. This example is based on one of the tutorials.   Download (Offline)  Download (Online)  Tutorial    Segmenting glomeruli This example applies auto-thresholding and morphological operations to segment glomeruli in 2D slices of whole murine kidney light sheet microscopy images. This algorithm is part of a 3D segmentation published by Klingberg et al. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.   Download (Offline)  Download (Online)  Publication    Segmenting worms This example segments worms. This algorithm is part of a 3D segmentation published by Klingberg et al. There are both offline and online versions available. The online version downloads all necessary images from GitHub on executing the pipeline.   Download (Offline)  Download (Online)  Publication    Stack hypermontage A useful node that creates a montage of each incoming image stack and creates a montage of the montages. It is very useful when trying out different parameters for 3D analyses. Just copy the node from this website and paste it into your JIPipe pipeline.   Copy  Download example pipeline     $(document).ready(function(){ // Landing page slideshow $('.examples').slick({ infinite: true, dots: true, slidesToShow: 3, slidesToScroll: 3, autoplay: true, autoplaySpeed: 10000, centerMode: true, centerPadding: '5rem', initialSlide: 1, responsive: [ { breakpoint: 1024, settings: { slidesToShow: 1, slidesToScroll: 1 } } ] }); }); function copyTextToClipboard(text, onsuccess) { if (!navigator.clipboard) { fallbackCopyTextToClipboard(text); return; } navigator.permissions.query({name:'geolocation'}).then(function(result) { if (result.state == \"granted\" || result.state == \"prompt\") { navigator.clipboard.writeText(text).then(function() { alert(onsuccess); }, function(err) { console.error('Async: Could not copy text: ', err); }); } else { alert(\"Unable to copy to clipboard! You might be using an older browser that does not support this.\"); } }); } function copyMontageExample() { var url = window.location.origin + '/examples/example-montage.json'; fetch(url) .then(function(response) { response.text().then(text = copyTextToClipboard(text, \"Copied the node to clipboard! Paste it into an existing JIPipe project.\")); }); }  "
},
{
	"uri": "https://www.jipipe.org/tutorials/analysis_video/",
	"title": "Image analysis pipeline (Video)",
	"tags": [],
	"description": "This step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.",
	"content": " This tutorial is also available as text tutorial.   "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/merging-algorithms/",
	"title": "Merging input data",
	"tags": [],
	"description": "",
	"content": "You might need to develop an algorithm that does not simply iterate through its input(s), but organize it into groups to be merged. JIPipe comes with JIPipeMergingAlgorithm that uses the annotation attached during processing to find data rows that belong to the same data set. The implementation creates JIPipeMergingDataBatch instances that represent multiple data rows merged into one group.\n Please access data via the data interface.  The only difference to JIPipeAlgorithm is that you need to override a different function called runIteration.\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeMergingAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation Please read and write only via the data interface. */ @Override public runIteration(JIPipeMergingDataBatch dataBatch, JIPipeProgressInfo progress) { // Run your workload here  } } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/algorithm/",
	"title": "Algorithm type",
	"tags": [],
	"description": "Defines a new algorithm",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: algorithm.schema.json\n Defines a new node type   id:  string       Unique algorithm ID   metadata:  See metadata        General algorithm metadata   category:  string   org.hkijena.jipipe:miscellaneous      The category   exported-parameters:  object   [object Object]     List of parameters that will be exported to users of the node   graph:  See graph        This graph is executed when the algorithm is run   menu-path:  string       Optional menu path within the category menu   jipipe:project-type:  string  , x ∈ { graph-wrapper-algorithm  (default) }       Identifies the JSON as algorithm      Example { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;parameter-visibilities\u0026#34; : { \u0026#34;visible-keys\u0026#34; : [ ] }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } "
},
{
	"uri": "https://www.jipipe.org/tutorials/extension/",
	"title": "Creating an extension",
	"tags": [],
	"description": "This step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.",
	"content": " 1. Existing pipeline In this tutorial, we will create a custom algorithm extension based on parts of the pipeline created in the other tutorial. Please open the project file for the pipeline and navigate to the Preprocessing tab.    2. Selecting the algorithms Please select the following algorithms (you can either do this by holding the Shift keyboard button and clicking the nodes or dragging a selection around the nodes):  Folder list Path to annotation List files Import image  After selecting the algorithms, right-click a selected node and click Export.  Selecting one or multiple algorithms is only one way to create a custom algorithm. You can also export a whole project compartment (via the Compartments tab) or the whole pipeline (via Project \u0026gt; Export as custom algorithm)     3. Preview This will open a new tab where you can see a preview of the pipeline that will be exported. You see that the connections between the selected algorithms were kept, while two additional nodes were added:  Group input Group output  Those two nodes respectively act as input and output of the whole exported algorithm. Its input and output slots will be accessible to users of your custom algorithm. JIPipe automatically creates matching input and output slots based on the selected algorithms, but you can choose to modify your pipeline in this step. Now click Export to extension and then New extension.  You can always modify custom algorithms within the extension builder. This will be shown in a later step.     4. Extension builder This will open the JIPipe extension builder tool that allows you to package one or multiple custom algorithms into an extension. Such extensions can be just put into the ImageJ plugin directory and will be automatically picked up by JIPipe just like any ImageJ plugin. An extension has a set of metadata that you need to set up. To do this, switch to Extension settings.  You can always find the extension builder in Plugins \u0026gt; New JSON extension ...     5. Extension metadata JIPipe utilizes a unique extension ID to identify an extension. This is the most important setting and should be chosen carefully. The format must follow a specific structure: [Author]:[Extension], where [Author] provides information about the extension author, and [Extension] contains some identifier. We recommend to let the [Author] information follow the Maven naming conventions. All the other metadata can be freely chosen or left out (with the exception of the name). Use the other metadata to add authors (including affiliations), a website, define a license, and cite work your pipeline is depending on. Finally, you can review or modify the extension contents by going to Extension contents.  Any dependency to other JIPipe extensions are automatically stored within any project or extension file. JIPipe uses this information to figure out a valid load order.     6. Extension content Our custom algorithm is already included in the list of extension contents (left-hand side). You only need to provide metadata. The most important setting is the unique algorithm ID that is used by JIPipe to identify your algorithm. Please choose a meaningful string that avoids having duplicate identifiers. Then you can provide a name, category, icon and menu location.  The extension builder will warn you if an algorithm ID already exists (we will show this function later). You can choose to ignore this if a duplicate ID is intentional - this will override an algorithm and replace it by the new one.   Algorithm IDs are not namespaced, meaning that they are independent of the extension ID.     7. Parameters By default, your algorithm does not come with parameters aside of the few default parameters (name, description, pass-through, enable). For your pipelines it can be useful to let users change some parameters. The Exported parameters section gives you full control on which parameters can be changed and how they are organized. First, you need to create a group by clicking the  Add group button. This will create a new section in the final parameter UI. Then you can reference parameters by clicking  Add parameter. You can customize the name and descriptions of any item.  It is always a good idea to check the parameters or maybe apply some corrections to the algorithm. To do this, click  Edit graph  You can just add all parameters of a specific algorithm by clicking Auto add algorithm. Just check if users can properly decipher the function of each parameter.   Hover over the blue  wrench icon to display information about the referenced parameter.   Each parameter can only be referenced once. You will get a warning if you have duplicate references.     8. Modifying the algorithm The extension builder contains a fully function algorithm graph editor (aside of anything that runs the graph) that allows you to modify an algorithm or create one from scratch. Use the editor to check the parameters of your algorithm. For example, it is a good idea to remove the folders from the Folder list algorithm.    9. Validation and installation Click the  Validate button on the top right corner to check for any issues. This tool will also detect duplicate extension and algorithm IDs. Errors about duplicates can be ignored if they are intentional.  Finally, you can install the extension by clicking  Install. This will open a dialog to save the extension into the ImageJ plugin directory and attempt to load the extension.  We still recommend to restart ImageJ, especially if you are installing duplicate IDs.     10. Using the algorithm You can find your algorithm in the menu, navigation bar, and algorithm finder just like any other algorithm. You can see that the parameters are included according to the settings within the extension builder.  JSON Algorithms can be always converted into  Group nodes that unlink the underlying pipeline from the JSON algorithm definition and allows users to modify them. Just select  Convert to group to apply such conversions.    Group nodes are related to JSON algorithms. If you export a single group node, its contents are exported into an algorithm instead of the node itself.     "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/create-extension/",
	"title": "Creating an extension project",
	"tags": [],
	"description": "Explains how to setup a SciJava plugin project to extend JIPipe",
	"content": "Prerequisities  Java 8 (Java 9+ are not working)  If you are using Windows or a Linux distribution without Java 8, we recommend AdoptOpenJDK (Please choose OpenJDK 8)   Maven  Creating the project The project should have following structure:\nProject root └── pom.xml └── src └── main ├── java └── resources Both the java and resources folder should contain a folder structure that is equivalent the groupId and artifactId of the project. This is done to prevent conflicts with other plugins.\nJIPipe is based on SciJava and requires libraries provided by the SciJava Maven repository.\nHere is an example *.pom file that makes use of SciJava:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;inceptionYear\u0026gt;2020\u0026lt;/inceptionYear\u0026gt; \u0026lt;organization\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/organization\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;license\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;distribution\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/distribution\u0026gt; \u0026lt;/license\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;developer\u0026gt; \u0026lt;id\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/developer\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;contributors\u0026gt; \u0026lt;contributor\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;/contributor\u0026gt; \u0026lt;/contributors\u0026gt; \u0026lt;mailingLists\u0026gt; \u0026lt;mailingList\u0026gt; \u0026lt;name\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/name\u0026gt; \u0026lt;archive\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/archive\u0026gt; \u0026lt;/mailingList\u0026gt; \u0026lt;/mailingLists\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;connection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/connection\u0026gt; \u0026lt;developerConnection\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/developerConnection\u0026gt; \u0026lt;tag\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/tag\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;issueManagement\u0026gt; \u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/issueManagement\u0026gt; \u0026lt;ciManagement\u0026gt; \u0026lt;system\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/system\u0026gt; \u0026lt;url\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/url\u0026gt; \u0026lt;/ciManagement\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pom-jipipe\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2020.11\u0026lt;/version\u0026gt; \u0026lt;!-- Update the version accordingly --\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;imagej.public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://maven.imagej.net/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imagej\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imglib2\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imglib2-ij\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.imagej\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;imagej-legacy\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;scijava-log-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JIPipe core library --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jipipe-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- ImageJ integration --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hkijena\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jipipe-ij\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Add more JIPipe libraries if you need --\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;license.licenseName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.licenseName\u0026gt; \u0026lt;license.copyrightOwners\u0026gt;N/A\u0026lt;/license.copyrightOwners\u0026gt; \u0026lt;license.projectName\u0026gt;\u0026lt;!-- Please insert a value --\u0026gt;\u0026lt;/license.projectName\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- This plugin can be useful to create a manually-installable package --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/dependencies\u0026lt;/outputDirectory\u0026gt; \u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt; \u0026lt;overWriteSnapshots\u0026gt;false\u0026lt;/overWriteSnapshots\u0026gt; \u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt; \u0026lt;excludeGroupIds\u0026gt;net.imagej, net.imglib2, org.scijava, com.google.code.gson, com.google.guava, org.swinglabs, ome \u0026lt;/excludeGroupIds\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.scijava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;scijava-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;set-rootdir\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;validate\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;set-rootdir\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-jars\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;install\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-jars\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Creating an extension service JIPipe uses the SciJava plugin API to register Java extensions. In your project, you can create as many extensions as you want.\nJava extension inherit from JIPipeJavaExtension and require a @Plugin annotation.\nWe recommend to inherit from JIPipeDefaultJavaExtension that comes with some convenience-functions.\nA minimal extension can be found here:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { @Override public String getName() { return \u0026#34;My extension\u0026#34;; } @Override public String getDescription() { return \u0026#34;A Java extension\u0026#34;; } @Override public String getDependencyId() { // We recommend the following structure: \u0026lt;groupId\u0026gt;.\u0026lt;artifactId\u0026gt;:\u0026lt;dependencyId\u0026gt;  // (!) The dependency Id should be unique for your plugin (!)  return \u0026#34;org.hkijena.jipipe:my-extension\u0026#34;; } @Override public String getDependencyVersion() { return \u0026#34;1.0.0\u0026#34;; } @Override public String getAuthors() { return \u0026#34;Ruman Gerst\u0026#34;; } @Override public String getWebsite() { return \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;; } @Override public String getLicense() { return \u0026#34;BSD-2\u0026#34;; } @Override public URL getLogo() { // This code loads the default JIPipe logo from JIPipe resources  // You can replace it with your own logo if you want  // Just do not use JIPipe\u0026#39;s ResourceUtils for this, as its always pointing to JIPipe resource directories  return ResourceUtils.getPluginResource(\u0026#34;logo-400.png\u0026#34;); } @Override public String getCitation() { // Here you can enter a citation for your publication  // It will be displayed in the plugin manager  return \u0026#34;\u0026#34;; } @Override public void register() { // Content is registered here  } } Testing your extension Use following code to create an ImageJ2 instance that immediately loads JIPipe:\npublic static void main(final String... args) { final ImageJ ij = new ImageJ(); ij.ui().showUI(); // If your ImageJ freezes, you can leave this out. JIPipe will show anyways.  ij.command().run(JIPipeGUICommand.class, true); } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/slot-configuration/",
	"title": "Customizing slots",
	"tags": [],
	"description": "",
	"content": "In the previous examples, we used the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations with autoCreate = true to automatically configure the slots.\nThis is not sufficient for more complicated algorithms that require\n Restricting the number of slots Restricting the allowed data types Users to add more slots or remove existing ones  A custom JIPipeSlotConfiguration can be used to implement such more advanced behaviors.\nFor many cases, the default implementation JIPipeMutableSlotConfiguration is sufficient.\nThe slot configuration can be overriden during instantiation of the algorithm:\npublic MyAlgorithm(JIPipeNodeInfo info) { super(info, JIPipeMutableSlotConfiguration.builder() .addInputSlot(\u0026#34;Input\u0026#34;, ImagePlusData.class) .restrictOutputTo(ImagePlusData.class) .build()); }  The slots of JIPipeMutableSlotConfiguration are by default unsealed - meaning that users can add more slots. Use the seal() functions to prevent this.   Do not create static slot configurations. Each algorithm should have its own instance. Use a private static function if you want to work outside the capabilities of the builder.   You should keep the @AlgorithmInputSlot and @AlgorithmOutputSlot annotations. They are required for the algorithm finder and generating tooltips.  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "This library provides integration of ImageJ data types, as well as common ImageJ algorithms.",
	"content": "The ImageJ integration library integrates common data types from ImageJ into JIPipe:\n Multi-dimensional images (ImagePlus). The standard output file format are TIFF files. Result tables. They are serialized to CSV files. Region of interest (ROI Manager). JIPipe handles ROI as *.zip files.  The ImageJ data types are marked as accessible from outside JIPipe, meaning that algorithms that only use those types can be executed standalone\nImage data types Various ImageJ algorithms only work on data with a specific color type, or dimensionality. To make it easier for algorithms to specifiy which types are suitable, the JIPipe standard library introduces various image sub-types (e.g. 8-bit greyscale 3D image).\nThe library is set up to automatically convert any image data type into any other image data type. During this conversion, the data types automatically attempt to satisfy their constraints or raise an error. The conversion automatically converts a lower-dimensional image into a higher-dimensional image (e.g. 2D to 3D), but not the other way around.\nThe image data types are organized in the following way:\nmermaid.initialize({startOnLoad:true}); graph LR; ImgPlus[\"Image (nD)\"] -- ImgPlusGreyscale[\"Greyscale image (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale8U[\"8-bit greyscale image (nD)\"] ImgPlusGreyscale8U -- ImgPlusGreyscaleMask[\"8-bit mask (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale16U[\"16-bit greyscale image (nD)\"] ImgPlusGreyscale -- ImgPlusGreyscale32F[\"32-bit float greyscale image (nD)\"] ImgPlus[\"Image (nD)\"] -- ImgPlusColor[\"Color image (nD)\"] ImgPlusColor -- ImgPlusColor8U[\"8-bit color image (nD)\"] ImgPlusColor -- ImgPlusColorRGB[\"RGB color image (nD)\"]  The graph above shows the structure for non-dimensional (nD) images. This structure is repeated for 2D, 3D, \u0026hellip; 5D images.\nColor space conversions are automatically applied (e.g. from RGB to greyscale). While trivial for specific color types (like RGB color), JIPipe falls back to following color spaces for generic colors (e.g. greyscale image):\n   Color space Fallback colorspace     Greyscale 32-bit float greyscale   Color RGB color    Frequency space image data types The JIPipe standard library contains color types that are intended to hold frequency-space (FFT) data. While the standard library only provides methods to handle 2D FFT, there are 3D, \u0026hellip;, 5D data types available for future extensions.\n We rely on the mechanisms provided by ImageJ. For example, the ImageJ FFT generates a 8-bit greyscale power spectrum image and attaches data to the image instance. JIPipe has no special methods to load and save the FFT data, aside from the image data itself. We recommend to generate FFT data within the pipeline to generate the correct data.  ImageJ algorithms The standard library provides a selection of common ImageJ algorithms as JIPipe algorithm nodes. Those algorithms wrap around the respective ImageJ methods and have the same feature set, aside from some changes that are required to make algorithms usable in a batch-environment like JIPipe.\nYou can find a list of all algorithms via the  Help menu on the top right corner and the item Algorithm compendium.\nMacro node If an algorithm is not available as JIPipe node, you can use the Macro node.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/graph-editor/",
	"title": "Pipeline editor",
	"tags": [],
	"description": "Explains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.",
	"content": "The graph editor (pipeline editor) allows you to edit the processing steps of a graph compartment. Its user interface is separated into three sections:\n The analysis graph contains the processing steps (also referred as algorithms) The settings panel shows the properties of the currently selected algorithms The toolbar allows you to add more algorithms into the graph, navigate to existing algorithms, change some behavior settings of the graph editor, and create screenshots  Analysis graph The analysis graph contains algorithms that are represented by rectangles. The algorithm graph area will automatically grow depending on where you place the algorithms. Scroll bars will appear if the graph area is larger than the available screen size.\n An alternative to using the scroll bars is to hold the middle mouse button while dragging the your mouse.  Algorithms read data from their input slots and output the results into the output slots. There are some algorithms that do not have input slots - they produce output based on their current parameters. The algorithm user interface has three sections:\n Input slots are located on the top of the algorithm UI. Each slot has a unique name that is displayed below the arrow. The arrow opens a menu that allows you to make/modify connections or change other options specific to the slot. Depending on the algorithm, a + button is created that allows you to add more slots. The drag area allows you to move the algorithm around. Move your  mouse pointer over the area and drag your mouse while holding the 🖱 left mouse button. On clicking the  button, a menu will open that contains some algorithm options. Alternatively you can right-click the drag area to open this menu. Output slots are located on the bottom and allow you to connect your output data to the input of another algorithm.   Any output data is always saved automatically by JIPipe. After generating the final output data, there is no need to connect it to any input.  Slot connections You can connect two slots by clicking the  or  button of a slot and by selecting the source/target slot. Input slots can only receive one connection, while outputs can be distributed to as many inputs as you wish. The selection menu shows all available target slots and its sorted from the nearest to the slot that is furthest away.\nA connection is shows as line between the connected slots. The color of the line indicates if this connection is valid or invalid depending on the data types of the source and target.\n A black line indicates that the data types match exactly. A blue line indicates that the types dont match exactly, but can be converted by JIPipe A red line indicates that the types are incompatible. You will probably get an error message during the calculation.   Hover with your mouse over a slot's name to show information about its data type.  Slot options The slot context menu opened by  or  contain additional entries to managing connections.\n  Label this slot allows you to give the slot a custom name without changing the internal workings of the algorithm (As many algorithms are designed to adress specific slots). On selecting the entry, you can give a custom name that is displayed in cursive. To remove the custom label, label it with an empty text.  Find matching algorithm \u0026hellip; (only output slots) opens a tool that lists all compatible algorithms that can receive the output data as input. Depending on the algorithm, you can remove a slot from within this menu  Algorithm settings The algorithm settings are displayed on the right-hand side and contain all settings of the selected algorithm. There are usually four categories:\n  Parameters contains general parameters, like the name displayed in the drag area, and algorithm-specific parameters like thresholds, the selection of methods, and other parameters.  Slots is an alternative to modifying slots via the algorithm UI. Here, you can also re-order slots.  Annotations is an alternative to modifying slot annotations via the algorithm UI. See above for more info about annotations.  Quick run is a tool to run the analysis only up to the selected algorithm. It allows you to try and compare multiple parameters without creating new nodes. See the testbench documentation for more info.  Toolbar The toolbar contains functions to add new algorithms into the graph, navigate to existing algorithms or search the list of available algorithms, and functions to control the algorithm graph display.\n On the left-hand side you can find a menu containing all available algorithms. On selecting an entry, the corresponding algorithm is added to the graph. The navigator allows you to quickly navigate to an existing algorithm instance or create a new one. Just type one or multiple search terms into the field. On pressing the  arrow down key on your keyboard, the first entry is selected. The view options control how the graph editor behaves and contains some additional utility functions.  View options  and allow you to switch between horizontal and vertial view modes. This does not change the pipeline, but just how it is displayed in the editor. By default, a vertical view is enabled. If you prefer that data flows from left to right, choose the horizontal view mode. automatically aligns all nodes in the algorithm graph according to the algorithm by Sugiyama et. al allows you to change how dragging the middle mouse button changes the current view. is enabled by default and makes it that nodes are automatically aligned on creating connections. This feature does not reorganize the whole graph, but only places the target algorithm to a location that better represents the data flow. crops the graph area to the area taken by the algorithm nodes. Use this tool to find your nodes after scrolling too far away. creates a screenshot of the whole graph compartment that is currently being displayed.  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/result-preview/",
	"title": "Preview from results folder",
	"tags": [],
	"description": "",
	"content": "While JIPipeData allows you to define a custom function for previewing, this only works for data already present in memory. To allow previewing of data stored in a results folder, you need to suppy a JIPipeResultDataSlotPreviewUI that loads the data from disk and generates a preview. We recommend to use JIPipeAsyncResultDataPlotPreviewUI This class will offload the loading and preview generation into a separate thread to prevent the UI from freezing. By default it will use the already defined importFrom(Path) method present in the JIPipeData class and use its already defined preview function.\nYou can override the data loading and other methods for customization.\npublic class MyDataPreviewUI extends JIPipeAsyncResultDataPlotPreview { public MyDataPreviewUI(JTable table) { super(table); } } The preview class is registered as last argument of registerDataType():\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The last null parameter will be handled in the next tutorial  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), MyDataDataSlotRowUI.class, MyDataPreviewUI.class); } } "
},
{
	"uri": "https://www.jipipe.org/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "This section contains video and text tutorials for the most common tasks done with JIPipe.\nTutorial list  Image analysis pipeline\nThis step-by-step tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Image analysis pipeline (Video)\nThis step-by-step video tutorial explains how to create an image analysis workflow with simple algorithms like Gaussian blur, auto thresholding, and distance transform watershed. The segmented objects are quantified and plots are genereated.\n  Creating an extension\nThis step-by-step tutorial explains how to create an JIPipe extension from parts of an existing pipeline without the need for programming.\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/macro-node/",
	"title": "Macro node",
	"tags": [],
	"description": "The macro node allows to run ImageJ macros.",
	"content": "The macro node allows to run existing ImageJ macros or execute algorithms that are not directly available as JIPipe nodes. You will find it in Images \u0026gt; ImageJ Macro.\nInputs and outputs By default, the node has no inputs and outputs. Use to the + button to add them. For example, if you want to process one image and output the processed result, create one input and one output.\nBy default, there are four data types that can be used as input and output:\n Any image data type Results table ROI List Paths  Depending on the data type, JIPipe converts inputs into a format that can be processed by an ImageJ macro. The other way around, JIPipe extracts outputs from via modes that are commonly used in macros.\n Developers can provide their own integrations to add more data types.  Image data As input: The image is opened as ImageJ image window, named according to the slot name. We recommend to use the macro command select(\u0026lt;window name\u0026gt;) to first select the image window before applying the processing.\nAs output: The image is extracted from an image window, named according to the slot name. Use the rename() command to rename outputs accordingly.\nExample (for the node shown above)\n// The input is created as window \u0026#34;Input\u0026#34; selectWindow(\u0026#34;Input\u0026#34;); run(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=2\u0026#34;); // The node expects an image window \u0026#34;Output\u0026#34; rename(\u0026#34;Output\u0026#34;); Results table As input: The table data is opened as the main \u0026ldquo;Results\u0026rdquo; table. We recommend to have only one results table input, as the conversion overwrites the current table.\nAs output: The table data is extracted from the main \u0026ldquo;Results\u0026rdquo; table.\n You should only have one results table input, as only the latest input is used. If you want to merge tables, use JIPipe nodes for this.  ROI data As input: The ROI are added to the ROI manager. Like with the results table data, the existing ROI manager is cleared.\nAs output: The ROI are extracted from the ROI manager.\n You should only have one results ROI List data input, as only the latest input is used.  Path data As input: Paths are defined as string variable, named according to the input slot name. Please note that the slot name must be a valid variable name.\nAs output: A path is extracted from a results table window (row 0, column 0). We do not recommend to extact paths as output, as ImageJ does not have native handling for such data.\n We recommend to only use paths as input. The extraction as output is unpredictable, as ImageJ has not a native way to display this type in a way that can be distinguished from result tables.  Parameters The most important parameters are\n The macro code The list of variables  The Code parameter contains the macro code. You can hide it with Collapse or open the code in a larger editor (in a separate tab).\nVariables The macro node allows you to create parameters that can be directly accessed from within JIPipe. The benefit is that those variables can be exported (custom nodes/group node) for ease of use or applying multiple parameter sets.\nClick the Add parameter button in the Macro parameters category to add a variable/parameter.\nIn the dialog, you have to set following options:\n Select the data type of the parameter The Unique identifier acts both as identifier inside JIPipe and the variable name inside the macro. The Name is displayed in the JIPipe GUI The Description field allows you to provide a documentation displayed at the bottom of the parameter list  Variables inside macros On running the macro node, the final code is assembled by adding variables at the top.\nVariables are assembled as var \u0026lt;Unique identifier\u0026gt; = \u0026lt;Value\u0026gt;. The values are converted as following:\n   JIPipe parameter type ImageJ macro variable type     String String   Byte Integer   Short Integer   Double Double   Float Double   Path String   Boolean Boolean    For example, a Gaussian blur node with a Sigma parameter will generate following code:\n// Code generated from parameters var sigma = 2.0; // Code written in the \u0026#34;Code\u0026#34; parameter selectWindow(\u0026#34;Input\u0026#34;); run(\u0026#34;Gaussian Blur...\u0026#34;, \u0026#34;sigma=\u0026#34; + sigma); rename(\u0026#34;Output\u0026#34;);  Path inputs are converted in a similar way.  "
},
{
	"uri": "https://www.jipipe.org/documentation/expressions/",
	"title": "Expression parameters",
	"tags": [],
	"description": "Explains the expression parameter type language that is often used for filtering or generating numbers.",
	"content": "When using nodes that filter or generate data, you might encounter a parameter type called \u0026ldquo;Expression\u0026rdquo;. This parameter allows to to write simple to complex functions that can test for one or multiple conditions or act as input for a generator node. The basic concept of this expression language is to mix string, boolean, and numeric operations into one simple but powerful language. It allows you for example to first calculate a numeric metric and use it for filtering objects within one line.\nThere are always four components you will interact with:\n Literals like numbers (0.5), strings (\u0026quot;hello world\u0026quot;), and boolean values (TRUE, FALSE) Variables that are supplied from the node itself like x, y, or Area Functions that process literals or variables like MIN(x, 5), STRING_EQUALS(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;). Parameters are separated by commas. Operators that do something with the literals, variables, or function results, like subtraction, concatentation, or conditions  The expression language is interpreted as one line and you cannot write own variables. The result of the one expression is supplied to the node for processing.\nThe user interface of the expression parameter allows you to type the expression via a text field. You can also create new lines if you have longer expressions. They will be all merged automatically. If you are unfamiliar with the expression language, you can click the button to open a tool that lists all available functions and operators. This tool will help you to build expressions and check the syntax.\n To get familiar with expression, use JIPipe's integrated calculator tool (Tools  Development  Calculator). You can play around with any expression you like without breaking something.  Variables Variables are set externally by the node and can contain various useful values. For example, filter nodes will put numbers into the variables. Image generator nodes might put the pixel coordinates into them.\nExample Here the node supplies the variables x and y and expects a number back. You can input a formula that will be automatically applied to ally x and y values:\n(x + y) + x/y + 1 Operators The expressions understand a wide range of common operators for numeric, string, and boolean data:\n You can add, subtract, divide, \u0026hellip; numbers Strings can be concatenated or checked for if one string contains another All basic boolean operators are available  Example You can combine various operators to do complex filtering. Here the node supplies variables Area and MaxWidth:\n(Area \u0026gt; 1000) AND ((MaxWidth^2 / Area \u0026gt; 0.5)) Functions The expression language comes with a large library of predefined functions that you can use for more complex tasks:\nExample To find files, it can be useful to utilize a Glob-filter that can reliably test for the file extension. Here name is the file name and supplied by the node.\nSTRING_MATCHES_GLOB(name, \u0026quot;*.tif\u0026quot;) AND (\u0026quot;data\u0026quot; IN name) Data types The expression language supports five basic data types: Numbers, strings, arrays, and maps\nNumbers Numbers are any kind of number (integer or floating point). Number literals are read as floating point numbers (double).\nExample: 1, 0.5\nStrings Strings are character sequences (texts). They are defined by putting double quotes around a text. If you want to have a double quote inside your string, escape it via \\. If you want a \\ in your text, escape it with another \\.\nExample: \u0026quot;hello world\u0026quot;, \u0026quot;this text has a \\\u0026quot; quote and \\\\ backslash\u0026quot;\nArrays Arrays are collections of values. They are defined via the ARRAY(...) function. Individual items are access via the @ operator and a numeric index starting from zero.\nExample: ARRAY(1,2,3,4) @ 2 will return 3.\nExample: ARRAY(1,2,3,4) @ ARRAY(0,1) will return an array with 1 and 2\nMaps Maps are collections of values where each value is given a unique name. They are defined via the MAP(...) function that should be provided with 2-item arrays (there is a PAIR(key, value) function for this). You can get an array of all keys via the KEYS() function and can access elements via the @ operator.\nExample: MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3)) @ \u0026quot;b\u0026quot; returns 2\nExample: KEYS(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with a, b, and c\nExample: VALUES(MAP(PAIR(\u0026quot;a\u0026quot;, 1), PAIR(\u0026quot;b\u0026quot;, 2), PAIR(\u0026quot;c\u0026quot;, 3))) returns an array with 1, 2, and 3\nOperators There are many operators with alternative ways to write them available. There are two kinds of operators:\n Symbolic operators are using symbols like $, \u0026amp; or * Textual operators are written words like AND or CONTAINS  The difference between the operators is that symbolic operators can be written without spaces. For example you can write 5+5 or !x. Textual operators require spaces to be separated. For example you cannot write NOTx. You have to write NOT x.\n   Operator Description Usage     Logical AND Returns TRUE if both operands are TRUE x AND y or x \u0026amp; y   Logical OR Returns TRUE if one of the operands is TRUE x OR y or x | y   Logical XOR Returns TRUE if exactly one operand is TRUE x XOR y   Logical NOT Returns TRUE if input is FALSE and vice versa NOT x or ! x   Numeric division Divides the left by the right operand x / y   Numeric exponent Calculates left to the power of the right operand x ^ y   Numeric subtraction / Array removal Subtracts right from left (Numbers). If the operands are arrays, the right items are removed from the left array x - y   Numeric multiplication Multiplies the two operands x * y   Numeric addition / String concatenation / Array concatentation Adds two numbers. Concatenates if the operands are strings. Merges two arrays x + y   Numeric greater than Returns TRUE if the left operand is greater than the right one x \u0026gt; y   Numeric greater or equal Returns TRUE if the left operand is greater or equal to the right x \u0026gt;= y   Numeric less than Returns TRUE if the left operand is less than the right one x \u0026lt; y   Numeric less or equal Returns TRUE if the left operand is less or equal to the right one x \u0026lt;= y   Numeric / String / Boolean equality Returns TRUE if the operands are equal x == y or x EQUALS y   Numeric / String / Boolean inequality Returns TRUE if the operands are unequal x != y or x UNEQUAL y   Numeric negation This is technically an operator -x   Numeric modulo Calculates the modulo x % y   Contains Returns TRUE if the one string is contained in the other one (both operands are strings), or if an array contains an item, or a map contains a values x IN y or y CONTAINS x   Variable exists Returns TRUE if the a variable with the name exists x EXISTS   Resolve variable Returns the value of the variable with name. Useful for variables that have spaces in their names or special characters. $ x (Alternative function: GET_VARIABLE(x))   Get item in array/map Returns the array item(s) or string characters of the left operands. The right-hand side can be a number (the index starting from 0) or an array of indices. If the left operand is a map, the indices are whatever the map uses as index x @ y or x AT y    Precedence The operators are ordered according to a precedence table. You might need to use brackets (()) to force the order you expect:\nThe higher the number is the more the operator is preferred.\n   1 2 3 4 5 6 7 8 9 10     OR AND NOT           XOR                Subtraction (x - y) Divide (x / y)  Power (x^y) Negate (-x)         Modulo (x % y)            Multiply (x * y)          Greater than or equal (x \u0026gt;= y)            Greater than (x \u0026gt; y)            Less than or equal (x \u0026lt;= y)            Less than (x \u0026lt; y)            Equal (x == y)            Unequal (x != y)             String contains (x IN y)            Addition (x + y)            String contains (x CONTAINS y)             Variable exists (x EXISTS)              Array/Map access (x @ y) Variable resolve ($ x)    Compatible types Not all operators are compatible to all types. See following table for the operator\u0026rsquo;s behavior:\n   Operator Number Boolean String Array Map     AND Error OK Error Error Error   NOT Error OK Error Error Error   OR Error OK Error Error Error   XOR Error OK Error Error Error   Divide (x / y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Multiply (x * y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Modulo (x % y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) Error Error   Subtract (x - y) OK OK (TRUE=1, FALSE=0) Works (If can be converted to number) OK (both operands are arrays) OK (left operand is map, right operand is array or map)   Addition (x + y) OK OK (TRUE=1, FALSE=0) OK (Conversion to strings, string concatenation) OK (both operands are arrays) OK (both operands are maps)   Equality (x == y) OK OK OK (If types differ, conversion to strings) OK OK   Inequality (x != y) OK OK OK OK OK   Contains (x IN y / x CONTAINS y) Error Error OK OK OK   Less than (x \u0026lt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Less than or equal (x \u0026lt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than (x \u0026gt; y) OK OK (TRUE=1, FALSE=0) Error Error Error   Greater than or equal (x \u0026gt;= y) OK OK (TRUE=1, FALSE=0) Error Error Error   Variable exists (x EXISTS) Works (Converted to string) Works (Converted to string) OK Error Error   Variable resolve ($ x) Works (Converted to string) Works (Converted to string) OK Error Error   Get item in array or map (x @ y) Error Error Error OK OK    "
},
{
	"uri": "https://www.jipipe.org/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "General Can I make the startup faster? Many JIPipe extensions rely on other ImageJ plugins to work. That is why JIPipe always checks if all necessary ImageJ plugins are available. If you are sure that you have everything installed, you can disable this check at Project \u0026gt; Application settings \u0026gt; General \u0026gt; Extensions. Disable Validate ImageJ dependencies.\nUser interface Does JIPipe have a dark mode? Yes, you can enable it in Project \u0026gt; Application settings \u0026gt; UI \u0026gt; General \u0026gt; Theme. Set the theme to Modern dark and restart JIPipe/ImageJ.\nHow can I make long connections without zooming out? Click the arrow button at the input/output slot. It lists all compatible sources/targets ordered by distance.\nCompartments What are those compartments for? Imagine you have a large complicated pipeline. Most certainly, you could split it into multiple sub-pipelines like \u0026ldquo;preprocessing\u0026rdquo; or \u0026ldquo;segmentation\u0026rdquo;. Compartments allow you to do exactly this.\nWhat is the difference between groups and compartments? If you use compartments, JIPipe is still aware of the whole pipeline. This allows it to run all dependency nodes via Update cache or Quick run. Groups are independent pipelines that are not aware where they are used. You can only extract the final outputs, not intermediate steps.\nData processing What happens if I put multiple inputs into a slot? Because each slot holds a table of data and metadata, those tables are merged row-wise.\n Show example     Data     C1_1   C1_2   C1_3    and    Data     C1_4   C1_5   C1_6    are merged into    Data     C1_1   C1_2   C1_3   C1_4   C1_5   C1_6      Why should I care to add those annotations? Annotations are optional for single data analyses or pipelines without multi-input nodes, but helpful anyways. They will allow you to quickly find out from which data set your data was generated.\nIf you have a multi-input node, you will need annotations, as JIPipe needs to figure out which data from which input belongs together.\nYou will find more information here.\nCan you give me an example of multi-input processing? OK, let\u0026rsquo;s imaginge you have two sets of greyscale images (C1 and C2). You want to merge them as channels into an RGB image.\n   Data     C1_1   C1_2   C1_3       Data     C2_1   C2_2   C2_3    The merge channels node has two inputs (one for each channel) and at some point needs to have a table like this to work on:\n   Data (Slot 1) Data (Slot 2)     C1_1 C2_1   C1_2 C2_2   C1_3 C2_3    The issue is now: JIPipe is not aware that you call the images C1_1, C2_1, [\u0026hellip;] and that C1_1 and C2_1 should go together. That\u0026rsquo;s why have to put annotation columns next to the data that will be used by JIPipe:\n   Data #Dataset     C1_1 D1   C1_2 D2   C1_3 D3       Data #Dataset     C2_1 D1   C2_2 D2   C2_3 D3    JIPipe will look at #Dataset and match the rows together that have the same values.\nWhy do you create annotations with a \u0026lsquo;#\u0026rsquo;? There are two kinds of annotations: Ones that only you care about (e.g. the resolution) and the ones the JIPipe should care about. By default all JIPipe\u0026rsquo;s multi-input nodes are configured to only care about annotation columns that begin with #.\nYou can extensively configure this behavior in the node\u0026rsquo;s properties and also manually define which columns JIPipe should look at.\nWhat happens if a reference column is missing? JIPipe will assume an ANY for such columns.\nLet\u0026rsquo;s create an example: Uploading OMERO images require a dataset Id. But often, you only want to upload all images to just one dataset. Here we have three annotated images and just one unannotated OMERO data set.\n   Data #Dataset     Image1 D1   Image2 D2   Image3 D3       Data     OMERO dataset Id    What will to the OMERO data set happen if JIPipe combines the tables?\n   Data #Dataset     OMERO dataset Id {ANY}    It will assume that the one row matches to any #Dataset.\nThe final table will look like this:\n   Data (Slot 1) Data (Slot 2)     Image1 OMERO dataset Id   Image2 OMERO dataset Id   Image3 OMERO dataset Id    Can I preview what the multi-input processing will do without running the node? Yes, switch to the \u0026ldquo;Data batches\u0026rdquo; tab in the properties panel. It allows you to configure how JIPipe merges data together and previews the results.\nDo not forget to refresh after changing a setting.\nImageJ integration Can I use existing ImageJ macros in JIPipe? Yes, use Images \u0026gt; ImageJ macro. The input slots are opened as image windows and can be addressed from within the macro with selectWindow(). You can also load an example that shows how to use the node.\nCan I use JIPipe from within ImageJ macros? Yes. You can use both pipelines and individual JIPipe algorithms from within ImageJ macros and the GUI.\nWhy are some JIPipe algorithms not availabe from within ImageJ? JIPipe has a very general data model that makes it possible to develop pipelines for processing any kind of data. The communication between JIPipe\u0026rsquo;s data types and ImageJ is handled by adaptors that will handle the \u0026ldquo;translation\u0026rdquo; back \u0026amp; forth. For some of such data types, there is no adaptor. The reason behind this is that ImageJ might not have an equivalent data type or feature.\nPerformance How does JIPipe store its data during the analysis? JIPipe stores all necessary inputs and the outputs of each processing step. This means that any kind of large data set will be loaded into the memory at the same time if you set up an iteration.\nFor example, an Import image step will load all the images and then continue with the next steps.\nI have a very large data set. How can I prevent loading it at the same time? You can run JIPipe projects within other JIPipe projects. This will separate them and into individual runs that are iterated one-by-one. JIPipe comes with nodes to extract specific results from those outputs.\nCreate the analysis for only one data set and export project-wide parameters via its project settings. Those parameters will be later modified and should contain anything you need for the project setup. Save it into a *.jip project.\nThen create a separate project and add the nodes Run JIPipe project and Define JIPipe project parameters. In both nodes, you load the main analysis projects.\nResult analysis Can I open a table in ImageJ instead of JIPipe or vice versa? Yes, and even more: Depending on the data type there are multiple options on displaying data available. Select the data in the result view or cache browser and click the ... button at the bottom. JIPipe will even remember the last setting for you.\nCan I save data by their metadata? Yes, use the node Miscellaneous \u0026gt; Export data. It will export all incoming data into one or multiple folders and generates names based on metadata.\nOMERO I do not want to always put in the credentials into each OMERO node. What can I do? Go to Project \u0026gt; Application settings \u0026gt; Extensions \u0026gt; OMERO and set your credentials there. Any OMERO node will supplement unset credentials by those settings.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/",
	"title": "Creating an algorithm",
	"tags": [],
	"description": "Explains how to create a custom algorithm",
	"content": "All algorithms inherit from JIPipeAlgorithm. An algorithm consists of following parts:\n A run() function that runs the workload A reference to an algorithm info that describes the general properties of the algorithm A slot configuration that describes which slots the algorithm should have  JIPipe comes with different base algorithms that provide different feature sets:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.    Any algorithm should have the following basic structure:\n// Annotates documentation to the algorithm @JIPipeDocumentation(name = \u0026#34;My Algorithm\u0026#34;, description = \u0026#34;Does something\u0026#34;) // Sets the algorithm category @JIPipeOrganization(nodeTypeCategory = MiscellaneousNodeTypeCategory.class) // Input and output slots autoCreate automatically creates the slots if set to true and no slot configuration was provided @AlgorithmInputSlot(value = ImagePlusData.class, slotName = \u0026#34;Input\u0026#34;, autoCreate = true) @AlgorithmOutputSlot(value = ImagePlusData.class, slotName = \u0026#34;Output\u0026#34;, autoCreate = true) public class MyAlgorithm extends JIPipeAlgorithm { /* This is the main constructor of the algorithm. It contains a reference to the algorithm info that contains some important metadata */ public MyAlgorithm(JIPipeNodeInfo info) { super(info); } /* A deep copy constructor. It is required. Please do not forget to deep-copy all important fields */ public MyAlgorithm(MyAlgorithm original) { super(original); // Deep-copy additional fields here  } /* The workload is run in this functon. You can also have the ability to inform the user about the current algorithm status for more complex algorithms. You can also query if the user requested cancellation */ @Override public run(JIPipeProgressInfo progress) { // Run your workload here  } } To register the algorithm and provide it with an Id, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // Registers our algorithm with a unique ID and an icon  registerNodeType(\u0026#34;my-algorithm\u0026#34;, MyAlgorithm.class, UIUtils.getIconURLFromResources(\u0026#34;actions/viewimage.png\u0026#34;)); } } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/dependency/",
	"title": "Dependency",
	"tags": [],
	"description": "Project or extension dependency. Refers to an JIPipe extension.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: dependency.schema.json\n Project or extension dependency. Refers to a JIPipe extension.   metadata:  See metadata         id:  string       Unique ID of this dependency should have format  .  :       version:  string       Version of this dependency      Example { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "This section explains the JIPipe user interface, how to create an analysis pipeline, and some concepts behind how analysis pipelines work.\nBatch processing JIPipe is a tool to create data processing workflows via a graphical language. A special feature of JIPipe processing is always done in batches, meaning that workflows are always designed to scale for large amounts of data without the need of external scripts or major changes in a pipeline.\nThe JIPipe graphical language is graph-based where nodes represent data processing algorithms and edges represent that data is transferred from an algorithm output to another algorithm\u0026rsquo;s input.\nAn example is the application of a gaussian filter to an image after loading it:\nmermaid.initialize({startOnLoad:true}); graph LR; A[File] -- B[Load image] B -- C[Apply gaussian]  To design efficient and scalable pipelines yourself, it is a good idea to look into the JIPipe data model.\nGraph compartments A common issue with graphical programming languages is that larger pipelines are hard to navigate. Another issue with such languages is that it is hard to separate functional units for easier readability.\nJIPipe solves both issues with the concept of strongly separated graph components that group a set of algorithms together. Components only can interact via special interface algorithms, making it easier to structure the pipeline.\nPlease take a look at our graph compartment documentation for more information.\nUser interface overview The JIPipe user interface is designed around managing an analysis project. A project contains all information to run an analysis, outside of the input data and can be saved into JSON files. The user interface is separated into three sections:\n The project menu contains all operations for the current project / window. It allows you to open/save projects, access and modify graph compartments, manage plugins, and run the analysis The tab bar allows you to switch between different interfaces associated to the current project. You can close thabs by clicking the x icon. If a tab contains some data that will be lost after closing it, you will have to confirm the action. If no question is asked on closing a tab, you will be able to open it later again without losing data. The current content depends on the selected tab   You can also close a tab by clicking it with the middle mouse button.  Further reading  Batch pipelines\nExplains basic concepts about how data is processed within JIPipe. We really recommend to take a look at this documentation.\n  Pipeline editor\nExplains the graph editor user interface, how to create a pipeline, and additional features like the algorithm finder tool.\n  Expression parameters\nExplains the expression parameter type language that is often used for filtering or generating numbers.\n  Graph compartments\nExplains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.\n  Running a pipeline\nExplains how to run a pipeline and navigate through the results.\n  Testing algorithm parameters\nExplains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.\n  Data caching\nExplains the how JIPipe caches intermediate results and how to access them.\n  ImageJ integration\nExplains functionality that allows ImageJ to run JIPipe algorithms or pipelines.\n  Managing plugins\nExplains how to install and manage plugins.\n  Standard library\nContains some explanations about the algorithms that are included in the JIPipe standard distribution.\n  Extension builder\nExplains the extension builder tool\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/filesystem/",
	"title": "Filesystem algorithms",
	"tags": [],
	"description": "This library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.",
	"content": "The JIPipe standard library contains data types and algorithms to apply file system operations. The common use case is to extract the list of input files for the following algorithms.\nThe filesystem library has two basic data types:\n A  File contains a path to a file A  Folder contains a path to a folder A Path contains a path to a file or folder  In the Add data menu you can define one file/folder or a list of files/folders.\n We recommend to create a list of files/folders. This makes it easier to scale your workflow up.   Drag any set of files or folders into the graph editor to create corresponding file/folder data source algorithms.  File/folder manipulation algorithms The standard library comes with various algorithms that apply common operations to input filesystem data. This includes listing the files in a folder, filtering files/folders, or navigating to a subfolder. They are placed in the Filesystem category.\nAutomated relativization File and folder data source algorithms by default store absolute paths. If you save your project in a parent folder where the data is stored, the paths are automatically converted into relative paths that make data transfer between devices easier.\nAnnotation It is helpful to add data annotations to the file data at some point. This allows algorithms and users to assign data rows to an unique data set. See the annotation standard library documentation for more information.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/graph-compartment/",
	"title": "Graph compartments",
	"tags": [],
	"description": "Explains the concept of graph compartments that allow easy organization of the analysis pipeline into functional units.",
	"content": "A common issue with graphical programming languages is that large graphs are hard to navigate. JIPipe solves this issue by separating the pipeline graph into sub-graphs. Each sub-graph has a predetermined output node that is visible to other compartments. Other nodes on the other hand are not visible to other compartments.\nThe difference between compartments and simple node groups is that compartments only communicate with each other via the compartment output node. JIPipe also only allows you to edit a specific compartment, instead of the whole graph. By default, JIPipe creates three compartments: Preprocessing, Analysis, and Postprocessing.\n By default a compartment's output node is not visible in any other compartment. The have to be connected in a similar manner on how algorithms are connected. To do this, use the compartment editor that is described in the following section.   You can ignore the compartment feature if you want. You can delete the default compartments without any issue. Just leave one graph compartment and edit the remaining one.   Compartments behave similar to algorithms. This means you can create a directed acyclic graph of compartments.  Creating and connecting compartments JIPipe comes with an editor that allows to control the graph compartments. This editor is similar to the pipeline editor and allows you to create new compartments, connect them, as well as import or export compartments. Instead of containg algorithms, the editor contains graph compartment nodes that can be connected similar to how algorithms are connected.\nYou can one or multiple compartments in the editor. Click the  Edit button to open the compartment in the pipeline editor.\n You can also double-click a compartment node to open the editor.  "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/multi-parameter/",
	"title": "Multi-parameter algorithms",
	"tags": [],
	"description": "This library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.",
	"content": "Most algorithms allow handling of multiple parameters via an additional slot that can be optionally enabled. You can find the setting in an algorithm\u0026rsquo;s settings as Multiple parameters. On selecting the item, a new slot will appear that consumes parameter data.\nTo define parameters, use the algorithms found in Add data \u0026gt; Parameters. There are currently two data source algorithms available:\n Define parameter defines a single set of parameters Define multiple parameters lets you define a table of parameters   Use Process  Merge  Merge slots to merge multiple parameter sets.  Defining parameters Both data sources require you to determine which parameters should be created. To do this, add parameters into the Parameters section (red box).\nFor Define multiple parameters, there is an additional element (blue box) that contains a parameter table. Each row represents a parameter set, while a column represents a parameter type. Columns can be added by adding parameters into the Parameters section.\n You can leave the table empty. In this case, the parameters are extracted from the 'Parameters' section.  Select a table cell to open the parameter editor below the table.\nThere are following buttons available:\n Add row adds a new row with standard parameters Generate row allows you to create new rows where one column is generated by the selected generator Replace cells allows you to replace the selected cells in one column with a set of generated parameters  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/parameters/",
	"title": "Parameters",
	"tags": [],
	"description": "",
	"content": "You can add parameters to your algorithm by creating a property with a getter and setter. Then you annotate the getter and setter with the same @JIPipeParameter keys. Also add an @JIPipeDocumentation annotation to either the getter or setter.\nParameters are automatically serialized and deserialized.\nPlease make sure to send an event when the parameter is set, so the UI can update.\n// ... see previous tutorials public class MyAlgorithm extends JIPipeIteratingAlgorithm { private float roundness = 0.5f; // ... see previous tutorials  @JIPipeParameter(\u0026#34;roundness\u0026#34;) @JIPipeDocumentation(name = \u0026#34;Roundness\u0026#34;, description = \u0026#34;Value within [0, 1]\u0026#34;) public float getRoundness() { return roundness; } @JIPipeParameter(\u0026#34;roundness\u0026#34;) public boolean setRoundness(float roundness) { if(roundness \u0026lt; 0 || roundness \u0026gt; 1) return false; // Reject this value  this.roundness = roundness; // Send the change out to listeners  getEventBus().post(new ParameterChangedEvent(this, \u0026#34;roundness\u0026#34;)); } }  Your setter can return a boolean. If the output is true, JIPipe considers the value as valid. If false, the JIPipe UI re-loads a valid value via the getter.   Please make sure that your parameter key is unique. Only one getter and one setter should have the same key.   Not all data types are supported. Data types are registered into JIPipe and available via JIPipeUIParametertypeRegistry.getInstance(). In a later tutorial we show how to register custom data types. JIPipe supports common primitives like boolean, int, float, double, String, and all enum data types.  Parameter settings Some parameter types have different styles or other settings that can change the behavior of the parameter editor UI. An example is StringParameterSettings that allows to change between single-line and multi-line editors.\nSub-parameters JIPipeAlgorithm, like any JIPipeParameterHolder allows sub-parameters.\nTo create a sub-parameter create a getter to an JIPipeParameterHolder and annotate it with @JIPipeParameter. The key provided with the annotation should be an unique parameter key. The parameters in the sub-parameter instance are automatically displayed as new group in the parameter editor.\n Please do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm's event bus. Otherwise there can be issues with the extension builder. You can use the registerSubParameter() method in the constructor and copy constructor as a shortcut.  User-defined parameters If you want to make it possible for users to create custom parameters, create an JIPipeDynamicParameterHolder as sub-parameter. You can control the list of allowed parameter types and other settings.\n Do not forget to deep-copy the JIPipeDynamicParameterHolder. The class has a copy constructor for such an operation.   Please do not forget to listen for the ParameterStructureChangedEvent and pass it to the algorithm's event bus. Otherwise there can be issues with the extension builder. JIPipeAlgorithm comes with a pre-made function registerSubParameters() that should be called in the constructors.  Full control You can inherit from JIPipeCustomParameterHolder to define all parameters manually without the need for an JIPipeDynamicParameterHolder or annotations.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/parallelization/",
	"title": "Parallelization",
	"tags": [],
	"description": "",
	"content": "The current version of JIPipe supports parallelization via a fixed thread pool. Parallelization is done on an per-algorithm-level, meaning that the algorithms are responsible for providing parallelization capabilities.\nThe included base algorithms JIPipeIteratingAlgorithm, JIPipeSimpleIteratingAlgorithm, and JIPipeMergingAlgorithm already come with support for parallelization that has to be manually enabled via code. The inherit from JIPipeParallelizedAlgorithm and completely apply parallelization automatically.\nAutomated parallelization (JIPipeParallelizedAlgorithm) The automated parallelization is controlled by three factors:\n If the user enabled parallelization via a parameter If parallelization is supported In how many batches the data is separated  To enable parallelization, let supportsParallelization() return true (defaults to false). This will parallelize the processing of data interfaces (see previous chapters). As sometimes third-party algorithms apply their own parallelization, you can restrict how many threads are allocated by JIPipe by setting getParallelizationBatchSize.\nFor example, there are many image analysis algorithm implementations that use Runtime.getRuntime().availableProcessors() for their own parallelization. To ensure that only as many threads as the user selected are allocated, return Runtime.getRuntime().availableProcessors() from getParallelizationBatchSize(). The implementation then will adapt to this value.\npublic class MyAlgorithm extends JIPipeIteratingAlgorithm { /* Enable parallelization. By default false. */ @Override isParallelizationEnabled() { return true; } /* Assume that each runIteration() executes a third-party algorithm with its own parallelization based on Runtime.getRuntime().availableProcessors() threads. Tell this to the JIPipe implementation to limit the number of threads. */ @Override getParallelizationBatchSize() { return Runtime.getRuntime().availableProcessors(); } } Manual parallelization You can choose to do your own parallelization (leave isParallelizationEnabled() to return false). Each JIPipeAlgorithm object has a method getThreadPool() that returns the thread pool assigned to the current run. Please note that this thread pool can be null.\nThe thread pool provides methods to schedule workloads. If the number of threads is set to 1, the thread pool will schedule the workload into the current thread. You also have raw access to the ExecutorService behind the thread pool - just do not forget that the service can be null.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/custom-info/",
	"title": "Custom algorithm info",
	"tags": [],
	"description": "",
	"content": "In the previous tutorials we used the standard way of creating algorithms. This might not be sufficient if you want to generate algorithms, for example by importing ImageJ algorithms, loading algorithms from JSON or generate algorithms for an unknown list of data types.\nHow algorithms are registered Algorithm instances are created by an JIPipeNodeInfo. This info is the object that is actually registered into JIPipe. It is able to create new instances of the declared algorithm, or copy it. It also carries basic metadata such as a name, description, or annotation preferences.\nDeclarations should be unique and have a unique ID within the JIPipe algorithm registry.\nOn registering an algorithm like in previous tutorials, following code is run:\npublic void registerNodeType(String id, Class\u0026lt;? extends JIPipeAlgorithm\u0026gt; algorithmClass) { registerNodeType(new JIPipeJavaAlgorithmRegistrationTask(id, algorithmClass, this)); } The code generates a task that just checks if all algorithm dependencies are loaded. If all dependencies are available, the task runs:\nJIPipeAlgorithmRegistry.getInstance().register(new JIPipeNodeInfo(id, algorithmClass), source); The important bit is JIPipeNodeInfo. In the end an algorithm info is created that extract algorithm information from the class annotations.\nCreating a custom info To create a custom info, inherit from JIPipeNodeInfo. The most important functions are clone() and newInstance().\nRegister the info either via a direct call to registerNodeType(JIPipeNodeInfo) or (recommended) via a task that inherits from JIPipeNodeRegistrationTask. You can inherit from the default implementation JIPipeDefaultNodeRegistrationTask that comes with pre-made functionality to check for common dependencies. The reason behind using a task is that some algorithm-internal classes might require that data types or annotation types are already registered.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph-edge/",
	"title": "Graph Edge",
	"tags": [],
	"description": "Edge in a graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph-edge.schema.json\n Edge in a graph   source-node:  string       Algorithm ID of the edge source   target-node:  string       Algorithm ID of the edge target   source-slot:  string       Slot name within the edge source algorithm   target-slot:  string       Slot name within the edge target algorithm      Example { \u0026#34;source-node\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-node\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/",
	"title": "Java API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe Java API that allows you to create SciJava plugins to extend JIPipe. The Java API is very powerful and allows you to add algorithms, annotation types and new data types. It also allows you to create UI-only components such as parameter editors, plots, and table processing operations.\nYou can refer to the JIPipe JavaDocs for more information about the API specifics. The following tutorials will show you to implement your own Java extensions via small examples.\n JavaDocs\nProvides a link to the JavaDocs\n  Creating an extension project\nExplains how to setup a SciJava plugin project to extend JIPipe\n  Creating an algorithm\nExplains how to create a custom algorithm\n  Creating a data type\nExplains how to create custom data types\n  Creating a parameter type\nExplains how to create an UI for a parameter\n  Usage in Java\nExplains how to use the JIPipe API to run graphs, algorithms, or projects within pure java code\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/result-analysis/",
	"title": "Running a pipeline",
	"tags": [],
	"description": "Explains how to run a pipeline and navigate through the results.",
	"content": "JIPipe stores its results in a user-defined output folder. After clicking  Run (located at the top right corner of a project window) JIPipe will query the output folder from you. You can also generate a random folder that will be located on your operating system\u0026rsquo;s temporary directory by clicking the button.\nAfter confirming the settings by clicking  Run now, JIPipe will start processing the pipeline.\n You can have as many runs as you want. Runs will not execute in parallel, but be scheduled to wait until the current run finishes.   The JIPipe output folder is automatically organized in a standardized way, so JIPipe can open a result folder. You find the \"Open analysis output ...\" button in the \"Project\" menu.  Result analysis After all results are generated, the result analysis UI will be automatically opened. It allows you to navigate through the results, and import them back into ImageJ (if supported by the generated data type).\nThe UI has two main components:\n The slot tree shows a hierarchy of all data slots. It is organized by compartment, then algorithm, and finally data slot. By selecting any of the entries, all data associated to the selection or any n-child is displayed. The output data table lists the stored data of the selected slot(s) as table (if you are unfamiliar why this is, please take a look at the explanation on how JIPipe processes data)  After selecting a set of slots in the slot tree the output data table will update to only display the data of the selected slots. The table has following columns:\n (Optional) Compartment shows in which graph compartment the generating algorithm is located (Optional) Algorithm shows the name of the algorithm that generated the data. Location is the folder name where the data is located relative to the slot directory Data shows a string representation of the data row. The contents vary depending on the slot data type. For example, file system data display their path at this location. Additional columns correspond to the data annotations that were attached by various algorithms  Importing results back into JIPipe/ImageJ/\u0026hellip; On selecting one or multiple rows, additional UI elements are displayed below the table. They contain various actions that can be applied to the output data, such as opening the results directory, importing the data back into ImageJ or JIPipe, or any other operation.\n Double-click a row to execute the default action, which is the one most commonly used.  -- "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/algorithm/context-actions/",
	"title": "Context actions",
	"tags": [],
	"description": "",
	"content": "Context actions allow you to add custom buttons into an algorithm\u0026rsquo;s parameter group that by default will also appear within a node\u0026rsquo;s context menu. They can be used for multiple purposes such as loading example data, applying an auto-configuration, opening websites, or displaying documentation or data in a new tab.\nTo create one, annotate a public function with @JIPipeDocumentation and @JIPipeContextAction. The function should have one parameter: an instance of JIPipeWorkbench.\n@JIPipeDocumentation(name = \u0026#34;Load example\u0026#34;, description = \u0026#34;Loads example parameters that showcase how to use this algorithm.\u0026#34;) @JIPipeContextAction(iconURL = ResourceUtils.RESOURCE_BASE_PATH + \u0026#34;/icons/actions/graduation-cap.png\u0026#34;) public void setToExample(JIPipeWorkbench parent) { // Insert code here } "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/data-type/",
	"title": "Creating a data type",
	"tags": [],
	"description": "Explains how to create custom data types",
	"content": "Custom JIPipe data types must inherit from JIPipeData. It is required to add an @JIPipeDocumentation annotation that provides a name and brief description of the data type.\nJIPipe requires that data can be saved to a folder within the output directory. We also recommend that you include code that can load the data back into JIPipe or ImageJ in some form.\nThere are no requirements on the constructor of the data type. The only requirement is that there is a function importFrom(Path) that imports JIPipeData from a row storage folder.\nThe folder that is provided in storageFilePath is unique to the data and empty. The name parameter in storageFilePath is usually the data slot name and can be used as template for file names. It can be ignored undless forceName is true. The reason behind this is that then the name is pre-generated in a unique way for saving the data at a non-standard location (e.g. exporting the data). In such cases all file or folder names within the storage path should contain the name in some way, even if the import function cannot load the exported data anymore.\nThere are two optional functions that you can override:\n display() shows the data in ImageJ, JIPipe, or any other GUI preview() generates a GUI component that acts as thumbnail/preview of the contained data  public class MyData implements JIPipeData { String value; public MyData() { } // Constructor that initializes the data  public MyData(String value) { this.value = value; } @JsonGetter(\u0026#34;value\u0026#34;) public String getValue() { return value; } @JsonSetter(\u0026#34;value\u0026#34;) public String setValue(String value) { this.value = value; } // This should return a deep copy  @Override public JIPipeData duplicate() { return new MyData(value); } // The display method is optional, but recommended  @Override public void display(String displayName, JIPipeWorkbench workbench) { JIPipeTextEditor editor = JIPipeTextEditor.openInNewTab(workbench, displayName); editor.setMimeType(getMimeType()); editor.setText(data); } // The preview method is optional, but recommended for many cases  // The width and height are guidelines you should adhere to (especially the height)  @Override public Component preview(int width, int height) { // This example would overlap with toString()  return new JLabel(value); } // Do not forget to override this  @Override public String toString() { return StringUtils.orElse(value, \u0026#34;\u0026#34;); } @Override public void saveTo(Path storageFilePath, String name, boolean forceName, JIPipeProgressInfo progress) { try { JsonUtils.getObjectMapper().writeValue(storageFilePath.resolve(name + \u0026#34;.json\u0026#34;).toFile(), this); } catch(Exception e) { throw new RuntimeException(e); } } // We will use this method later to load the data back from disk  public static MyData fromJson(Path jsonFile) { try { return JsonUtils.getObjectMapper().readValue(jsonFile.toFile(), MyData.class); } catch(Exception e) { throw new RuntimeException(e); } } // Do not forget to add this method or JIPipe will refuse to start  public static MyData importFrom(Path rowStorageFolder) { // You can use the PathUtils  Path targetFile = PathUtils.findFileByExtensionIn(storageFilePath, \u0026#34;.json\u0026#34;); return fromJson(targetFile); } }  You can use JIPipe's JsonUtils class to get access to a Jackson JSON ObjectMapper.   Do not forget to override toString(), as the string representation will be displayed in the cache browser.  To register the data type and provide it with an id, and icon, use JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // The two null parameters will be handled in the next tutorials  // You can leave them null if you want. This is valid.  registerDataType(\u0026#34;my-data\u0026#34;, MyData.class, ResourceUtils.getPluginResource(\u0026#34;/icons/data-types/data-type.png\u0026#34;), null, null); } } "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/annotations/",
	"title": "Data annotation algorithms",
	"tags": [],
	"description": "This library provides basic functionality to add annotations to data slot rows.",
	"content": "Data annotations allow JIPipe algorithms and users to assign an unique data set to the data located in a data slot. The standard library contains various algorithms that allow to generate, manipulate, and utilize those annotations.\nWe recommend to use the algorithms in Annotation \u0026gt; Generate while setting up filesystem operations or any other import step to prevent issues in following algorithm steps.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/graph/",
	"title": "Graph",
	"tags": [],
	"description": "A graph",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: graph.schema.json\n A graph   nodes:  object   [object Object]      The nodes. Keys are the unique algorithm instance IDs. See graph-node        edges:  object[]       The edges. IDs in the edge definition must be consistent to the IDs in the 'nodes' entry See graph-edge           Example { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/",
	"title": "JSON API documentation",
	"tags": [],
	"description": "",
	"content": "This section is about the JIPipe JSON API that includes the API for creating JSON extensions, but also other data types like a project.\n  Project file specification   JSON extension file specification   JSON objects The JSON API is object-oriented and re-uses different object types in multiple occasions. You will be referred to the specified documentation.\n Algorithm node\nNode in a graph\n  Algorithm type\nDefines a new algorithm\n  Dependency\nProject or extension dependency. Refers to an JIPipe extension.\n  Graph Edge\nEdge in a graph\n  Graph\nA graph\n  Extension\nAn extension that can be put into the ImageJ plugin folder\n  Metadata\nCommonly used metadata type in JIPipe.\n  Point\nA point\n  Project\nAn analysis project\n  Slot definition\nDefines a data slot\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/quick-run/",
	"title": "Testing algorithm parameters",
	"tags": [],
	"description": "Explains the Quick Run feature that allows to test and compare different algorithm parameters without recalculating the whole pipeline.",
	"content": "Many algorithms require plenty of user-defined parameters to create the expected results. Finding those parameters on the other hand can be very time-consuming due to the requirement of repeating all previous and following processing steps.\nJIPipe comes with a feature termed Quick Run that makes it easier to only test a part of an analysis pipeline. You can find the testbench by selecting an algorithm in the algorithm graph and selecting the  Quick Run tab.\nIt will ask for a folder where to store algorithm outputs. For most cases, you can leave the folder as is - but if you expect to generate large amounts of output data, you should select a folder on a drive that can store as much data. Click  Run \u0026amp; open results to create the testbench. JIPipe then will run the pipeline up until the selected algorithm and open a new tab.\n The Quick Run expects that all relevant algorithms are valid and will tell you if it finds issues. Please fix the issues and click \"Retry\".   You can also do a Quick Run from an algorithm's right-click context menu.  If you click {\u0026lt; icon name=\u0026quot;fa-cog\u0026rdquo; size=\u0026quot;medium\u0026rdquo; \u0026gt;}} Run, the results will not be shown. Instead, if enabled, data will just be stored into the Cache\nResult UI After clicking  Run \u0026amp; open results and generating the results, JIPipe will open a new tab in its user interface. It contains a modified version of the result analysis interface that also allows you to change the algorithm parameters and create and load result snapshots of the current algorithm.\nThe user interface is separated into following components:\n The algorithm parameters of the selected algorithm are displayed on the left-hand side. You can change them and create a  New test The results are displayed in the result analysis panel. See the result analysis documentation for more information on how it is used. The testbench allows you to compare multiple parameter sets. On creating a  New test, the results from previous tests are accessible via the drop-down menu. You can also re-label the current parameter set by clicking the  button.  Testing a batch of parameters The testbench currently has not the capabilites to generate a set of parameters. We recommend to use the multi-parameter algorithm feature that was designed to manage parameter sets.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/cache/",
	"title": "Data caching",
	"tags": [],
	"description": "Explains the how JIPipe caches intermediate results and how to access them.",
	"content": "JIPipe has a project-wide cache for generated results. This cache can be accessed by algorithms to prevent repeating previous calculation steps.\nCache items are assigned a unique identifier ( Snapshot) that is based on relevant algorithm parameters and the processing pipeline behind the data generation. You have multiple ways to manage and access the cache. First, in the top tool bar, there is a summary on how many items are currently cached. If items are stored in the cache, you have multiple options to clear the cache.\nIf you select an algorithm, you have access to its  Cache browser that lists all  Snapshots and all stored data, including a string representation, and annotations if available. By selecting a row in the data table below, you can  Show the item\u0026rsquo;s data. The operation depends on the exact data type. ImageJ images for example are opened in ImageJ.\nIf an algorithm data slot has cached data, icons appear next to the slot. Hover the items with your mouse to show a summary. Clicking the items allows you to manage the cache or display the results in a full-window cache browser.\n"
},
{
	"uri": "https://www.jipipe.org/citation/",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nThe publication is currently in preparation. Please visit this page again later.\n Thanks!\nJIPipe was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n   \n "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/parameter-type/",
	"title": "Creating a parameter type",
	"tags": [],
	"description": "Explains how to create an UI for a parameter",
	"content": "JIPipe requires you to register custom parameter types, where they are assigned an unique identifier. This is done to allow future refactoring without breaking a user\u0026rsquo;s project.\nA custom parameter type must be JSON-serializable via the Jackson library. It is associated to an editor UI that is responsible for updating the parameter value from the GUI.\n A parameter type cannot be a generic class. This is due to restrictions in the JVM. We recommend to create a sub-class for a list of a parameter if you require a list of it down the line. The list parameter inherits from the ListParameter class.  Creating an editor To create an editor UI, you have to inherit from JIPipeParameterEditorUI.\nThe UI class provides access to the JIPipeParameterHolder object and the JIPipeParameterAccess object that encapsulates the getter and setters, as well as additional annotations.\nThere is also access to the SciJava context object.\n Please be careful to avoid infinite loops between reloading and setting parameters from UI elements.  Registering a parameter Register the parameter type and its UI in JIPipeJavaExtension:\n@Plugin(type = JIPipeJavaExtension.class) public class MyExtension extends JIPipeDefaultJavaExtension { // ... See previous tutorial for other methods  @Override public void register() { // You have to provide an unique ID, the parameter class, a method to create a new instance, a method to create a deep copy, and an UI class  registerParameterType(\u0026#34;my-parameter\u0026#34;, MyParameter.class, MyParameter::new, p -\u0026gt; p.clone(), \u0026#34;My parameter\u0026#34;, \u0026#34;A custom parameter type\u0026#34;, MyParameterParameterEditorUI.class); // If you have a hierarchy of parameters, you can register the editor for the whole hierarchy:  registerParameterEditor(MyCollectionBase.class, MyCollectionParameterEditorUI.class); // There is a predefined method to register enum values:  registerEnumParameterType(\u0026#34;my-enum\u0026#34;, MyEnum.class, \u0026#34;My Enum\u0026#34;, \u0026#34;Enum of values\u0026#34;); } }  Do not forget to register all algorithm parameter types. JIPipe will throw an error if it detects a missing parameter registration.   There is an overload of registerParameterType that takes the matching list directly and automatically generates the ID, name, and description.   You can set the instance creation function to null if the parameter is default-constructable. You can set the clone function to null if the parameter type can be copied via a copy constructor.   You can review your parameter UI via Tools  Development  Show all parameter types.  Making use of the parameter registration You can use the parameter type registry to get a parameter type info. The info provides access to all metadata from the registry.\nJIPipe comes preinstalled with some common Java types (String, numerics, file and folder paths). You can take a look at the Parameters Extension package for all default parameters that are provided by JIPipe.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/json-extension/",
	"title": "Extension",
	"tags": [],
	"description": "An extension that can be put into the ImageJ plugin folder",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: json-extension.schema.json\n An extension that can be put into the ImageJ plugin folder   id:  string       Unique ID of this extension. Should have format  .  :       version:  string       Version of this extension   metadata:  See metadata        General metadata about the extension   algorithms:  object[]       List of added algorithms See algorithm           Example { \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:example-list-tiff\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Example extension\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;An example extension\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;algorithms\u0026#34; : [ { \u0026#34;id\u0026#34; : \u0026#34;folder-list-tif\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;List TIFF files\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Lists all TIFF files in a folder\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;category\u0026#34; : \u0026#34;Converter\u0026#34;, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;default-preprocessing-filter-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Filtered files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Filtered files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 250 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;file-filter\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;Filter *.tif\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filterString\u0026#34; : \u0026#34;*.tif\u0026#34; } ], \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } }, \u0026#34;default-preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;Folders\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;folder\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Files\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;file\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;{Vertical}\u0026#34; : { \u0026#34;x\u0026#34; : 25, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;jipipe:algorithm-type\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;description\u0026#34; : null, \u0026#34;jipipe:trait-generation\u0026#34; : { \u0026#34;modification\u0026#34; : { \u0026#34;per-slot\u0026#34; : { }, \u0026#34;global\u0026#34; : { } }, \u0026#34;transfer\u0026#34; : { \u0026#34;transfers\u0026#34; : [ ], \u0026#34;transfer-all-to-all\u0026#34; : true } }, \u0026#34;jipipe:dynamic-parameters\u0026#34; : { } } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;default-preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;default-preprocessing-filter-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34; } ] }, \u0026#34;menu-path\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;graph-wrapper-algorithm\u0026#34;, \u0026#34;preferred-traits\u0026#34; : [ ], \u0026#34;unwanted-traits\u0026#34; : [ ], \u0026#34;added-traits\u0026#34; : [ ], \u0026#34;removed-traits\u0026#34; : [ ] } ], \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;json-extension\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation/imagej-integration/",
	"title": "ImageJ integration",
	"tags": [],
	"description": "Explains functionality that allows ImageJ to run JIPipe algorithms or pipelines.",
	"content": "ImageJ to JIPipe JIPipe integrates commonly used data types and popular algorithms from ImageJ. If an algorithm is not available for JIPipe, you can still run them via the Macro node. There is also a Python script node available that behaves similar to the macro node.\nJIPipe to ImageJ JIPipe algorithms and pipelines can be executed from within an ImageJ environment. There are two ways JIPipe integrates back into ImageJ:\n You can run a pipeline project from a macro/command You can run JIPipe algorithms from a macro/command if the slot data types are supported by ImageJ  Running a pipeline You can run an JIPipe pipeline via the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe project. It will ask you the project file and the output directory.\nTo run the command via a macro, run:\nrun(\u0026quot;Run JIPipe project\u0026quot;, \u0026quot;projectFile=\u0026lt;Project\u0026gt;, outputDirectory=\u0026lt;Directory\u0026gt;, threads=\u0026lt;Threads\u0026gt;\u0026quot;)  There can be issues using the macro recorder depending on which ImageJ algorithms are used. This issue is especially prevalent in ImageJ macro algorithm nodes.  You can also run JIPipe in headless-mode just like any ImageJ2 algorithm:\n./ImageJ-linux64 --headless --ij2 --run \u0026#34;Run JIPipe project\u0026#34; \u0026#39;projectFile=\u0026#34;\u0026lt;Project\u0026gt;\u0026#34;, outputDirectory=\u0026#34;\u0026lt;Directory\u0026gt;\u0026#34;, threads=\u0026lt;Threads\u0026gt;\u0026#39;  While JIPipe works in Headless-mode, some ImageJ algorithms don't. You will get an error message if an algorithm requires a graphical environment.  Running a single algorithm JIPipe algorithms can be run from ImageJ macros/commands if the slot data types are compatible with ImageJ. By default, this includes any image data type, result tables, and regions of interest (via ROIManager). If you run the command Plugins \u0026gt; JIPipe \u0026gt; Run JIPipe algorithm, a dialog with all available algorithms, parameters, and more information is shown.\nA difference to the parameter panel of an algorithm within the graph editor UI is that you have to select the input image.\nOutput data is created according to the slot name. For example if the output slot name is Output, the created image window will also be named Output.\n Just as in a graph, images are converted automatically to the data type specified by the algorithm.   There may be issues if multiple ROI or result table outputs are generated. JIPipe will merge multiple ROI List data items into one Results Table.   There can be issues using the macro recorder depending on which ImageJ algorithm is executed. This issue is especially prevalent in ImageJ macro algorithm nodes.  To run the command via a macro, run:\nrun(\u0026quot;Run JIPipe algorithm\u0026quot;, \u0026quot;algorithmId=\u0026lt;Algorithm\u0026gt;, algorithmParameters=\u0026lt;Parameters\u0026gt;\u0026quot;) The algorithm ID can be looked up via the plugin manager. Algorithm parameters are provided as string in JSON format. The JSON data should have following structure:\n (Optional) An object parameters that contains the algorithm parameters. They are equal to the parameters saved in an JIPipe project file. We recommend to use the Copy command button to obtain the parameters. If you leave out parameters, the default value is assumed. (Optional) An object add-input that contains additional input slot definitions. The entry keys are the slot names. (Optional) An object add-output that contains additional output slot definitions. The entry keys are the slot names. (Optional) An object input. Entry keys correspond to the slot name. The entry value is a string that corresponds to the Window name that contains the data. Only required for image data types, as JIPipe accesses the global ROI manager and global result table.   Use the \"Copy command\" button in the \"Run JIPipe algorithm\" GUI command to quickly create a valid macro for your parameters.  "
},
{
	"uri": "https://www.jipipe.org/documentation/plugins/",
	"title": "Managing plugins",
	"tags": [],
	"description": "Explains how to install and manage plugins.",
	"content": "JIPipe has its own plugin (extension) system that is independent of the one provided by ImageJ/SciJava. You can find a list of plugins in Plugins \u0026gt; Manage plugins.\nJIPipe by default supports two types of extensions:\n Java extensions are similar to ImageJ plugins (*.jar) and are the most powerful plugin type. Just like ImageJ plugins, they are located in the plugins directory. JSON plugins are similar to ImageJ macros or scripts, as they are pure text files. Such extensions can be created without programming via the JSON Extension Builder  Some plugins require that dependencies are installed and will notify you if something is wrong. To check if all plugins are in working condition, check if the top right button displays  All plugins valid. Otherwise click the button to show what went wrong and how to solve the issue.\n"
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/plots-tables/",
	"title": "Plots and tables",
	"tags": [],
	"description": "This library provides operations to generate and modify tables, as well as creating plots.",
	"content": "The standard library contains algorithms and data types that allows to manipulate tables, and create plots. The table data type is the JIPipe wrapper for the ImageJ results table (see ImageJ integration).\nManipulating tables Table manipulation operations are located in Process \u0026gt; Tables and allow you to add, remove, or replace columns.\nCreating plots Plots can be created via the Analyze \u0026gt; Plot \u0026gt; Plot tables algorithm that processes each incoming result table and produces an automatically generated plot. You can decide which plot type is generated, and how to assign the columns of the input tables to the data series as expected by the plot. Plots are exported automatically as PNG and SVG in the size set up within the algorithm node settings.\nYou can later import the plot back into the JIPipe plot editor that has more options available.\nPlot editor JIPipe comes with a plot editor GUI that allows more refined control over plots than by the standard Plot tables algorithm (for example multiple series). You can either open a plot from results, or create a new plot from scratch via Project \u0026gt; New plot.\nThe settings panel of the plot editor is split into three tabs:\n  Settings contains all general parameters of the plot. It also allows you to change the plot type.  Series contains all data series. A series is a collection of string or number arrays that is used as input for the plot. Depending on the plot type, there can be multiple series (e.g. the line XY plot can display multiple lines)  Data contains a list of data columns that can be assembled to series. You can open the columns in the table editor or import columns from a CSV file. JIPipe also supports generating columns that do not carry any data, but instead generate the requested number of rows.  Table editor While JIPipe prefers opening tables in ImageJ\u0026rsquo;s table view, it contains a table editor that allows you to do basic operations directly from within JIPipe.\nYou can find the operations on the right-hand side. They include some basic operations like modifying rows and columns, and specialized operations for scientific data, such as splitting values by category, quickly integrating the table, and combining columns into a single condition column.\n"
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/metadata/",
	"title": "Metadata",
	"tags": [],
	"description": "Commonly used metadata type in JIPipe.",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: metadata.schema.json\n Commonly used metadata type in JIPipe.   name:  string       A name   description:  string       A description   authors:  string       Comma-separated list of authors   website:  string       Website of the project   license:  string       Name of the license   citation:  string       Citation for the publication      Example { \u0026#34;name\u0026#34; : \u0026#34;Image property annotations\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used annotations for describing image properties\u0026#34;, \u0026#34;authors\u0026#34; : \u0026#34;Zoltán Cseresnyés, Ruman Gerst\u0026#34;, \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD-2\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/python/",
	"title": "Python integration",
	"tags": [],
	"description": "This library provides nodes that allow to run Python scripts.",
	"content": "The standard library contains nodes that allow to run Python scripts using the Jython library. Python scripts have access to all JIPipe and ImageJ APIs that are available at runtime.\nYou can find the nodes in the Miscellaneous menu. You can find algorithms equivalent to each of the Java standard algorithms:\n   Algorithm type Purpose     JIPipeAlgorithm The base class of all algorithms. It provides no included functionality outside of absolutely necessary ones.   JIPipeParameterSlotAlgorithm This algorithm allows users to run multiple parameter sets by optionally enabling an additional slot Parameters.   JIPipeSimpleIteratingAlgorithm A JIPipeParameterSlotAlgorithm that has one input slot and iterates over the input rows.   JIPipeIteratingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches.   JIPipeMergingAlgorithm A JIPipeParameterSlotAlgorithm that can have multiple input slots and match annotations of the input data to create data batches. The difference to JIPipeIteratingAlgorithm is that a batch can have duplicate items per slot.     Due to restrictions in the Jython library, Python libraries that are built on a native backend (such as Numpy) will not work.   As JIPipe builds on the functionality provided by ImageJ. Please refer to the ImageJ documentation to find information on how to expand Jython with additional libraries.  "
},
{
	"uri": "https://www.jipipe.org/documentation-java-api/usage-in-java/",
	"title": "Usage in Java",
	"tags": [],
	"description": "Explains how to use the JIPipe API to run graphs, algorithms, or projects within pure java code",
	"content": "The JIPipe API allows you to run algorithms, graphs, and projects in a pure Java environment without the need for a GUI or through ImageJ1 or ImageJ2 scripts.\nPrerequisites To use the JIPipe API JIPipe must be initialized first. This requires an ImageJ instance or any other way to load SciJava plugins. The following example shows how to initialize JIPipe.\npublic static void main(String[] args) { // Extract necessary SciJava variables  // An alternative is to create a @Plugin and execute this plugin via ImageJ  final ImageJ ij = new ImageJ(); Context context = ij.context(); // Execute the JIPipe registration if necessary  if (JIPipe.getInstance() == null) { JIPipe.createInstance(context); JIPipe.getInstance().initialize(); } // JIPipe is now ready to use } Loading and running a project You can load a project via a static method. Running the project either involves enqueuing a run into the global queue or running it on the current thread. The run has a multitude of settings that control how/if output is written or how many threads are used.\npublic static void main(String[] args) { // First initialize JIPipe before this line!  // Load the project  // JIPipe will put any non-exception errors or warnings into the report  JIPipeValidityReport report = new JIPipeValidityReport(); JIPipeProject project = JIPipeProject.loadProject(Paths.get(\u0026#34;my-project.jip\u0026#34;), report); // Create a run that generates a deep-copy of the project\u0026#39;s graph  // The run is controlled by the JIPipeRunSettings instance that allows you to  // have runs without caching or writing outputs if needed  JIPipeRunSettings settings = new JIPipeRunSettings(); settings.setOutputPath(Paths.get(\u0026#34;/data/my-project-output\u0026#34;)); JIPipeRun run = new JIPipeRun(project, settings); // Option 1: Run in separate thread (Async)  JIPipeRunnerQueue.getInstance().enqueue(run); // Option 2: Run it on the current thread  // The run itself has a property getProgressInfo() that allows access to the progress \u0026amp; log  run.run(); } Loading a result To load an existing result folder, the run is imported back into JIPipe. The run itself contains a graph instance with nodes that are aware of the data storage location. The storage location contains a data-table.json file that can be imported into an exported data table. This table contains all metadata and the relative storage location of each row.\nRow data is always stored in folders that correspond to the row index. For example, the first row\u0026rsquo;s data is stored in a folder 0.\npublic static void main(String[] args) { // First initialize JIPipe before this line!  // Load the run  // It will load the project as well  Path path = Paths.get(\u0026#34;/data/my-project-output\u0026#34;); JIPipeRun run = JIPipeRun.loadFromFolder(path, report); run.getProject().setWorkDirectory(path); // You can now access the run\u0026#39;s graph and access the data slots  JIPipeDataSlot slot = run.getGraph().getNodes().get(\u0026#34;some-node\u0026#34;).getOutputSlot(\u0026#34;Output\u0026#34;); // Load the slot\u0026#39;s data table  JIPipeExportedDataTable table = slot.getStorageDataTable(); // Example: Get the folder where the first row stores its data  Path firstRowStorage = slot.getRowStoragePath(0); } Building and running a graph JIPipe allows to create and run graphs without involving a project. A simple graph runner is available to execute a graph.\npublic static void main(String[] args) { // First initialize JIPipe before this line!  JIPipeGraph graph = new JIPipeGraph(); // There are multiple ways to instantiate a new node:  // Option 1: Utility function  JIPipeGraphNode first = JIPipe.createNode(\u0026#34;import-file\u0026#34;, JIPipeGraphNode.class); // Option 2: Using the registry  JIPipeGraphNode second = JIPipeNodeRegistry.getInstance().getInfoById(\u0026#34;import-imagej-imgplus-from-file\u0026#34;).newInstance(); // Add the nodes into the graph and connect them  graph.insertNode(first, JIPipeGraph.COMPARTMENT_DEFAULT); graph.insertNode(second, JIPipeGraph.COMPARTMENT_DEFAULT); graph.connect(first, second); // Use the graph runner  // We always recommend to make a copy of the graph if it is used somehere else  JIPipeGraphRunner run = new JIPipeGraphRunner(new JIPipeGraph(graph)); // Option 1: Run in separate thread (Async)  JIPipeRunnerQueue.getInstance().enqueue(run); // Option 2: Run it on the current thread  // The run itself has a property getProgressInfo() that allows access to the progress \u0026amp; log  run.run(); } Running a single node You can run single algorithm nodes without involving a project or a graph:\npublic static void main(String[] args) { // First initialize JIPipe before this line!  JIPipeSimpleIteratingAlgorithm node = JIPipe.createNode(\u0026#34;import-imagej-imgplus-from-file\u0026#34;, JIPipeSimpleIteratingAlgorithm.class); // Always clear the node first (allows you to re-use it)  node.clearSlotData(); // Add inputs  node.getFirstInputSlot().addData(new FileData(Paths.get(\u0026#34;/data/image.tif\u0026#34;))); // The node requires a progress info  JIPipeProgressInfo progress = new JIPipeProgressInfo(); // Run the node  node.run(progress); // Extract the output  ImagePlusData image = node.getFirstOutputSlot().getData(0, ImagePlusData.class); } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/point/",
	"title": "Point",
	"tags": [],
	"description": "A point",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: point.schema.json\n A point   x:  integer       X coordinate   y:  integer       Y coordinate      Example { \u0026#34;x\u0026#34; : 2900, \u0026#34;y\u0026#34; : 100 } "
},
{
	"uri": "https://www.jipipe.org/documentation/standard-library/",
	"title": "Standard library",
	"tags": [],
	"description": "Contains some explanations about the algorithms that are included in the JIPipe standard distribution.",
	"content": "JIPipe comes with a standard library of data types, algorithms, and other functionality that makes it ready to use for most common image analysis projects. The library of course can be extended with plugins.\nPlease take a look at the following standard library components:\n ImageJ integration\nThis library provides integration of ImageJ data types, as well as common ImageJ algorithms.\n  Macro node\nThe macro node allows to run ImageJ macros.\n  Filesystem algorithms\nThis library provides data types for that wrap filesystem objects, as well as algorithms to navigate the filesystem and extract information.\n  Multi-parameter algorithms\nThis library provides the ability to manage algorithm parameter sets, generate parameters iteratively, and apply algorithms to multiple parameters at once.\n  Data annotation algorithms\nThis library provides basic functionality to add annotations to data slot rows.\n  Plots and tables\nThis library provides operations to generate and modify tables, as well as creating plots.\n  Python integration\nThis library provides nodes that allow to run Python scripts.\n  "
},
{
	"uri": "https://www.jipipe.org/documentation/create-json-extensions/",
	"title": "Extension builder",
	"tags": [],
	"description": "Explains the extension builder tool",
	"content": "JIPipe allows the creation of extensions that contain additional algorithms without the need for writing Java code. We recommend starting from a functional pipeline project and export the whole pipeline or a part of it into a JSON Extension. Alternatively, you can create custom algorithms from scratch within the extension builder.\nIf you want a step-by-step guideline on how to create a custom algorithm, please check out our tutorial.\nExporting from an existing pipeline Within the JIPipe interface, you can find contextual menu items and buttons that allow to generate an exported algorithm.\n To export the whole pipeline as algorithm, select Project \u0026gt; Export as custom algorithm To export a graph compartment, select it and click the Export button at the top-right corner. Then select  As custom algorithm To export a selection of nodes, click the Export button at the top-right corner. JIPipe ensures that connections within the selected nodes are exported as well. To export a single algorithm, click the Export button at the top-right corner. Please note that if the algorithm is a  Group algorithm, the group contents are exported instead of the group iself.  This will open a tab showing a preview of the pipeline. Select Export to extension to copy the custom algorithm into a new or existing extension.\n To open a new extension builder or load a JSON extension, you can use Plugins \u0026gt; New JSON extension ...  The extension builder The extension builder opens three tabs:\n A short introduction A tab that allows you to change the extension settings and metadata A tab that lists all algorithms that are part of the extension  Extension settings All extension metadata can be changed from within this tab. There are only three fields that are mandatory and one where you have to put special care in deciding about the value:\n Unique extension ID is the most important field. It contains a unique identifier that is utilized by JIPipe to figure out project and algorithm dependencies. It must have following format: [Author]:[Id] where [Author] contains information about the author (ideally in Maven-compatible format) and [Id] is the identifier if this extension within the author\u0026rsquo;s group. Version is not used by JIPipe but can be helpful for users to find issues Name is displayed in the plugin manager  You can write anything you want into the other metadata fields or leave them out.\nExtension contents This interface allows you to manage the list of algorithms that are contained within the extension. If you want, you can also create algorithms from scratch (although we do not recommend this as you cannot test pipelines within the extension builder). On selecting an algorithm, you can edit its metadata.\n Algorithm ID is the most important field. It uniquely identifies the algorithm within JIPipe. The ID is not namespaced (meaning that it is independent of the extension ID). We recommend to choose a meaningful name that can be easily expanded for specialized algorithms. Category determines in which menu the algorithm is shown. Please note that if you select DataSource, the algorithm will be placed in a menu based on the output data type. Choosing Internal is not allowed.  You can edit the graph that defines the algorithm\u0026rsquo;s workload by clicking  Edit algorithm. Use this to modify the pipeline to your needs and change parameters. Please note that you cannot test the pipeline.\n We recommend to check if you have some parameters that are invalid or dangerous (e.g. file paths that were copied when exportiong from a project). You algorithms should always have sane defaults.  Exporting parameters By default (this excludes exporting from a  Group algorithm) your algorithm will not have any parameters aside of the default ones (name, description, pass-though, and enabled). The extension builder comes with a powerful editor to reference parameters within the algorithm\u0026rsquo;s graph.\nExported parameters are organized in Groups with each group having a title and optional description. Each group holds a collection of parameter references that can be assigned a custom name and description. Click  Add group to create a new empty group or use the  Auto add algorithm button to import parameters from a node and automatically create groups.\nIn a group, you can use the  Add parameter button to create a reference.\n Hover over the blue  wrench icon to display information about the referenced parameter.   Each parameter can only be referenced once. You will get a warning if you have duplicate references. If you ignore the warning, JIPipe will just skip them when creating the parameter UI.   The parameter editor UI implements a sub-set of the parameter reference standard to prevent overloading the UI. You always can change the JSON file to control additional properties like a manual order of the parameter items.  "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/project/",
	"title": "Project",
	"tags": [],
	"description": "An analysis project",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: project.schema.json\n An analysis project   jipipe:project-type:  string  , x ∈ { project  (default) }       Used to identify this JSON as JIPipe project   metadata:  See metadata    [object Object]      General information about the project   dependencies:  object[]       Dependencies of this project See dependency        graph:  See graph    [object Object]      Contains the pipeline nodes   compartments:  object   [object Object]      For organization of compartments  compartment-graph:  See graph    [object Object]      Structural graph of compartments          Example { \u0026#34;jipipe:project-type\u0026#34; : \u0026#34;project\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Empty (3 compartments)\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;This template contains three compartments \u0026#39;Preprocessing\u0026#39;, \u0026#39;Analysis\u0026#39;, and \u0026#39;Postprocessing\u0026#39; that are connected to each other.\u0026#34;, \u0026#34;authors\u0026#34; : [ ], \u0026#34;website\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;dependencies\u0026#34; : [ { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Standard plots\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Commonly used plot types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:plots\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Integrates ImageJ algorithms into JIPipe\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-algorithms\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Filesystem types and algorithms\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types and algorithms for interacting with files and folders\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:filesystem\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Compartment management\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Data types required for graph compartment management\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:compartments\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; }, { \u0026#34;metadata\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;ImageJ integration\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Adds support for commonly used ImageJ data types\u0026#34;, \u0026#34;authors\u0026#34; : [ { \u0026#34;first-name\u0026#34; : \u0026#34;Zoltán\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Cseresnyés\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\u0026#34; }, { \u0026#34;first-name\u0026#34; : \u0026#34;Ruman\u0026#34;, \u0026#34;last-name\u0026#34; : \u0026#34;Gerst\u0026#34;, \u0026#34;affiliations\u0026#34; : \u0026#34;Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans-Knöll-Institute, Jena, Germany\\nFaculty of Biological Sciences, Friedrich-Schiller-University Jena, Germany\u0026#34; } ], \u0026#34;website\u0026#34; : \u0026#34;https://applied-systems-biology.github.io/jipipe/\u0026#34;, \u0026#34;license\u0026#34; : \u0026#34;BSD 2-Clause\u0026#34;, \u0026#34;citation\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;id\u0026#34; : \u0026#34;org.hkijena.jipipe:imagej-integration\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;1.0.0\u0026#34; } ], \u0026#34;additional-metadata\u0026#34; : { \u0026#34;pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe:pipeline-parameters\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.settings.JIPipeProjectInfoParameters\u0026#34;, \u0026#34;exported-parameters\u0026#34; : { \u0026#34;parameter-reference-groups\u0026#34; : [ ] } }, \u0026#34;org.hkijena.jipipe.ui:project-tabs\u0026#34; : { \u0026#34;jipipe:type\u0026#34; : \u0026#34;org.hkijena.jipipe.ui.project.JIPipeProjectTabMetadata\u0026#34;, \u0026#34;data\u0026#34; : { \u0026#34;open-tabs\u0026#34; : [ \u0026#34;singleton:INTRODUCTION\u0026#34;, \u0026#34;singleton:COMPARTMENT_EDITOR\u0026#34;, \u0026#34;graph-compartment:preprocessing\u0026#34;, \u0026#34;graph-compartment:analysis\u0026#34;, \u0026#34;graph-compartment:postprocessing\u0026#34; ], \u0026#34;selected-tab\u0026#34; : null } } }, \u0026#34;graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing-folder-list\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 300 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-folder-list\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;folder-paths\u0026#34; : [ \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5516\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5517\u0026#34;, \u0026#34;ATTC_IµL_3rdReplicate-Experiment-5518\u0026#34; ], \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Folder list\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;preprocessing-path-to-annotation\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 400, \u0026#34;y\u0026#34; : 500 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;path-to-annotation-simple\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;annotation-merge-strategy\u0026#34; : \u0026#34;OverwriteExisting\u0026#34;, \u0026#34;remove-extensions\u0026#34; : true, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;generated-annotation\u0026#34; : \u0026#34;Dataset\u0026#34;, \u0026#34;full-path\u0026#34; : false, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Path to annotation\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-list-files\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 700 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;folder-list-files\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;subfolder\u0026#34; : \u0026#34;in\u0026#34;, \u0026#34;recursive-follows-links\u0026#34; : true, \u0026#34;filters\u0026#34; : [ { \u0026#34;mode\u0026#34; : \u0026#34;Glob\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;*.tif\u0026#34;, \u0026#34;invert\u0026#34; : false } ], \u0026#34;only-filenames\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;recursive\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;List files\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-import-image\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 900 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;import-imagej-imgplus-from-file\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;generated-image-type\u0026#34; : \u0026#34;imagej-imgplus\u0026#34;, \u0026#34;title-annotation\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image title\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Import image\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;preprocessing-preprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Data\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 425, \u0026#34;y\u0026#34; : 1100 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis-gaussian-blur-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-blur-gaussian2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;sigma-y\u0026#34; : -1.0, \u0026#34;sigma-x\u0026#34; : 1.0, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Gaussian blur 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-auto-threshold-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-threshold-auto2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;method\u0026#34; : \u0026#34;Default\u0026#34;, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;dark-background\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Auto threshold 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-distance-transform-watershed-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 650 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-binary-dtwatershed2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Distance transform watershed 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-find-particles-2d\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 850 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;ij1-analyze-find-particles2d\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;min-particle-circularity\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:parallelization:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Find particles 2D\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;min-particle-size\u0026#34; : 0.0, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;annotation-type\u0026#34; : { \u0026#34;content\u0026#34; : \u0026#34;Image index\u0026#34;, \u0026#34;enabled\u0026#34; : false }, \u0026#34;max-particle-circularity\u0026#34; : 1.0, \u0026#34;split-slices\u0026#34; : true, \u0026#34;exclude-edges\u0026#34; : false, \u0026#34;measurements\u0026#34; : { \u0026#34;values\u0026#34; : [ \u0026#34;Centroid\u0026#34;, \u0026#34;PixelValueMinMax\u0026#34;, \u0026#34;Area\u0026#34; ] }, \u0026#34;max-particle-size\u0026#34; : \u0026#34;Infinity\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/has-parameter-slot\u0026#34; : false, \u0026#34;jipipe:parameter-slot-algorithm/attach-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/attach-only-non-default-parameter-annotations\u0026#34; : true, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-prefix\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;jipipe:parameter-slot-algorithm/parameter-annotations-use-internal-names\u0026#34; : false }, \u0026#34;analysis-analysis-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } }, \u0026#34;output\u0026#34; : { \u0026#34;Spore Mask\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore ROI\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-roi\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } }, \u0026#34;Spore measurements\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-results-table\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 100, \u0026#34;y\u0026#34; : 50 } }, \u0026#34;analysis\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 1050 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing-plot-tables\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 550, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;plot-from-table\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;plot-type\u0026#34; : \u0026#34;plot-histogram\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Plot tables\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null, \u0026#34;plot-parameters/export-height\u0026#34; : 768, \u0026#34;plot-parameters/value-axis-label\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;plot-parameters/bins\u0026#34; : 10, \u0026#34;plot-parameters/export-width\u0026#34; : 1024, \u0026#34;plot-parameters/bin-axis-label\u0026#34; : \u0026#34;Bin\u0026#34;, \u0026#34;plot-parameters/histogram-type\u0026#34; : \u0026#34;Frequency\u0026#34;, \u0026#34;plot-parameters/title\u0026#34; : \u0026#34;Histogram plot\u0026#34;, \u0026#34;column-assignments\u0026#34; : { \u0026#34;parameters\u0026#34; : { \u0026#34;Value\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Values to generate a histogram from. (Numeric column)\u0026#34;, \u0026#34;visibility\u0026#34; : \u0026#34;TransitiveVisible\u0026#34;, \u0026#34;field-class\u0026#34; : \u0026#34;org.hkijena.jipipe.extensions.tables.parameters.TableColumnSourceParameter\u0026#34;, \u0026#34;value\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;PickColumn\u0026#34;, \u0026#34;column-source\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;Equals\u0026#34;, \u0026#34;filter-string\u0026#34; : \u0026#34;Area\u0026#34;, \u0026#34;invert\u0026#34; : false }, \u0026#34;generator-source\u0026#34; : { \u0026#34;generator-type\u0026#34; : null, \u0026#34;generated-type\u0026#34; : \u0026#34;NumericColumn\u0026#34; } }, \u0026#34;short-key\u0026#34; : \u0026#34;Value\u0026#34;, \u0026#34;ui-order\u0026#34; : 0, \u0026#34;field-class-id\u0026#34; : \u0026#34;table-column-source\u0026#34; } } } }, \u0026#34;postprocessing-postprocessing-output\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { }, \u0026#34;output\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;postprocessing\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 1100, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;jipipe:algorithm:save-outputs\u0026#34; : true, \u0026#34;jipipe:algorithm:enabled\u0026#34; : true, \u0026#34;jipipe:algorithm:pass-through\u0026#34; : false, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing output\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing-plot-tables\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Image\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : true } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-import-image\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Files\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-preprocessing-output\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-gaussian-blur-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Data\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Mask\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-auto-threshold-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-distance-transform-watershed-2d\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-list-files\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Annotated paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Folders\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Measurements\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore measurements\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing-folder-list\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;preprocessing-path-to-annotation\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Folder paths\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Paths\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis-find-particles-2d\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis-analysis-output\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;ROI\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Spore ROI\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] }, \u0026#34;compartments\u0026#34; : { \u0026#34;compartment-graph\u0026#34; : { \u0026#34;nodes\u0026#34; : { \u0026#34;preprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 50 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;analysis\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Preprocessing\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 50, \u0026#34;y\u0026#34; : 250 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null }, \u0026#34;postprocessing\u0026#34; : { \u0026#34;jipipe:slot-configuration\u0026#34; : { \u0026#34;input\u0026#34; : { \u0026#34;Analysis\u0026#34; : { \u0026#34;slot-data-type\u0026#34; : \u0026#34;jipipe:compartment-output\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inherited-slot\u0026#34; : null, \u0026#34;name\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;custom-name\u0026#34; : null, \u0026#34;inheritance-conversions\u0026#34; : { } } } }, \u0026#34;jipipe:algorithm-ui-location\u0026#34; : { \u0026#34;DEFAULT\u0026#34; : { \u0026#34;Vertical\u0026#34; : { \u0026#34;x\u0026#34; : 188, \u0026#34;y\u0026#34; : 450 } } }, \u0026#34;jipipe:node-info-id\u0026#34; : \u0026#34;jipipe:project-compartment\u0026#34;, \u0026#34;jipipe:algorithm-compartment\u0026#34; : \u0026#34;DEFAULT\u0026#34;, \u0026#34;jipipe:node:name\u0026#34; : \u0026#34;Postprocessing\u0026#34;, \u0026#34;jipipe:node:description\u0026#34; : null } }, \u0026#34;edges\u0026#34; : [ { \u0026#34;source-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;postprocessing\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Analysis\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } }, { \u0026#34;source-algorithm\u0026#34; : \u0026#34;preprocessing\u0026#34;, \u0026#34;target-algorithm\u0026#34; : \u0026#34;analysis\u0026#34;, \u0026#34;source-slot\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;target-slot\u0026#34; : \u0026#34;Preprocessing\u0026#34;, \u0026#34;metadata\u0026#34; : { \u0026#34;ui-hidden\u0026#34; : false } } ] } } } "
},
{
	"uri": "https://www.jipipe.org/documentation-json-api/slot-definition/",
	"title": "Slot definition",
	"tags": [],
	"description": "Defines a data slot",
	"content": "This document describes the properties of the JSON API object. You also can access the document in JSON Schema format: slot-definition.schema.json\n Defines a data slot   slot-data-type:  string       The data type ID of the data stored in this slot   slot-type:  string  , x ∈ { Input  , Output  }       Determines if the slot is an input or an output   inherited-slot:  object      Only valid for output slot. Defines from which slot to inherit the data type. Can be '*' to select the first available slot.   name:  string       Unique slot name   custom-name:  object      User-customizable name. Only displayed in UI.   inheritance-conversions:  object   [object Object]     Only valid for slot inheritance. Applies conversiuons to the inherited type. Must contain map from input data type ID to output data type ID. Conversion is a finite text replacement system.      Example { \u0026#34;slot-data-type\u0026#34; : \u0026#34;imagej-imgplus-2d\u0026#34;, \u0026#34;slot-type\u0026#34; : \u0026#34;Output\u0026#34;, \u0026#34;inherited-slot\u0026#34; : \u0026#34;Input\u0026#34;, \u0026#34;inheritance-conversions\u0026#34;: { \u0026#34;imagej-imgplus-2d-greyscale-mask\u0026#34;: \u0026#34;imagej-imgplus-2d-greyscale-8u\u0026#34; }, \u0026#34;name\u0026#34; : \u0026#34;Output\u0026#34; } "
},
{
	"uri": "https://www.jipipe.org/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "https://www.jipipe.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.jipipe.org/",
	"title": "JIPipe",
	"tags": [],
	"description": "",
	"content": "Macro programming for everyone!  JIPipe is a graphical batch processing programming language for ImageJ that allows you to create macros without any programming  by just creating a flowchart!   Download now   Learn how to use it   Show examples     --  Intuitive user interface JIPipe comes with a modern and easy to use interface that is simple by default, but powerful when needed. All options are logically organized and located where you expect them to be.    Easy to learn JIPipe comes with helpful tools such as the Algorithm finder that guides you in creating a pipeline by offering compatible processing steps for your current data.    Easy to organize \u0026amp; document JIPipe allows you to organize your pipelines into compartments and node groups to help you to keep track of your analysis. Furthermore, you can document your pipeline by adding labels, names, and custom descriptions to inputs, outputs, and nodes.    Built on ImageJ JIPipe is built on the established ImageJ software and comes with commonly used ImageJ functions and plugins, just as CLIJ2 and MorphoLibJ. You can re-use your existing macros and ImageJ2 scripts and create easy-to-use graphical interfaces for them, which will also be available directly within ImageJ via JIPipe's two-way integration.    Easy sharing \u0026amp; extending JIPipe allows you to export your pipelines as custom nodes that can be installed just like any other ImageJ plugin. Programmers can make use of the powerful API to enhance the feature set even more.    Powerful result evaluation You can either analyze results directly after processing or load existing results directly into JIPipe. The powerful result analysis tool lets you import data back into ImageJ, or summarize and plot them directly within JIPipe.    Integrated table editor JIPipe comes with a tool to summarize and concatenate tables without any external tools. The tool can directly import table data generated by ImageJ.    Integrated plot editor JIPipe comes with a powerful plot builder that supports a multitude of different plot types, such as XY plots, bar charts, histograms, and box plots.     Do you want to try it?  You can try JIPipe right now in three simple steps!   Download ImageJ or open your existing ImageJ installation Activate the JIPipe update site (Help \u0026gt; Update ...) Run the JIPipe GUI from within the plugin menu   After starting JIPipe, we recommend you to follow our tutorial or load an example pipeline.   Do you have a question or require some help?  Please do not hesitate to contact us! You can always contact the JIPipe developers via the community, or via E-Mail. If you find a bug, you can also report it directly on GitHub.    Community   Send E-Mail   Report a bug    JIPipe was developed by Research Group Applied Systems BiologyHead: Prof. Dr. Marc Thilo Figge HKI-Center for Systems Biology of Infection Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI) Adolf-Reichwein-Straße 23, 07745 Jena, Germany       $(document).ready(function(){ // Landing page slideshow $('.landing-features').slick({ infinite: true, dots: true, slidesToShow: 3, slidesToScroll: 3, autoplay: true, autoplaySpeed: 10000, centerMode: true, centerPadding: '5rem', initialSlide: 1, responsive: [ { breakpoint: 1024, settings: { slidesToShow: 1, slidesToScroll: 1 } } ] }); });  "
},
{
	"uri": "https://www.jipipe.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]